{
  
    
        "post0": {
            "title": "2022/01/05/WED",
            "content": "- 예제1 . a=11 if a&lt;5: print(&#39;a=....1,2,3,4&#39;) elif a&gt;10: print(&#39;a=11,12,13,....&#39;) else: print(&#39;a=5,6,7,...,10&#39;) . a=11,12,13,.... . - 예제2 . a,b=2,3 if a==b: print(&#39;a=b&#39;) else: if a&lt;b: print(&#39;a&lt;b&#39;) else: print(&#39;a&gt;b&#39;) . a&lt;b . - 예제3 . a=2 if a==1: print(&#39;a=1&#39;) . 2이면 뭐 하라고 한 적 없으니까 그냥 아무것도 실행하지 않음 . for &#47928; . - 예제1-리스트! . for i in [1,2,3,4]: print(i) . 1 2 3 4 . i . 4 . i는 4로 저장되고 종료 . - 예제2- 튜플! . for i in (1,2,3,4): print(i) . 1 2 3 4 . - 예제3-스트링! . for i in &#39;1234&#39;: print(i) . 1 2 3 4 . - 의문 . for i in ???: print(i) . 에서 물음표 자리에 올 수 있는 것이 무엇일까? . - 예제4 . a=5 for i in a: print(i) . 이렇게 입력하면 에러 발생 . 5라고 출력될 줄 알았는데 아니었다. . 무슨 차이인가? . 1차원 이상의 자료에서 for문 정의가 가능하다 . - 예제5 . L=[[1,2,3],[3,4,5]] . for i in L: print(i) . [1, 2, 3] [3, 4, 5] . import pandas as pd df=pd.DataFrame(L) . df . 0 1 2 . 0 1 | 2 | 3 | . 1 3 | 4 | 5 | . for i in df: print(i) . 0 1 2 . column명 불러오는 건가? . import numpy as np ndr=np.array(L) . ndr . array([[1, 2, 3], [3, 4, 5]]) . for i in ndr: print(i) . [1 2 3] [3 4 5] . i . array([3, 4, 5]) . for&#47928;&#51032; &#46041;&#51089;&#50896;&#47532; . for i in ???: print(i) . ??? 자리에 올 수 있는 것은 dir()하여 __iter__()라는 메서드가 있는 object이다. . 이러한 오브젝트를 iterable한 object라 한다 . a=1 . dir(a) . [&#39;__abs__&#39;, &#39;__add__&#39;, &#39;__and__&#39;, &#39;__bool__&#39;, &#39;__ceil__&#39;, &#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__divmod__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__float__&#39;, &#39;__floor__&#39;, &#39;__floordiv__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__getnewargs__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__index__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__int__&#39;, &#39;__invert__&#39;, &#39;__le__&#39;, &#39;__lshift__&#39;, &#39;__lt__&#39;, &#39;__mod__&#39;, &#39;__mul__&#39;, &#39;__ne__&#39;, &#39;__neg__&#39;, &#39;__new__&#39;, &#39;__or__&#39;, &#39;__pos__&#39;, &#39;__pow__&#39;, &#39;__radd__&#39;, &#39;__rand__&#39;, &#39;__rdivmod__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__rfloordiv__&#39;, &#39;__rlshift__&#39;, &#39;__rmod__&#39;, &#39;__rmul__&#39;, &#39;__ror__&#39;, &#39;__round__&#39;, &#39;__rpow__&#39;, &#39;__rrshift__&#39;, &#39;__rshift__&#39;, &#39;__rsub__&#39;, &#39;__rtruediv__&#39;, &#39;__rxor__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__sub__&#39;, &#39;__subclasshook__&#39;, &#39;__truediv__&#39;, &#39;__trunc__&#39;, &#39;__xor__&#39;, &#39;as_integer_ratio&#39;, &#39;bit_length&#39;, &#39;conjugate&#39;, &#39;denominator&#39;, &#39;from_bytes&#39;, &#39;imag&#39;, &#39;numerator&#39;, &#39;real&#39;, &#39;to_bytes&#39;] . 예상대로 int클래스의 인스턴스는 __iter__()가 없다. . - 위에서 정의한 L(list), df, ndr(ndarray) 는 모두 __iter__() 함수가 있다. 따라서 iterable한 오브젝트이다. . iterable한 오브젝트는 iterator로 만들 수 있는 특징이 있다. . iterable한 오브젝트를 어떻게 iterator로 만드는가? . df . 0 1 2 . 0 1 | 2 | 3 | . 1 3 | 4 | 5 | . dfiter1=df.__iter__() . dfiter2=iter(df) . dfiter1? . Type: generator String form: &lt;generator object RangeIndex.__iter__ at 0x0000028645753270&gt; Docstring: &lt;no docstring&gt; . - dfiter1은 generator라는 클래스에서 만들어진 인스턴스 오브젝트이다. . dir(dfiter1) . [&#39;__class__&#39;, &#39;__del__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__name__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__next__&#39;, &#39;__qualname__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;, &#39;close&#39;, &#39;gi_code&#39;, &#39;gi_frame&#39;, &#39;gi_running&#39;, &#39;gi_yieldfrom&#39;, &#39;send&#39;, &#39;throw&#39;] . dfiter1.__next__() . 1 . next 메소드? 카운트 느낌!, BUT 영구적인 것은 아니고 STOP하게 됨 . . – for 문의 작동원리 . for i in L: print(i) . (1) iter함수를 사용해서 L이라는 오브젝트를 iterator로 만든다. L이라는 오브젝트가 이터러블하기 때문에 가능 . (2) iterator에서 .__next__()함수를 호출하고 결과를 i에 저장한뒤에 for문 블락안에 있는 내용(들여쓰기 된 내용)을 실행한다. . (3) StopIteration 에러가 발생하면 for 문을 멈춘다. . 이런 원리로 for문이 돌아가는 듯! . . Liter=iter(L) . Liter.__next__() . [1, 2, 3] . 123나오고 345 나오고 STOP . ndriter=iter(ndr) . print(ndriter.__next__()) . [1 2 3] . range() . - for문의 정석은 아래와 같이 range()를 사용하는 것이다. . for i in range(5): print(i) . 0 1 2 3 4 . in 다음애는 iterable만 가능 . - range(5)의 정체는 그냥 iterable object이다. . a=range(5) . - 그래서 언제든지 iterator로 바꿀 수 있다. . aiter=iter(a) . aiter.__next__() . 4 . 0~4까지 출력 후 error 출력 . &#51060;&#53552;&#47112;&#51060;&#53552;&#51032; &#44060;&#45392;&#51008; &#46356;&#48260;&#44613;&#50640; &#51025;&#50857;&#44032;&#45733; . for i in zip([1,2,3],&#39;abc&#39;): print(i) . (1, &#39;a&#39;) (2, &#39;b&#39;) (3, &#39;c&#39;) . zip([1,2,3],&#39;abc&#39;) . &lt;zip at 0x28645783d80&gt; . 어차피 for i in ????: ????의 자리는 iterable object 자리이다. . z=zip([1,2,3],&#39;abc&#39;) . dir(z) . [&#39;__class__&#39;, &#39;__delattr__&#39;, &#39;__dir__&#39;, &#39;__doc__&#39;, &#39;__eq__&#39;, &#39;__format__&#39;, &#39;__ge__&#39;, &#39;__getattribute__&#39;, &#39;__gt__&#39;, &#39;__hash__&#39;, &#39;__init__&#39;, &#39;__init_subclass__&#39;, &#39;__iter__&#39;, &#39;__le__&#39;, &#39;__lt__&#39;, &#39;__ne__&#39;, &#39;__new__&#39;, &#39;__next__&#39;, &#39;__reduce__&#39;, &#39;__reduce_ex__&#39;, &#39;__repr__&#39;, &#39;__setattr__&#39;, &#39;__sizeof__&#39;, &#39;__str__&#39;, &#39;__subclasshook__&#39;] . - __next__()함수가 있음 $ to$ z자체가 iterator였다. (iterable object 이면서) . z.__next__() . (2, &#39;b&#39;) . 첫번째, 두번째, 세번째 그리고 마지막엔 에러 . for i in ???: print(i) . - ??? 자리에 iterator 자체가와도 무방한 듯!!! . - 확인 . L=iter([1,2,3,4]) for i in L: print(i) . 1 2 3 4 . i . 4 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2022/01/05/intro3.html",
            "relUrl": "/2022/01/05/intro3.html",
            "date": " • Jan 5, 2022"
        }
        
    
  
    
        ,"post1": {
            "title": "2022/01/05/WED",
            "content": "maplotlib + seaborn . import matplotlib.pyplot as plt import numpy as np import seaborn as sns . x=[44,48,49,58,62,68,69,70,76,79] # 몸무게 y=[159,160,162,165,167,162,165,175,165,172] #키 g=&#39;F&#39;,&#39;F&#39;,&#39;F&#39;,&#39;F&#39;,&#39;F&#39;,&#39;M&#39;,&#39;M&#39;,&#39;M&#39;,&#39;M&#39;,&#39;M&#39; . plt.plot(x,y,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x1decec2b6a0&gt;] . sns.scatterplot(x=x,y=y,hue=g) . &lt;AxesSubplot:&gt; . - 두 그림을 나란히 겹쳐 그릴수 있을까? . fig, (ax1,ax2) = plt.subplots(1,2) ax1.plot(x,y,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x1decf4e8700&gt;] . sns.scatterplot(x=x,y=y,hue=g,ax=ax2) # ax=ax2 이 부분 추가 . &lt;AxesSubplot:&gt; . fig . fig.set_figwidth(8) . fig . ax1.set_title(&#39;matplotlib&#39;) ax2.set_title(&#39;seaborn&#39;) . Text(0.5, 1.0, &#39;seaborn&#39;) . fig . - 마치 matplotlib에 seaborn을 plugin하듯이 사용할 수 있다. . matplotlib vs seaborn . plt.plot([1,2,3],[3,4,5],&#39;x:r&#39;) . [&lt;matplotlib.lines.Line2D at 0x1decf720490&gt;] . &#50696;&#51228; . np.random.seed(43052) x=np.random.normal(size=1000,loc=2,scale=15) . - 이 자료가 정규분포를 따르는지 어떻게 체크할 수 있을까? . plt.hist(x) . (array([ 10., 24., 99., 176., 232., 222., 165., 53., 16., 3.]), array([-42.43984464, -33.38324282, -24.326641 , -15.27003917, -6.21343735, 2.84316447, 11.89976629, 20.95636811, 30.01296994, 39.06957176, 48.12617358]), &lt;BarContainer object of 10 artists&gt;) . - 종모양이므로 정규분포인듯 하다. . - 밀도추정곡선이 있었으면 좋겠다. (KDE로 추정) $ to$ seaborn을 활용하여 그려보자. . sns.histplot(x,kde=True) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - 종모양인것 같다. . - 그렇다면 아래는 어떤가? . np.random.seed(43052) from scipy.stats import t . y=t.rvs(10,size=1000) # rvs? random varieties of given type . sns.histplot(y,kde=True) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . - 종모양이다..? . - 비교 . fig, (ax1,ax2) = plt.subplots(1,2) sns.histplot(x,kde=True,ax=ax1) sns.histplot(y,kde=True,ax=ax2) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . xx= (x-np.mean(x)) / np.std(x,ddof=1) yy= (y-np.mean(y)) / np.std(y,ddof=1) fig, (ax1,ax2) = plt.subplots(1,2) sns.histplot(xx,kde=True,ax=ax1) sns.histplot(yy,kde=True,ax=ax2) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . xx= (x-np.mean(x)) / np.std(x,ddof=1) yy= (y-np.mean(y)) / np.std(y,ddof=1) fig, ((ax1,ax2),(ax3,ax4)) = plt.subplots(2,2) ax1.boxplot(xx) sns.histplot(xx,kde=True,ax=ax2) ax3.boxplot(yy) sns.histplot(yy,kde=True,ax=ax4) . &lt;AxesSubplot:ylabel=&#39;Count&#39;&gt; . fig.tight_layout() . fig . - 주의: 아래와 같이 해석하면 잘못된 해석이다. . $y$ 히스토그램을 그려보니 모양이 종모양이다. $ to$ $y$는 정규분포이다 | . - 관찰: boxplot을 그려보니 $y$의 꼬리가 정규분포보다 두꺼워 보인다. .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2022/01/05/intro2.html",
            "relUrl": "/2022/01/05/intro2.html",
            "date": " • Jan 5, 2022"
        }
        
    
  
    
        ,"post2": {
            "title": "2022/01/04/TUE",
            "content": "&#46972;&#51064;&#54540;&#46991; . import matplotlib.pyplot as plt x=[1,2,3,4] y=[1,2,4,3] plt.plot(x,y,&#39;:ok&#39;) . [&lt;matplotlib.lines.Line2D at 0x20657010eb0&gt;] . (1) &#44217;&#52432;&#44536;&#47532;&#44592; . import numpy as np x=np.arange(-5,5,0.1) y=2*x+np.random.normal(loc=0,scale=1,size=100) plt.plot(x,y,&#39;.:b&#39;) plt.plot(x,2*x,&#39;--r&#39;) . [&lt;matplotlib.lines.Line2D at 0x206585533d0&gt;] . (2) &#46384;&#47196;&#44536;&#47532;&#44592; - subplots . x=[1,2,3,4] y=[1,2,4,3] _ , s = plt.subplots(2,2) # subplots의 리턴값=(fig,axs) s[0,0].plot(x,y,&#39;o:r&#39;) s[0,1].plot(x,y,&#39;Xb&#39;) s[1,0].plot(x,y,&#39;xm&#39;) s[1,1].plot(x,y,&#39;.--k&#39;) . [&lt;matplotlib.lines.Line2D at 0x20658669190&gt;] . Anscombe&#39;s quartet . x = [10, 8, 13, 9, 11, 14, 6, 4, 12, 7, 5] y1 = [8.04, 6.95, 7.58, 8.81, 8.33, 9.96, 7.24, 4.26, 10.84, 4.82, 5.68] y2 = [9.14, 8.14, 8.74, 8.77, 9.26, 8.10, 6.13, 3.10, 9.13, 7.26, 4.74] y3 = [7.46, 6.77, 12.74, 7.11, 7.81, 8.84, 6.08, 5.39, 8.15, 6.42, 5.73] x4 = [8, 8, 8, 8, 8, 8, 8, 19, 8, 8, 8] y4 = [6.58, 5.76, 7.71, 8.84, 8.47, 7.04, 5.25, 12.50, 5.56, 7.91, 6.89] . _,s = plt.subplots(2,2) s[0,0].plot(x,y1,&#39;o&#39;) s[0,1].plot(x,y2,&#39;.&#39;) s[1,0].plot(x,y3,&#39;x&#39;) s[1,1].plot(x4,y4,&#39;X&#39;) . [&lt;matplotlib.lines.Line2D at 0x2065890b520&gt;] . 상관계수 | . - -1 ~ 1 사이의 값 . - 완전한 직선 = 상관계수가 1 또는 -1 . - 상관계수가 1에 가까우면 양의 상관관계에 있다고 말하고 -1에 가까우면 음의 상관관계 . - 자료의 모양이 직선모양에 가까우면 상관계수가 큰것이 맞나? . $x,y$ 값이 모두 큰 하나의 관측치가 상관계수값을 키울 수 있지 않나? | . - 상관계수가 좋은것은 맞나? (=상관계수는 두 변수의 관계를 설명하기에 충분히 적절한 통계량인가?) . n=len(x) xtilde = (x-np.mean(x)) / (np.std(x)*np.sqrt(n)) y1tilde = (y1-np.mean(y1)) / (np.std(y1)*np.sqrt(n)) . sum(xtilde*y1tilde) . 0.81642051634484 . np.corrcoef(x4,y4) . array([[1. , 0.81652144], [0.81652144, 1. ]]) . np.corrcoef([x,y1,y2,y3]) . array([[1. , 0.81642052, 0.81623651, 0.81628674], [0.81642052, 1. , 0.7500054 , 0.46871668], [0.81623651, 0.7500054 , 1. , 0.58791933], [0.81628674, 0.46871668, 0.58791933, 1. ]]) . - 위의 4개의 그림에 대한 상관계수는 모두 같다. (0.816) . - 상관계수는 두 변수의 관계를 설명하기에 부적절하다. . 상관계수는 1번그림과 같이 두 변수가 선형관계에 있을때 그 정도를 나타내는 통계량일뿐이다. | 선형관계가 아닌것처럼 보이는 자료에서는 상관계수를 계산할수는 있겠으나 의미가 없다. | .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2022/01/04/intro2.html",
            "relUrl": "/2022/01/04/intro2.html",
            "date": " • Jan 4, 2022"
        }
        
    
  
    
        ,"post3": {
            "title": "2022/01/03/MON",
            "content": "matplotlib &#49324;&#50857;&#48277; . &#50696;&#51228; 1: &#50529;&#49884;&#51592;&#47484; &#51060;&#50857;&#54620; &#54540;&#46991; . - 구조 : axis $ subset$ axes $ subset$ figure . import matplotlib.pyplot as plt . fig = plt.figure() # 도화지를 준비한다. . &lt;Figure size 432x288 with 0 Axes&gt; . fig # 현재 도화지상태를 체크 . &lt;Figure size 432x288 with 0 Axes&gt; . - 그림객체를 출력해봐야 아무것도 나오지 않는다. (아무것도 없으니까) . fig.add_axes() # fig에 액시즈를 추가 fig.axes # 현재 fig에 있는 액시즈 정보 . fig.axes # 현재 fig에 있는 액시즈 정보 . [] . fig.add_axes([0,0,1,1]) . &lt;Axes:&gt; . 도화지안에 (0,0) 위치에 길이가 (1,1) 인 네모틀을 만듦 . fig.axes # 현재 네모틀 상태를 체크 -&gt; 네모틀이 하나 있음. . [&lt;Axes:&gt;] . fig # 현재 도화지 상태 체크 -&gt; 도화지에 (하나의) 네모틀이 잘 들어가 있음 . axs1=fig.axes[0] ## 첫번째 액시즈 . axs1.plot([1,2,3],&#39;or:&#39;) # 첫번째 액시즈에 접근하여 그림을 그림 . [&lt;matplotlib.lines.Line2D at 0x19a41260d00&gt;] . fig #현재 도화지 상태 체크 --&gt; 그림이 잘 그려짐 . &#50696;&#51228;2: &#50529;&#49884;&#51592;&#47484; &#51060;&#50857;&#54620; &#49436;&#48652;&#54540;&#46991; (&#48169;&#48277;1) . fig # 현재 도화지 출력 . - 액시즈추가 . fig.add_axes([1,0,1,1]) # 1,0 위치에 길이 1,1 짜리 틀 추가 . &lt;Axes:&gt; . fig.axes . [&lt;Axes:&gt;, &lt;Axes:&gt;] . fig . axs2=fig.axes[1] ## 두번째 액시즈 . - 두번째 액시즈에 그림그림 . axs2.plot([1,2,3],&#39;ok&#39;) ## 두번째 액시즈에 그림그림 . [&lt;matplotlib.lines.Line2D at 0x19a413bdfd0&gt;] . fig ## 현재 도화지 체크 . - 첫번째 액시즈에 그림추가 . axs1.plot([1,2,3],&#39;--&#39;) ### 액시즈1에 점선추가 . [&lt;matplotlib.lines.Line2D at 0x19a413bd460&gt;] . fig ## 현재 도화지 체크 . &#50696;&#51228;3: &#50529;&#49884;&#51592;&#47484; &#51060;&#50857;&#54616;&#50668; &#49436;&#48652;&#54540;&#46991; (&#48169;&#48277;2) . fig = plt.figure() # 새로운 도화지 . &lt;Figure size 432x288 with 0 Axes&gt; . fig.axes . [] . fig.subplots(1,2) # default는 1,1 . array([&lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;], dtype=object) . fig.axes . [&lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;] . ax1,ax2 = fig.axes . ax1.plot([1,2,3],&#39;or&#39;) ax2.plot([1,2,3],&#39;ob&#39;) . [&lt;matplotlib.lines.Line2D at 0x19a416ba820&gt;] . fig . fig.set_figwidth(12) # 도화지 늘려보자 . fig . ax1.plot([1,2,3],&#39;--&#39;) . [&lt;matplotlib.lines.Line2D at 0x19a413341c0&gt;] . fig . &#50696;&#51228;4: &#50529;&#49884;&#51592;&#47484; &#51060;&#50857;&#54616;&#50668; 2$ times$2 &#49436;&#48652;&#54540;&#46991; &#44536;&#47532;&#44592; . fig = plt.figure() fig.axes . [] . &lt;Figure size 432x288 with 0 Axes&gt; . fig.subplots(2,2) fig.axes . [&lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;] . ax1,ax2,ax3,ax4=fig.axes . ax1.plot([1,2,3],&#39;ob&#39;) ax2.plot([1,2,3],&#39;or&#39;) ax3.plot([1,2,3],&#39;ok&#39;) ax4.plot([1,2,3],&#39;oy&#39;) . [&lt;matplotlib.lines.Line2D at 0x19a417ffd60&gt;] . fig . &#50696;&#51228;5: plt.subplots()&#47484; &#51060;&#50857;&#54616;&#50668; 2$ times$2 &#49436;&#48652;&#54540;&#46991; . x=[1,2,3,4] y=[1,2,4,3] _, axs = plt.subplots(2,2) axs[0,0].plot(x,y,&#39;o:r&#39;) axs[0,1].plot(x,y,&#39;Xb&#39;) axs[1,0].plot(x,y,&#39;xm&#39;) axs[1,1].plot(x,y,&#39;.--k&#39;) . [&lt;matplotlib.lines.Line2D at 0x19a41aab370&gt;] . 주의 . x=[1,2,3,4] y=[1,2,4,3] . _, axs = plt.subplots(2,2) . axs[0,0].plot(x,y,&#39;o:r&#39;) axs[0,1].plot(x,y,&#39;Xb&#39;) axs[1,0].plot(x,y,&#39;xm&#39;) axs[1,1].plot(x,y,&#39;.--k&#39;) . [&lt;matplotlib.lines.Line2D at 0x19a43184370&gt;] . _ . &#50696;&#51228;6: plt.subplots()&#47484; 2$ times$2 subplot &#44536;&#47532;&#44592; - &#50529;&#49884;&#51592;&#47484; &#44033;&#44033; &#48320;&#49688;&#47749;&#51004;&#47196; &#51200;&#51109; . x=[1,2,3,4] y=[1,2,4,3] fig, axs = plt.subplots(2,2) . axs # 중첩 리스트 형태로 들어가있음 . array([[&lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;], [&lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;]], dtype=object) . . 중첩리스트 형태라 . ax1,ax2,ax3,ax4 =axs . 이렇게하면 error . . (ax1,ax2), (ax3,ax4) = axs . ax1.plot(x,y,&#39;o:r&#39;) ax2.plot(x,y,&#39;Xb&#39;) ax3.plot(x,y,&#39;xm&#39;) ax4.plot(x,y,&#39;.--k&#39;) . [&lt;matplotlib.lines.Line2D at 0x23b4236a880&gt;] . fig . &#50696;&#51228;7: plt.subplots()&#47484; &#51060;&#50857;&#54616;&#50668; 2$ times$2 &#49436;&#48652;&#54540;&#46991; &#44536;&#47532;&#44592; - fig.axes&#50640;&#49436; &#51217;&#44540; . fig, _ = plt.subplots(2,2) . fig.axes . [&lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;] . ax1, ax2, ax3, ax4= fig.axes . ax1.plot(x,y,&#39;o:r&#39;) ax2.plot(x,y,&#39;Xb&#39;) ax3.plot(x,y,&#39;xm&#39;) ax4.plot(x,y,&#39;.--k&#39;) . [&lt;matplotlib.lines.Line2D at 0x19a435783d0&gt;] . fig . title &#49444;&#51221; . &#50696;&#51228;1: plt.plot() . x=[1,2,3] y=[1,2,2] . plt.plot(x,y,&#39;o:k&#39;) plt.title(&#39;fuck&#39;) . Text(0.5, 1.0, &#39;fuck&#39;) . &#50696;&#51228;2: &#50529;&#49884;&#51592;&#47484; &#51060;&#50857; . 기본적으로 1개 설정됨 . fig = plt.figure() fig.subplots() . &lt;AxesSubplot:&gt; . ax1=fig.axes[0] . ax1.set_title(&#39;title&#39;) . Text(0.5, 1.0, &#39;title&#39;) . fig . &#50696;&#51228;3: subplot&#50640;&#49436; &#44033;&#44033;&#51032; &#51228;&#47785;&#49444;&#51221; . fig, ax = plt.subplots(2,2) . axs . array([[&lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;], [&lt;AxesSubplot:&gt;, &lt;AxesSubplot:&gt;]], dtype=object) . (ax1,ax2),(ax3,ax4) =ax . ax1.set_title(&#39;title1&#39;) ax2.set_title(&#39;title2&#39;) ax3.set_title(&#39;title3&#39;) ax4.set_title(&#39;title4&#39;) . Text(0.5, 1.0, &#39;title4&#39;) . fig . fig.tight_layout() # 암기 . fig . &#50696;&#51228;4 : &#50529;&#49884;&#51592;&#51032; &#51228;&#47785; + Figure&#51228;&#47785; . 슈퍼타이틀=도화지 전체의 제목 명명 . fig.suptitle(&#39;sup title&#39;) . Text(0.5, 0.98, &#39;sup title&#39;) . fig . fig.tight_layout() . fig . 그냥 x=[1,2,3]만 입력해주면 (1,1)(2,2)(3,3)으로 값 설정됨 . x=[1,2,3] y=[4,5,6] . plt.plot(x,y,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x19a43700430&gt;] . 축 범위 재조정 中 . plt.plot(x,y,&#39;o&#39;) plt.xlim(-1,5) plt.ylim(3,7) . (3.0, 7.0) . &#50696;&#51228;2 . fig = plt.figure() fig.subplots() . &lt;AxesSubplot:&gt; . ax1=fig.axes[0] . import numpy as np . ax1.plot(np.random.normal(size=100),&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x19a437edf40&gt;] . fig . ax1.set_xlim(-10,110) ax1.set_ylim(-5,5) . (-5.0, 5.0) . fig . &#50696;&#51228;1 . np.linspace(-1,1,100,endpoint=True) . = start는 배열 시작값, stop은 배열의 끝 값, num은 start와 stop사이를 몇 개의 일정한 간격으로 요소를 만들 것인지, 만일 num을 생략하면 디폴트로 50개의 수열을 만들며, 마지막 endpoint가 의미하는 것은 stop으로 주어진 값을 포함시킬 것인지 아닌지를 선택하는 옵션 . np.random.seed(43052) x1=np.linspace(-1,1,100,endpoint=True) y1=x1**2+np.random.normal(scale=0.1,size=100) . axs1=plt.plot(x1,y1,&#39;o:m&#39;) axs1=plt.title(&#39;y=x**2&#39;) . np.corrcoef(x1,y1) . array([[1. , 0.00688718], [0.00688718, 1. ]]) . 상관계수의 값이 0에 가까운 것은 두 변수의 직선관계가 약한것을 의미하는 것, 두 변수 사이에 아무런 함수관계가 없다는 것을 의미하는 것은 아니다. | . &#50696;&#51228;2 . - 아래와 같은 자료를 고려하자. . np.random.seed(43052) x2=np.random.uniform(low=-1,high=1,size=100000) y2=np.random.uniform(low=-1,high=1,size=100000) . axs2=plt.plot(x2,y2,&#39;.&#39;) axs2=plt.title(&#39;rect&#39;) . np.corrcoef(x2,y2) . array([[1. , 0.00521001], [0.00521001, 1. ]]) . &#50696;&#51228;3 . np.random.seed(43052) _x3=np.random.uniform(low=-1,high=1,size=100000) _y3=np.random.uniform(low=-1,high=1,size=100000) . plt.plot(_x3,_y3,&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x19a44dae280&gt;] . radius = _x3**2+_y3**2 . x3=_x3[radius&lt;1] y3=_y3[radius&lt;1] plt.plot(_x3,_y3,&#39;.&#39;) plt.plot(x3,y3,&#39;.&#39;) . [&lt;matplotlib.lines.Line2D at 0x19a44e281f0&gt;] . axs3=plt.plot(x3,y3,&#39;.&#39;) axs3=plt.title(&#39;circ&#39;) . np.corrcoef(x3,y3) . array([[ 1. , -0.00362687], [-0.00362687, 1. ]]) .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2022/01/03/intro2.html",
            "relUrl": "/2022/01/03/intro2.html",
            "date": " • Jan 3, 2022"
        }
        
    
  
    
        ,"post4": {
            "title": "2022/01/02/SUN",
            "content": "흑백 $ to$ 차원: 세로픽셀수 $ times$ 가로픽셀수, 값: 0~255 (값이 클수록 흰색) | . 칼라 $ to$ 차원: 세로픽셀수 $ times$ 가로픽셀수 $ times$ 3, 값: 0~255 (값이 클수록 진한빨강, 진한파랑, 진한녹색) | . import cv2 as cv . bd=cv.imread(&#39;KakaoTalk_20210927_192557462.jpg&#39;) . import matplotlib.pyplot as plt plt.imshow(bd) . &lt;matplotlib.image.AxesImage at 0x1df8e565d90&gt; . bd.shape . (1084, 1084, 3) . (1084, 1084, 3) -&gt; 빨강으로만 표현된 사진, 파랑, 초록 각각으로 표현된 사진, 세사진이 겹쳐진 것을 의미 | . zeros_like -&gt; 초기화 | . [ : , : , 0 ] =&gt; 첫부분하고 두번째 부분은 세로,가로 픽셀수를 의미 마지막 숫자가 0,1,2순서대로 RGB임 | . import numpy as np bd_red=np.zeros_like(bd) #아예 초기화 bd_green=np.zeros_like(bd) #아예 초기화 bd_blue=np.zeros_like(bd) #아예 초기화 bd_red[:,:,0]=bd[:,:,0] bd_green[:,:,1]=bd[:,:,1] bd_blue[:,:,2]=bd[:,:,2] . plt.imshow(bd_red) . &lt;matplotlib.image.AxesImage at 0x1df8fab19a0&gt; . plt.imshow(bd_blue+bd_red) . &lt;matplotlib.image.AxesImage at 0x1df901f81c0&gt; . &#49328;&#51216;&#46020; (scatter plot) . import matplotlib.pyplot as plt . x=[1,2,3,4] y=[2,3,4,5] plt.plot(x,y,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x1df8feb2ee0&gt;] . deafult : line | 산점도는 보통 X와 Y의 관계를 알고 싶을 경우 그린다. | 박스플랏, 히스토그램은 그림을 그리기 위해서 하나의 변수만 필요함 | 따라서 산점도를 위해서는 두개의 변수가 필요함. | . x=[44,48,49,58,62,68,69,70,76,79] y=[159,160,162,165,167,162,165,175,165,172] . plt.plot(x,y,&#39;ok&#39;) . [&lt;matplotlib.lines.Line2D at 0x1df8ff27940&gt;] . 키가 큰 사람일수록 몸무게도 많이 나간다. (반대도 성립) | 키와 몸무게는 관계가 있어보인다. (정비례) | . 얼만큼 정비례인지? | 이 질문에 대답하기 위해서는 상관계수의 개념을 알아야 한다. | 상관계수에 대한 개념은 산점도를 이해함에 있어서 핵심개념이다. | . $$ (표본)상관계수 $$ . $$r= frac{ sum_{i=1}^{n}(x_i- bar{x})(y_i- bar{y}) }{ sqrt{ sum_{i=1}^{n}(x_i- bar{x})^2 sum_{i=1}^{n}(y_i- bar{y})^2 }} $$ . $$r= sum_{i=1}^{n} frac{1}{c}(x_i- bar{x})(y_i- bar{y}) $$ . $$r= sum_{i=1}^{n} left( frac{(x_i- bar{x})}{ sqrt{ sum_{i=1}^{n}(x_i- bar{x})^2}} frac{(y_i- bar{y})}{ sqrt{ sum_{i=1}^{n}(y_i- bar{y})^2}} right)$$ . $$ tilde{x}_i= frac{(x_i- bar{x})}{ sqrt{ sum_{i=1}^n(x_i- bar{x})^2}}, tilde{y}_i= frac{(y_i- bar{y})}{ sqrt{ sum_{i=1}^n(y_i- bar{y})^2}}$$ . $$r= sum_{i=1}^{n} tilde{x}_i tilde{y}_i $$ . import numpy as np x=np.array(x) y=np.array(y) . plt.plot(x-np.mean(x), y-np.mean(y),&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x1df8ff989a0&gt;] . - $a= sqrt{ sum_{i=1}^{n}(x_i- bar{x})^2}, b= sqrt{ sum_{i=1}^{n}(y_i- bar{y})^2}$ . a=np.sqrt(np.sum((x-np.mean(x))**2)) b=np.sqrt(np.sum((y-np.mean(y))**2)) a,b . (36.58004920718396, 15.218409903797438) . $a&gt;b$ 이므로 $ {x_i }$들이 $ {y_i }$들 보다 좀 더 퍼져있다. . $a= sqrt{n} times{ tt np.std(x)}$ . $b= sqrt{n} times{ tt np.std(y)}$ . std = 표준편차 . n=len(x) np.sqrt(n)*np.std(x), np.sqrt(n)*np.std(y) . (36.58004920718397, 15.21840990379744) . ${ tt np.std(x)}= sqrt{ frac{1}{n} sum_{i=1}^{n}(x_i- bar{x})^2}$ | ${ tt np.std(y)}= sqrt{ frac{1}{n} sum_{i=1}^{n}(y_i- bar{y})^2}$ | . - 이제 $( tilde{x}_i, tilde{y}_i)$를 그려보자. . xx= (x-np.mean(x))/a yy= (y-np.mean(y))/b plt.plot(xx,yy,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x1df90009e80&gt;] . 평균도 비슷하고 퍼진정도도 비슷하다. | . - 질문1: $r$의 값이 양수인가? 음수인가? . plotly 사용하여 그려보자. . # px.scatter(x=xx, y=yy) . $ tilde{x}_i$, $ tilde{y}_i$ 를 곱한값이 양수인것과 음수인것을 체크해보자. | 양수인쪽이 많은지 음수인쪽이 많은지 생각해보자. | $r= sum_{i=1}^{n} tilde{x}_i tilde{y}_i$ 의 부호는? +가 -보다 많은 것으로 보아 상관계수의 부호는 +임을 알 수 있다 | . - 질문2 : 아래와 같은 두개의 데이터 set이 있다고 하자. . x1=np.arange(0,10,0.1) y1=x1+np.random.normal(loc=0,scale=1.0,size=len(x1)) . plt.plot(x1,y1,&#39;o&#39;) . [&lt;matplotlib.lines.Line2D at 0x1df92eb2a90&gt;] . x2=np.arange(0,10,0.1) y2=x2+np.random.normal(loc=0,scale=7.0,size=len(x2)) # 표준편차 업그레이드 plt.plot(x2,y2,&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x1df92f209d0&gt;] . 아래는 겹쳐 그린 것 . plt.plot(x1,y1,&#39;o&#39;) plt.plot(x2,y2,&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x1df92f901c0&gt;] . n=len(x1) xx1= (x1-np.mean(x1)) / (np.std(x1) * np.sqrt(n)) yy1= (y1-np.mean(y1)) / (np.std(y1) * np.sqrt(n)) xx2= (x2-np.mean(x2)) / (np.std(x2) * np.sqrt(n)) yy2= (y2-np.mean(y2)) / (np.std(y2) * np.sqrt(n)) . plt.plot(xx1,yy1,&#39;o&#39;) plt.plot(xx2,yy2,&#39;x&#39;) . [&lt;matplotlib.lines.Line2D at 0x1df92feef70&gt;] . (1) $r_1$, $r_2$의 부호는 양수인가? 음수인가? . $r_1$ 의 부호는 양수 $r_2$ 의 부호도 대충 양수임을 알 수 있음 $ to$ 1,2,3,4분면으로 나눠서 1,3사분면에 많은 분포가 있을수록 상관계수의 부호는 양수일 확률이 높다 | . (2) $r_1,r_2$의 값중 어떠한 값이 더 절대값이 큰가? . r1의 절댓값이 더 클 것. 왜냐하면 r2는 2사분면 4사분면이 값이 음수라 양수값들을 상쇄시키기 때문에 절댓값의 크기 또한 작아질 것이다. | . sum(xx1*yy1),sum(xx2*yy2) . (0.9381086706782814, 0.36042715437479517) . 파란색의 계수값이 더 크므로 더 강한 직선성을 띈다고 할 수 있다 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2022/01/02/intro2.html",
            "relUrl": "/2022/01/02/intro2.html",
            "date": " • Jan 2, 2022"
        }
        
    
  
    
        ,"post5": {
            "title": "2022/01/01/SAT",
            "content": "참고 : github.com/guebin 최규빈 교수님 강의 자료 | . - &#48136;? &#51064;&#53552;&#45367; &#48136;? . &#48136; . 한 사람 혹은 집단에서 다른 지성으로 생각 혹은 믿음이 전달될 때 전달되는 모방 가능한 사회적 단위를 총칭 | . &#51064;&#53552;&#45367; &#48136; . 밈의 한 형태 | 인터넷을 통해 사람들에게 전파되는 어떤 생각, 행동, 스타일 등 | . . &#53364;&#47000;&#49828; . 많은 교재에서 정의를 회피함 | 비유적 설명 , 다른 대상을 가져와서 설명 클래스는 과자틀과 비슷하다. 클래스란 똑같은 무엇인가를 계속 만들어 낼 수도 있는 설계도면이고 객체란 클래스로 만든 피조물을 뜻한다. | . | . 직접적 설명 복제를 위한 확장가능한 프로그램 코드의 유닛 | . | . . 밈의 예제로 돌아가보자. . (1) 무야호 원본 시청 . (2) 복사하고 싶은 속성을 추림 . (3) 복제가능한 어떤 밈(틀)을 만듬 . 틀1: 무야호~~~ -&gt; 그만큼 ~하셨다는거지? | 틀2: 무야호 + 영상샘플링 + 음악샘플링 | . (4) 밈으로부터 짤을 만든다. . . 좀더 정리하여 말하면, . (1) 개념의 인지 . (2) 복사하고 싶은 속성을 추림 . (3) 복사가능한 어떤 틀을 만듬 (=클래스를 정의) . (4) 틀에서 인스턴스를 만든다 (=클래스에서 인스턴스를 만든다) . . [&#50696;&#51228;1] . 농심에서 나온 무파마를 먹고, 너무 맛있어서 갑자기 밈으로 놀고 싶어졌다. . from PIL import Image Image.open(&#39;mooyaho1.jpg&#39;).resize((200,200)) . &#52395; &#49884;&#46020;: &#45800;&#49692;&#47924;&#49885; . title=&quot;농심 무파마&quot; img=Image.open(&#39;mooyaho1.jpg&#39;).resize((200,200)) don=&quot;그만큼 맛있으시단거지&quot; . print(title) display(img) print(don) . 농심 무파마 . 그만큼 맛있으시단거지 . 짤을 변경하고 싶다면, 아래와 같이 수행하자. | . title=&quot;속 시원한 농심 무야호&quot; print(title) display(img) print(don) . 속 시원한 농심 무야호 . 그만큼 맛있으시단거지 . 첫 시도의 허점 . 변용 가능한 여러개 짤을 관리하기 힘들다. | 불필요한 반복도 많다. print, display, print &lt;-- 짤을 만들때마다 반복 | 코드가 지저분하다. (디버깅이 힘들다) | . &#46160;&#48264;&#51704; &#49884;&#46020;: &#47784;&#46280; . import mooyaho . mooyaho.memeshow(mooyaho.title, mooyaho.img,mooyaho.don) . 농심 무파마 . 그만큼 맛있으시단거지 . 타이틀을 바꾸고싶다면? | . mooyaho.title=&#39;속시원한 농심 무야호&#39; mooyaho.memeshow(mooyaho.title, mooyaho.img, mooyaho.don) . 속시원한 농심 무야호 . 그만큼 맛있으시단거지 . 두 번째 시도의 아쉬운 점 코드는 상대적으로 깔끔하지만, 함수부분이 조금 아쉽다. | 코드를 수정할때마 커널재시작을 해야한다. | . | . &#49464;&#48264;&#51704; &#49884;&#46020;: &#53364;&#47000;&#49828; . &#48373;&#51228;&#44032;&#45733;&#54620; &#53952;&#51012; &#47564;&#46308;&#51088; = &#53364;&#47000;&#49828;&#47484; &#49440;&#50616;&#54616;&#51088; . class MooYaHo(): ### MooYaHo라는 이름을 가진 클래스 선언 title=&quot;농심 무파마&quot; ### 클래스안에서 정의된 변수1 img=Image.open(&#39;mooyaho1.jpg&#39;).resize((200,200)) ### 클래스안에서 정의된 변수2 don=&quot;그만큼 맛있으시단거지&quot; ### 클래스안에서 정의된 변수3 def memeshow(self): ### 클래스안에서 정의된 함수* print(self.title) display(self.img) print(self.don) . 모듈버전과 비교해보자. | . from PIL import Image title=&quot;농심 무파마&quot; ### 모듈안에서 정의된 변수1 img=Image.open(&#39;mooyaho1.jpg&#39;).resize((200,200)) ### 모듈안에서 정의된 변수2 don=&quot;그만큼 맛있으시단거지&quot; ### 모듈안에서 정의된 변수3 def memeshow(title,img,don): ### 모듈안에서 정의된 함수 print(title) display(img) print(don) . $ to$ 모듈버전이랑 비교하니까 함수부분이 조금 다르다. . $ to$ 혹시 모듈처럼 아래와 같이 클래스를 선언해도 되지 않나? . class MooYaHo(): ### MooYaHo라는 이름을 가진 클래스 선언 title=&quot;농심 무파마&quot; ### 클래스안에서 정의된 변수1 img=Image.open(&#39;mooyaho1.jpg&#39;).resize((200,200)) ### 클래스안에서 정의된 변수2 don=&quot;그만큼 맛있으시단거지&quot; ### 클래스안에서 정의된 변수3 def memeshow(title,img,don): ### 클래스안에서 정의된 함수 print(title) display(img) print(don) . $ to$ 안 됨 (자세한 이유는 나중에) . 규칙1: 클래스내에서 함수를 선언하면 반드시 첫번째 인자는 self를 넣어야 한다. --&gt; self가 뭘까? . 규칙2: 클래스 내에서 정의한 변수 (예를들면 title, img, don)를 사용하려면 . self.title, self.img, self.don | MooYaHo.title, MooYaHo.img, MooYaHo.don | . &#48136;&#51004;&#47196; &#48512;&#53552; &#51684;&#51012; &#47564;&#46304;&#45796;. (&#53364;&#47000;&#49828;&#47196;&#48512;&#53552; &#51064;&#49828;&#53556;&#49828;&#47484; &#49373;&#49457;&#54620;&#45796;.) . Step1: 클래스에서 인스턴스를 만듬 . Step2: 인스턴스에서 memeshow라는 함수를 사용 . 클래스에서 인스턴스를 찍어내는 방법 . 함수사용법과 비슷 | 클래스 이름을 쓰고 콘텐츠를 구체화시키는 과정에서 필요한 입력1, 입력2를 ()에 넣는다. | MooYaHo의 경우는 따로 입력이 없으므로, 그냥 MooYaHo하고 입력을 비워둔다. 즉 MooYaHo()로 생성 | . moo1=MooYaHo() ### 첫번째 인스턴스 생성 . moo1? . Type: MooYaHo String form: &lt;__main__.MooYaHo object at 0x0000024E7565C730&gt; Docstring: &lt;no docstring&gt; . Type이 MooYaHo $ dots$ . 원래 Type은 int, float, list 이어야 할텐데..? int 가 클래스이름이었나? $ to$ 일단 나중에 . 밈의 속성 확인 . moo1.하고 탭을 눌러봤더니 아래 같은 것들이 나왔다 . 주황색: don, img, title | 파란식: memeshow &lt;- 함수 함수의 입력: self | 함수의 기능: print, display, print | . | . moo1.memeshow() . 농심 무파마 . 그만큼 맛있으시단거지 . &#53364;&#47000;&#49828;&#51032; &#50948;&#47141; . 성능1: 인스턴스에서 .을 찍고 접근할 수 있는 여러 자료들을 정의할 수 있다. . moo1.title . &#39;농심 무파마&#39; . 성능2: 인스턴스에서 .을 찍고 쓸 수 있는 자체적인 함수(=method라고 함)를 정의할 수 있다. . moo1.memeshow() . 농심 무파마 . 그만큼 맛있으시단거지 . 성능3: 짤의 내용을 쉽게 바꿀 수 있다. . moo1.title=&quot;속까지 시원해지는 농심 무야호&quot; . moo1.memeshow() . 속까지 시원해지는 농심 무야호 . 그만큼 맛있으시단거지 . moo1.don=&quot;그만큼 시원하시다는 거지&quot; moo1.memeshow() . 속까지 시원해지는 농심 무야호 . 그만큼 시원하시다는 거지 . 성능4: 여러짤을 동시에 쉽게 컨트롤 할 수 있다. . moo2=MooYaHo() moo3=MooYaHo() . moo2.title=&quot;오뚜기 진야호&quot; moo2.don=&quot;그만큼 진하시다는 거지~&quot; moo2.memeshow() . 오뚜기 진야호 . 그만큼 진하시다는 거지~ . moo3.title=&quot;팔도 비야호&quot; moo3.don=&quot;그만큼 비비고 싶으셨단 거지~&quot; moo3.memeshow() . 팔도 비야호 . 그만큼 비비고 싶으셨단 거지~ . moo2.memeshow() . 오뚜기 진야호 . 그만큼 진하시다는 거지~ . 성능 5: 틀의 재설계(밈의 재설계) $ star$$ star$$ star$ . 출력만 살짝 바꾸어서 MooYaHo2를 만들고 싶다. --&gt; MooYaHo의 모든 내용은 그대로 가져오고, 그 살짝만 다시 조정하면 된다. . #### 이런식으로 할 필요 없다. class MooYaHo2(): ### MooYaHo라는 이름을 가진 클래스 선언 title=&quot;농심 무파마&quot; ### 클래스안에서 정의된 변수1 img=Image.open(&#39;mooyaho1.jpg&#39;).resize((200,200)) ### 클래스안에서 정의된 변수2 don=&quot;그만큼 맛있으시단거지&quot; ### 클래스안에서 정의된 변수3 def memeshow(self): ### 클래스안에서 정의된 함수* print(&#39;☆☆☆☆☆☆[&#39;+self.title+&#39;]☆☆☆☆☆☆&#39;) display(self.img) print(&#39;형돈:&#39;+self.don) . class MooYaHo2(MooYaHo): choi=&#39;무야~~~~~호~~~!!!&#39; def memeshow(self): ### 클래스안에서 정의된 함수* print(&#39;☆☆☆☆☆☆[&#39;+self.title+&#39;]☆☆☆☆☆☆&#39;) display(self.img) print(self.choi) print(&#39;형돈:&#39;+self.don) . moo4=MooYaHo2() . moo4.memeshow() . ☆☆☆☆☆☆[농심 무파마]☆☆☆☆☆☆ . 무야~~~~~호~~~!!! 형돈:그만큼 맛있으시단거지 . moo5=MooYaHo2() . moo5.title=&#39;오뚜기 진야호&#39; moo5.don=&#39;그만큼 진하시다는 거지&#39; moo5.memeshow() . ☆☆☆☆☆☆[오뚜기 진야호]☆☆☆☆☆☆ . 무야~~~~~호~~~!!! 형돈:그만큼 진하시다는 거지 . . &#50696;&#51228;2 . clss안에 있는 함수는 첫번째 인자로 self를 받고 변수 사용할 때는 self.이라고 사용 . 아래 셀에서 Meme은 class의 name이다 . import numpy class Meme: # class Meme(): n=0 #짤 생성 횟수 title=&quot;농심&quot; def memeshow(self): self.n+=1 print(self.title) print(&quot;*****&quot;) print(numpy.random.normal()) print(&quot;*****&quot;) print(str(self.n)+&#39;번째 짤&#39;) . ins1=Meme() . ins1.memeshow() . 농심 ***** 0.2916597433173283 ***** 2번째 짤 . ins2=Meme() . ins2.title=&#39;삼양&#39; . ins2.memeshow() . 삼양 ***** 0.608642243170386 ***** 1번째 짤 . ins2.n . 1 . ins1.n . 2 . ㄴㅇㄱ 아?! self에 들어가야했던것은 사실 인스턴스 이름이었음. . 그런데 인스턴스 이름은 모른다. (내가 뭘로 만들지 알고? ) . 그래서 그냥 self로 하는것임. . #### &#50696;&#51228;3 . 아래코드가 아쉽다. . $ to$ 왜 아쉽지? . $ to$ 왜 굳이 default가 농심이여서 instanc 생설할 때마다 title을 수정해줘야지? . ins2=Meme() ins2.title=&#39;삼양&#39; . title이 無디폴트였으면 좋겠다. . &#51064;&#49828;&#53556;&#49828;&#47484; &#47564;&#46308;&#46412;&#47560;&#45796; &#53440;&#51060;&#53952;&#51012; &#49352;&#47196; &#51221;&#54616;&#45716; &#48169;&#49885;&#51060; &#51080;&#51004;&#47732; &#51339;&#44192;&#45796;. . &#44536; &#45824;&#50504;&#51060; : __init__ . __init__ . 인스턴스가 생성되는 시점에 자동 실행 | 특별한 첫번째 인자를 가진다(self) | 클래스를 인스턴스화 할때 ( )의 값들을 함수의 입력으로 받는다. | . Meme2 라는 새로운 class를 정의中 . *&#51452;&#51032;* . def `__init__`(self,title): . 에서 self.title이 아니라 self,title같이 콤마를 사용해야한다. . 그런데 첫번째 인자를 굳이 self로 안 받아도 되는 것 같긴 함 . class Meme2: n=0 def __init__(a,title): a.title=title def memeshow(a): a.n=a.n+1 print(a.title) print(&quot;*****&quot;) print(numpy.random.normal()) print(&quot;*****&quot;) print(str(a.n)+&#39;번째 짤&#39;) . ins3=Meme2(&#39;팔도&#39;) . ins3.title . &#39;팔도&#39; . ins3.memeshow() . 팔도 ***** -1.9895310742180208 ***** 3번째 짤 . . (1) Meme2()를 인스턴스화 하는 순간에 __init__ 이 실행되어야함. . (2) 그런데 __init__의 첫번째 인자인 self는 입력 안해도 된다고 치고, 두번째 인수인 title은 입력으로 받았어야만 하는것인데, 입력으로 받지못하여 에러메시지 발생. . (3) 도대체 그럼 언제 __init__의 두번째 인수인 title을 넣어야할까? 곰곰히 생각해보니 Meme2를 인스턴스화 하는 순간에 입력으로 넣었어야 논리적으로 맞다. 즉 ins3=Meme2(&#39;팔도&#39;)와 같은 식으로 생성하는 순간 입력으로 넣어야 하는 것이었음. . (4) __init__의 두번째 인자가 &#39;팔도&#39;로 입력되었고, 이것이 self.title 즉 ins3.title에 바로 업데이트 된 상황임. . . 코드의 효율적인 수정 . Meme2는 Meme을 상속받는 中 . class Meme2(Meme): def __init__(self,title): self.title=title . ins3=Meme2(&#39;팔도&#39;) . ins3.memeshow() . 팔도 ***** -2.1018660318391236 ***** 1번째 짤 . ins4=Meme2(&#39;오뚜기&#39;) . ins4.memeshow() . 오뚜기 ***** 0.25483170477981176 ***** 1번째 짤 . . 욕심: 타이틀이 없다고 에러메시지를 띄우는것 보다 없으면 없는대로 만들어도 되지 않을까? . class Meme3(Meme): def __init__(self,title=None): self.title=title . ins5=Meme3() . ins5.title . title을 None으로 설정해놔서 title이 출력되지 않은 상황임 . ins5.memeshow() . None ***** 0.6307634191745345 ***** 1번째 짤 . ins5.title=&#39;야구르트&#39; . ins5.title . &#39;야구르트&#39; . ins5.memeshow() . 야구르트 ***** -1.3387268900814815 ***** 2번째 짤 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2022/01/01/intro3.html",
            "relUrl": "/2022/01/01/intro3.html",
            "date": " • Jan 1, 2022"
        }
        
    
  
    
        ,"post6": {
            "title": "2022/01/01/SAT(HappyNewYear)",
            "content": "Histogram Equalization, HE :&#51060;&#48120;&#51648; &#47749;&#50516;&#45824;&#48708; &#44060;&#49440; . import cv2 as cv import matplotlib.pyplot as plt import pandas as pd . img = cv.imread(&#39;KakaoTalk_20210927_192557462.jpg&#39;,0) # 이미지 저장하는 과정 . 마지막 숫자 0 : 이미지를 흑백으로 저장 | cmap = &#39;gray&#39; =&gt; 흑백으로 불러와라 . | vmin &amp; vmax의 범위는 명암 범위? 뭐 이런 것 같음 . | . plt.imshow(img,cmap=&#39;gray&#39;,vmin=0,vmax=255) plt.colorbar() . &lt;matplotlib.colorbar.Colorbar at 0x25cfb4eeaf0&gt; . img . array([[235, 233, 228, ..., 224, 224, 224], [229, 231, 231, ..., 222, 222, 222], [226, 227, 231, ..., 223, 223, 223], ..., [227, 231, 224, ..., 29, 20, 26], [230, 235, 229, ..., 21, 10, 15], [238, 239, 233, ..., 19, 14, 20]], dtype=uint8) . - 이미지자료 : 0(검정)~255(흰색) 사이의 어떠한 숫자들이 포함된 매트릭스 . 2차원으로 이루어졌음 . plt.imshow(img[500:600,500:600],cmap=&#39;gray&#39;,vmin=0,vmax=255) . &lt;matplotlib.image.AxesImage at 0x25cfb57e2b0&gt; . img.shape . (1084, 1084) . 이미지는 1084x1084=1175056 개의 숫자의 모임 | 벡터로 만든다음 히스토그램을 그려보자 | . fig1=plt.hist(img.flatten(),256,[0,256]) #0부터 256까지 256개로 잘라서 각 범주당 개수를 표현 . - 히스토그램을 그려보니 특정 구간에 너무 값들이 모여있음 . - 원래 0~255까지의 색을 표현할 수 있는데 컴퓨터가 표현가능한 색상보다 적은 조합만을 사용하고 있음. . - 아이디어: 좀 더 많은 색상을 표현할 수 없을까? $ to$ 위의 히스토그램은 좀 평평하게 만들면 되지 않을까? . img2=cv.equalizeHist(img) . fig2_1=plt.hist(img2.flatten(),256,[0,256]) . 값의 분포도가 커졌음 | . plt.imshow(img2,cmap=&#39;gray&#39;,vmin=0,vmax=255) plt.colorbar() . &lt;matplotlib.colorbar.Colorbar at 0x25cfdad86d0&gt; . import numpy as np _img=np.hstack((img,img2)) . plt.imshow(_img,cmap=&#39;gray&#39;) . &lt;matplotlib.image.AxesImage at 0x25cfdc80ac0&gt; .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2022/01/01/intro2.html",
            "relUrl": "/2022/01/01/intro2.html",
            "date": " • Jan 1, 2022"
        }
        
    
  
    
        ,"post7": {
            "title": "2021/12/31/FRI",
            "content": "boxplot . import matplotlib.pyplot as plt import numpy as np y1=[75,75,76,76,77,77,79,79,79,98] y2=[76,76,77,77,78,78,80,80,80,81] plt.boxplot([y1,y2]) # plt.boxplot(y1)하면 단독 사용 가능 . {&#39;whiskers&#39;: [&lt;matplotlib.lines.Line2D at 0x163081e57f0&gt;, &lt;matplotlib.lines.Line2D at 0x163081e5ac0&gt;, &lt;matplotlib.lines.Line2D at 0x163082050d0&gt;, &lt;matplotlib.lines.Line2D at 0x16308205460&gt;], &#39;caps&#39;: [&lt;matplotlib.lines.Line2D at 0x163081e5e50&gt;, &lt;matplotlib.lines.Line2D at 0x163081f8220&gt;, &lt;matplotlib.lines.Line2D at 0x163082057f0&gt;, &lt;matplotlib.lines.Line2D at 0x16308205b80&gt;], &#39;boxes&#39;: [&lt;matplotlib.lines.Line2D at 0x163081e53a0&gt;, &lt;matplotlib.lines.Line2D at 0x163081f8d00&gt;], &#39;medians&#39;: [&lt;matplotlib.lines.Line2D at 0x163081f85b0&gt;, &lt;matplotlib.lines.Line2D at 0x16308205f10&gt;], &#39;fliers&#39;: [&lt;matplotlib.lines.Line2D at 0x163081f8940&gt;, &lt;matplotlib.lines.Line2D at 0x1630820f2e0&gt;], &#39;means&#39;: []} . np.mean(y1), np.mean(y2) . (79.1, 78.3) . 주황선은 평균이 아니고 그냥 중앙값임을 알 수 있다 | . plotly . import pandas as pd A=pd.DataFrame({&#39;class&#39;:[&#39;A&#39;]*len(y1), &#39;score&#39;:y1}) B=pd.DataFrame({&#39;class&#39;:[&#39;B&#39;]*len(y2), &#39;score&#39;:y2}) df=pd.concat([A,B],ignore_index=True) . import plotly.express as px px.box(df, x=&#39;class&#39;,y=&#39;score&#39;) # 접근성 up . histogram . plt.hist(np.random.normal(loc=0,scale=10, size=10000)) # loc=평균, scale=표준편차, size=개수 . (array([ 8., 43., 352., 1248., 2571., 2879., 1912., 786., 172., 29.]), array([-39.91620121, -32.36184952, -24.80749782, -17.25314613, -9.69879444, -2.14444274, 5.40990895, 12.96426064, 20.51861234, 28.07296403, 35.62731572]), &lt;BarContainer object of 10 artists&gt;) . np.random.seed(43052) y1=np.random.normal(loc=0,scale=1,size=10000) y2=np.random.normal(loc=2,scale=1,size=10000) . (np.mean(y2)-np.mean(y1)).round(3) #소수 셋째자리에서 반올림 . 2.01 . plt.boxplot([y1,y2]) . {&#39;whiskers&#39;: [&lt;matplotlib.lines.Line2D at 0x1631da59b80&gt;, &lt;matplotlib.lines.Line2D at 0x1631da59f10&gt;, &lt;matplotlib.lines.Line2D at 0x1631da424f0&gt;, &lt;matplotlib.lines.Line2D at 0x1631da42880&gt;], &#39;caps&#39;: [&lt;matplotlib.lines.Line2D at 0x1631da4c2e0&gt;, &lt;matplotlib.lines.Line2D at 0x1631da4c670&gt;, &lt;matplotlib.lines.Line2D at 0x1631da42c10&gt;, &lt;matplotlib.lines.Line2D at 0x1631da42fa0&gt;], &#39;boxes&#39;: [&lt;matplotlib.lines.Line2D at 0x1631da59850&gt;, &lt;matplotlib.lines.Line2D at 0x1631da42160&gt;], &#39;medians&#39;: [&lt;matplotlib.lines.Line2D at 0x1631da4ca00&gt;, &lt;matplotlib.lines.Line2D at 0x1631da39370&gt;], &#39;fliers&#39;: [&lt;matplotlib.lines.Line2D at 0x1631da4cd90&gt;, &lt;matplotlib.lines.Line2D at 0x1631da39730&gt;], &#39;means&#39;: []} . - 정규분포인것은 어떻게 아는가? $ to$ 히스토그램을 그려보아서 종 모양이 나오는지 살펴보자. . plt.hist(y1,bins=50) . (array([ 1., 1., 3., 0., 1., 4., 5., 12., 14., 26., 32., 52., 67., 89., 144., 171., 238., 282., 325., 378., 489., 492., 561., 635., 652., 636., 626., 606., 573., 539., 475., 444., 350., 250., 232., 172., 137., 80., 58., 47., 30., 23., 17., 12., 9., 4., 4., 0., 1., 1.]), array([-4.12186916, -3.96068404, -3.79949892, -3.6383138 , -3.47712868, -3.31594356, -3.15475844, -2.99357332, -2.8323882 , -2.67120308, -2.51001796, -2.34883284, -2.18764772, -2.0264626 , -1.86527748, -1.70409236, -1.54290724, -1.38172212, -1.220537 , -1.05935188, -0.89816676, -0.73698164, -0.57579652, -0.4146114 , -0.25342628, -0.09224116, 0.06894396, 0.23012908, 0.3913142 , 0.55249932, 0.71368444, 0.87486956, 1.03605468, 1.1972398 , 1.35842492, 1.51961004, 1.68079516, 1.84198028, 2.0031654 , 2.16435052, 2.32553564, 2.48672076, 2.64790588, 2.809091 , 2.97027612, 3.13146124, 3.29264636, 3.45383148, 3.6150166 , 3.77620172, 3.93738684]), &lt;BarContainer object of 50 artists&gt;) . plt.hist(y2,bins=50) . (array([ 1., 0., 3., 2., 4., 5., 5., 10., 16., 25., 33., 56., 74., 116., 119., 152., 244., 272., 351., 362., 438., 509., 531., 621., 624., 690., 636., 571., 564., 514., 462., 402., 356., 297., 233., 184., 144., 113., 80., 55., 38., 34., 21., 18., 4., 3., 2., 4., 1., 1.]), array([-2.0752867 , -1.9164866 , -1.7576865 , -1.5988864 , -1.4400863 , -1.2812862 , -1.1224861 , -0.963686 , -0.8048859 , -0.6460858 , -0.4872857 , -0.3284856 , -0.1696855 , -0.0108854 , 0.1479147 , 0.3067148 , 0.4655149 , 0.624315 , 0.7831151 , 0.9419152 , 1.1007153 , 1.2595154 , 1.4183155 , 1.5771156 , 1.7359157 , 1.8947158 , 2.0535159 , 2.212316 , 2.37111611, 2.52991621, 2.68871631, 2.84751641, 3.00631651, 3.16511661, 3.32391671, 3.48271681, 3.64151691, 3.80031701, 3.95911711, 4.11791721, 4.27671731, 4.43551741, 4.59431751, 4.75311761, 4.91191771, 5.07071781, 5.22951791, 5.38831801, 5.54711811, 5.70591821, 5.86471831]), &lt;BarContainer object of 50 artists&gt;) . plt.hist([y1,y2],bins=50) . (array([[ 1., 2., 2., 1., 5., 10., 16., 25., 47., 55., 110., 160., 218., 289., 388., 433., 604., 643., 728., 786., 797., 766., 749., 685., 597., 547., 366., 315., 221., 160., 94., 69., 38., 25., 24., 11., 6., 5., 0., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 4., 3., 7., 7., 14., 27., 41., 75., 109., 151., 188., 317., 377., 459., 550., 630., 737., 783., 848., 783., 702., 680., 585., 480., 404., 321., 223., 175., 113., 76., 49., 38., 24., 8., 3., 5., 2., 1.]]), array([-4.12186916, -3.92213741, -3.72240567, -3.52267392, -3.32294217, -3.12321042, -2.92347867, -2.72374692, -2.52401517, -2.32428342, -2.12455167, -1.92481992, -1.72508817, -1.52535642, -1.32562467, -1.12589292, -0.92616117, -0.72642942, -0.52669767, -0.32696592, -0.12723417, 0.07249757, 0.27222932, 0.47196107, 0.67169282, 0.87142457, 1.07115632, 1.27088807, 1.47061982, 1.67035157, 1.87008332, 2.06981507, 2.26954682, 2.46927857, 2.66901032, 2.86874207, 3.06847382, 3.26820557, 3.46793732, 3.66766906, 3.86740081, 4.06713256, 4.26686431, 4.46659606, 4.66632781, 4.86605956, 5.06579131, 5.26552306, 5.46525481, 5.66498656, 5.86471831]), &lt;a list of 2 BarContainer objects&gt;) . seaborn . A=pd.DataFrame({&#39;class&#39;:[&#39;A&#39;]*len(y1),&#39;score&#39;:y1}) B=pd.DataFrame({&#39;class&#39;:[&#39;B&#39;]*len(y2),&#39;score&#39;:y2}) df=pd.concat([A,B],ignore_index=True) . import seaborn as sns sns.histplot(df,x=&#39;score&#39;,hue=&#39;class&#39;) . &lt;AxesSubplot:xlabel=&#39;score&#39;, ylabel=&#39;Count&#39;&gt; . plotnine . from plotnine import * . fill 대신에 color로 가능,투명도는 alpha . ggplot(df)+geom_histogram(aes(x=&#39;score&#39;,color=&#39;class&#39;),position=&#39;jitter&#39;,alpha=0.7) # position의 option에는 stack, identity, dodge, fill, jitter들이 있음 # position유무의 차이는 아직 잘 모르겠음 # 다만 없으면 그래프가 많이 독립적으로 그려지지 않는 것 같음 . C: Users ehfus Anaconda3 envs dv2021 lib site-packages plotnine stats stat_bin.py:95: PlotnineWarning: &#39;stat_bin()&#39; using &#39;bins = 65&#39;. Pick better value with &#39;binwidth&#39;. . &lt;ggplot: (95329268354)&gt; . plotly . import plotly.figure_factory as ff . hist_data=[y1,y2] group_labels=[&#39;A&#39;,&#39;B&#39;] ff.create_distplot(hist_data, group_labels, bin_size=.1, show_rug=False) .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/31/intro2.html",
            "relUrl": "/2021/12/31/intro2.html",
            "date": " • Dec 31, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "2021/12/30/THU",
            "content": "import pandas as pd . df=pd.read_csv(&#39;WEOApr2020all.csv&#39;) df.head(3) . WEO Country Code ISO WEO Subject Code Country Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 0 512 | AFG | NGDP_RPCH | Afghanistan | Gross domestic product, constant prices | Annual percentages of constant price GDP are y... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 5.683 | 2.697 | 0.988 | 2.164 | 2.889 | 2.664 | 3.037 | -3.007 | 4.495 | 2018.0 | . 1 512 | AFG | PPPGDP | Afghanistan | Gross domestic product, current prices | These data form the basis for the country weig... | Purchasing power parity; international dollars | Billions | Source: National Statistics Office Latest actu... | NaN | ... | 60.181 | 62.948 | 64.231 | 66.301 | 69.501 | 73.091 | 76.624 | 74.792 | 79.678 | 2018.0 | . 2 512 | AFG | NGDPRPPPPCPCH | Afghanistan | Gross domestic product per capita, constant pr... | GDP is expressed in constant international dol... | Purchasing power parity; percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 2.236 | -0.521 | -1.941 | -0.547 | 0.358 | 1.268 | 1.654 | -4.291 | 3.063 | 2018.0 | . 3 rows × 52 columns . df.describe() . WEO Country Code Estimates Start After . count 1552.000000 | 1466.000000 | . mean 553.670103 | 2018.291951 | . std 261.437803 | 1.075652 | . min 111.000000 | 2009.000000 | . 25% 314.000000 | 2018.000000 | . 50% 571.000000 | 2018.000000 | . 75% 734.000000 | 2019.000000 | . max 968.000000 | 2020.000000 | . df.columns . Index([&#39;WEO Country Code&#39;, &#39;ISO&#39;, &#39;WEO Subject Code&#39;, &#39;Country&#39;, &#39;Subject Descriptor&#39;, &#39;Subject Notes&#39;, &#39;Units&#39;, &#39;Scale&#39;, &#39;Country/Series-specific Notes&#39;, &#39;1980&#39;, &#39;1981&#39;, &#39;1982&#39;, &#39;1983&#39;, &#39;1984&#39;, &#39;1985&#39;, &#39;1986&#39;, &#39;1987&#39;, &#39;1988&#39;, &#39;1989&#39;, &#39;1990&#39;, &#39;1991&#39;, &#39;1992&#39;, &#39;1993&#39;, &#39;1994&#39;, &#39;1995&#39;, &#39;1996&#39;, &#39;1997&#39;, &#39;1998&#39;, &#39;1999&#39;, &#39;2000&#39;, &#39;2001&#39;, &#39;2002&#39;, &#39;2003&#39;, &#39;2004&#39;, &#39;2005&#39;, &#39;2006&#39;, &#39;2007&#39;, &#39;2008&#39;, &#39;2009&#39;, &#39;2010&#39;, &#39;2011&#39;, &#39;2012&#39;, &#39;2013&#39;, &#39;2014&#39;, &#39;2015&#39;, &#39;2016&#39;, &#39;2017&#39;, &#39;2018&#39;, &#39;2019&#39;, &#39;2020&#39;, &#39;2021&#39;, &#39;Estimates Start After&#39;], dtype=&#39;object&#39;) . type(df) . pandas.core.frame.DataFrame . df[&#39;Country&#39;].nunique() # 194개 나라의 data가 들어있음을 알 수 있다 . 194 . df.iloc[:,3] . 0 Afghanistan 1 Afghanistan 2 Afghanistan 3 Afghanistan 4 Afghanistan ... 1547 Zimbabwe 1548 Zimbabwe 1549 Zimbabwe 1550 Zimbabwe 1551 Zimbabwe Name: Country, Length: 1552, dtype: object . df.Country . 0 Afghanistan 1 Afghanistan 2 Afghanistan 3 Afghanistan 4 Afghanistan ... 1547 Zimbabwe 1548 Zimbabwe 1549 Zimbabwe 1550 Zimbabwe 1551 Zimbabwe Name: Country, Length: 1552, dtype: object . df[[&#39;Country&#39;]] . Country . 0 Afghanistan | . 1 Afghanistan | . 2 Afghanistan | . 3 Afghanistan | . 4 Afghanistan | . ... ... | . 1547 Zimbabwe | . 1548 Zimbabwe | . 1549 Zimbabwe | . 1550 Zimbabwe | . 1551 Zimbabwe | . 1552 rows × 1 columns . df[[&#39;Subject Descriptor&#39;]].head(7) . Subject Descriptor . 0 Gross domestic product, constant prices | . 1 Gross domestic product, current prices | . 2 Gross domestic product per capita, constant pr... | . 3 Inflation, average consumer prices | . 4 Inflation, end of period consumer prices | . 5 Unemployment rate | . 6 General government net lending/borrowing | . df[[&#39;Subject Descriptor&#39;,&#39;2020&#39;]] . Subject Descriptor 2020 . 0 Gross domestic product, constant prices | -3.007 | . 1 Gross domestic product, current prices | 74.792 | . 2 Gross domestic product per capita, constant pr... | -4.291 | . 3 Inflation, average consumer prices | 4.711 | . 4 Inflation, end of period consumer prices | 4.5 | . ... ... | ... | . 1547 Inflation, average consumer prices | 319.036 | . 1548 Inflation, end of period consumer prices | 154.297 | . 1549 Unemployment rate | NaN | . 1550 General government net lending/borrowing | -4.931 | . 1551 Current account balance | -1.914 | . 1552 rows × 2 columns . df[[&#39;Subject Descriptor&#39;,&#39;2020&#39;,&#39;Country&#39;]] . Subject Descriptor 2020 Country . 0 Gross domestic product, constant prices | -3.007 | Afghanistan | . 1 Gross domestic product, current prices | 74.792 | Afghanistan | . 2 Gross domestic product per capita, constant pr... | -4.291 | Afghanistan | . 3 Inflation, average consumer prices | 4.711 | Afghanistan | . 4 Inflation, end of period consumer prices | 4.5 | Afghanistan | . ... ... | ... | ... | . 1547 Inflation, average consumer prices | 319.036 | Zimbabwe | . 1548 Inflation, end of period consumer prices | 154.297 | Zimbabwe | . 1549 Unemployment rate | NaN | Zimbabwe | . 1550 General government net lending/borrowing | -4.931 | Zimbabwe | . 1551 Current account balance | -1.914 | Zimbabwe | . 1552 rows × 3 columns . Inflation . idx_inf=df[&#39;Subject Descriptor&#39;].str.contains(&#39;Inflation, end of&#39;) print(idx_inf) . 0 False 1 False 2 False 3 False 4 True ... 1547 False 1548 True 1549 False 1550 False 1551 False Name: Subject Descriptor, Length: 1552, dtype: bool . df.loc[idx_inf] . WEO Country Code ISO WEO Subject Code Country Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 4 512 | AFG | PCPIEPCH | Afghanistan | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.241 | 1.487 | 1.131 | 4.588 | 3.041 | 0.755 | 2.773 | 4.5 | 5 | 2018.0 | . 12 914 | ALB | PCPIEPCH | Albania | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 1.776 | 0.719 | 1.937 | 2.176 | 1.798 | 1.799 | 1.15 | 2.6 | 2.9 | 2019.0 | . 20 612 | DZA | PCPIEPCH | Algeria | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | 14.143 | ... | 1.148 | 5.253 | 4.362 | 6.957 | 4.933 | 2.702 | 2.434 | 3.3 | 4 | 2019.0 | . 28 614 | AGO | PCPIEPCH | Angola | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.687 | 7.498 | 12.091 | 41.125 | 23.667 | 18.604 | 16.893 | 20.979 | 23.981 | 2019.0 | . 36 311 | ATG | PCPIEPCH | Antigua and Barbuda | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: Central Bank Latest actual data: 2018 ... | 17.71 | ... | 1.059 | 1.327 | 0.9 | -1.121 | 2.356 | 1.741 | 1.574 | 1.348 | 2.008 | 2018.0 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 1516 299 | VEN | PCPIEPCH | Venezuela | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: Central Bank Latest actual data: 2019 ... | NaN | ... | 56.193 | 68.54 | 180.87 | 274.354 | 862.629 | 130,060.24 | 9,585.49 | 15,000.00 | 15,000.00 | 2019.0 | . 1524 582 | VNM | PCPIEPCH | Vietnam | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 6.036 | 1.839 | 0.597 | 4.737 | 2.597 | 2.983 | 5.237 | 2 | 4.3 | 2018.0 | . 1532 474 | YEM | PCPIEPCH | Yemen | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office. Central Ba... | NaN | ... | 8.14 | 10.005 | 34 | 11.9 | 47 | 14.3 | 6.2 | 46 | 5 | 2017.0 | . 1540 754 | ZMB | PCPIEPCH | Zambia | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.14 | 7.862 | 21.112 | 7.469 | 6.085 | 7.9 | 11.7 | 12.7 | 11.4 | 2019.0 | . 1548 698 | ZWE | PCPIEPCH | Zimbabwe | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 0.331 | -0.796 | -2.473 | -0.898 | 3.43 | 42.074 | 521.15 | 154.297 | 3 | 2019.0 | . 194 rows × 52 columns . df_inf=df[idx_inf] df_inf.head(3) . WEO Country Code ISO WEO Subject Code Country Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 4 512 | AFG | PCPIEPCH | Afghanistan | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.241 | 1.487 | 1.131 | 4.588 | 3.041 | 0.755 | 2.773 | 4.5 | 5 | 2018.0 | . 12 914 | ALB | PCPIEPCH | Albania | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 1.776 | 0.719 | 1.937 | 2.176 | 1.798 | 1.799 | 1.15 | 2.6 | 2.9 | 2019.0 | . 20 612 | DZA | PCPIEPCH | Algeria | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | 14.143 | ... | 1.148 | 5.253 | 4.362 | 6.957 | 4.933 | 2.702 | 2.434 | 3.3 | 4 | 2019.0 | . 3 rows × 52 columns . df_inf_2021=df_inf[[&#39;Country&#39;,&#39;2021&#39;]] . df_inf_2021.reset_index(drop=True,inplace=True) . df_inf_2021 . Country 2021 . 0 Afghanistan | 5 | . 1 Albania | 2.9 | . 2 Algeria | 4 | . 3 Angola | 23.981 | . 4 Antigua and Barbuda | 2.008 | . ... ... | ... | . 189 Venezuela | 15,000.00 | . 190 Vietnam | 4.3 | . 191 Yemen | 5 | . 192 Zambia | 11.4 | . 193 Zimbabwe | 3 | . 194 rows × 2 columns . df_inf_2021.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 194 entries, 0 to 193 Data columns (total 2 columns): # Column Non-Null Count Dtype -- -- 0 Country 194 non-null object 1 2021 190 non-null object dtypes: object(2) memory usage: 3.2+ KB . 2021 null data가 4개임을 알 수 있다 | . df_inf_2021=df_inf_2021.loc[df_inf_2021[&#39;2021&#39;].notnull()] . df_inf_2021 . Country 2021 . 0 Afghanistan | 5 | . 1 Albania | 2.9 | . 2 Algeria | 4 | . 3 Angola | 23.981 | . 4 Antigua and Barbuda | 2.008 | . ... ... | ... | . 189 Venezuela | 15,000.00 | . 190 Vietnam | 4.3 | . 191 Yemen | 5 | . 192 Zambia | 11.4 | . 193 Zimbabwe | 3 | . 190 rows × 2 columns . null data가 빠졌음 | . df_inf_2021.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 190 entries, 0 to 193 Data columns (total 2 columns): # Column Non-Null Count Dtype -- -- 0 Country 190 non-null object 1 2021 190 non-null object dtypes: object(2) memory usage: 4.5+ KB . data에 큰 숫자마다 comma가 들어가 있음 $ to$ 없애주자 . df_inf_2021=df_inf_2021.replace(&#39;,&#39;,&#39;&#39;,regex=True) df_inf_2021 . Country 2021 . 0 Afghanistan | 5 | . 1 Albania | 2.9 | . 2 Algeria | 4 | . 3 Angola | 23.981 | . 4 Antigua and Barbuda | 2.008 | . ... ... | ... | . 189 Venezuela | 15000.00 | . 190 Vietnam | 4.3 | . 191 Yemen | 5 | . 192 Zambia | 11.4 | . 193 Zimbabwe | 3 | . 190 rows × 2 columns . 이제 numeric data로 바꿔보자 | . df_inf_2021[&#39;2021&#39;]=pd.to_numeric(df_inf_2021[&#39;2021&#39;]) . 확인해보자 | . df_inf_2021.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 190 entries, 0 to 193 Data columns (total 2 columns): # Column Non-Null Count Dtype -- -- 0 Country 190 non-null object 1 2021 190 non-null float64 dtypes: float64(1), object(1) memory usage: 4.5+ KB . float64로 잘 바뀌었음 | . df_inf_2021.sort_values(&#39;2021&#39;).plot.bar(x=&#39;Country&#39;) . &lt;AxesSubplot:xlabel=&#39;Country&#39;&gt; . 무용지물의 그래프가 나왔다 | . df_inf_2021.sort_values(&#39;2021&#39;).iloc[0:20,:].plot.bar(x=&#39;Country&#39;) . &lt;AxesSubplot:xlabel=&#39;Country&#39;&gt; . &#49892;&#50629;&#47456; . df_ur=df[df[&#39;Subject Descriptor&#39;].str.contains(&#39;Unemployment&#39;)] df_ur . WEO Country Code ISO WEO Subject Code Country Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 5 512 | AFG | LUR | Afghanistan | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 13 914 | ALB | LUR | Albania | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: National Statistics Office Latest actu... | 5.028 | ... | 15.9 | 17.5 | 17.1 | 15.2 | 13.7 | 12.3 | 12 | 11.8 | 11.5 | 2019.0 | . 21 612 | DZA | LUR | Algeria | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: National Statistics Office Latest actu... | 15.789 | ... | 9.829 | 10.6 | 11.214 | 10.498 | 11.709 | 11.731 | 11.383 | 15.091 | 13.909 | 2019.0 | . 29 614 | AGO | LUR | Angola | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 37 311 | ATG | LUR | Antigua and Barbuda | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 1517 299 | VEN | LUR | Venezuela | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.47 | 6.7 | 7.4 | 20.863 | 27.886 | 35.543 | NaN | NaN | NaN | 2011.0 | . 1525 582 | VNM | LUR | Vietnam | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: Other Latest actual data: 2019 Employm... | NaN | ... | 2.75 | 2.1 | 2.33 | 2.33 | 2.21 | 2.21 | 2.21 | NaN | NaN | 2019.0 | . 1533 474 | YEM | LUR | Yemen | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 1541 754 | ZMB | LUR | Zambia | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 1549 698 | ZWE | LUR | Zimbabwe | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 194 rows × 52 columns . df_ur=df_ur[[&#39;Country&#39;,&#39;2021&#39;]] . df_ur.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 194 entries, 5 to 1549 Data columns (total 2 columns): # Column Non-Null Count Dtype -- -- 0 Country 194 non-null object 1 2021 100 non-null object dtypes: object(2) memory usage: 4.5+ KB . 94개의 null data 발견 | . df_ur=df_ur.loc[df_ur[&#39;2021&#39;].notnull()] . df_ur.reset_index(drop=True,inplace=True) df_ur . Country 2021 . 0 Albania | 11.5 | . 1 Algeria | 13.909 | . 2 Argentina | 10.084 | . 3 Armenia | 18.389 | . 4 Aruba | 7.458 | . ... ... | ... | . 95 Turkey | 15.567 | . 96 Ukraine | 9.318 | . 97 United Kingdom | 4.375 | . 98 United States | 9.135 | . 99 Uruguay | 8.098 | . 100 rows × 2 columns . null data가 잘 빠졌음 | . 이제 numeric으로 변형해주자 | . df_ur[&#39;2021&#39;]=pd.to_numeric(df_ur[&#39;2021&#39;]) . df_ur.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 100 entries, 0 to 99 Data columns (total 2 columns): # Column Non-Null Count Dtype -- -- 0 Country 100 non-null object 1 2021 100 non-null float64 dtypes: float64(1), object(1) memory usage: 1.7+ KB . df_ur.plot.bar(x=&#39;Country&#39;) . &lt;AxesSubplot:xlabel=&#39;Country&#39;&gt; . df_ur.sort_values(&#39;2021&#39;,ascending=False).plot.bar(x=&#39;Country&#39;, title=&#39;Unemployment Rate&#39;,figsize=(15,5)) . &lt;AxesSubplot:title={&#39;center&#39;:&#39;Unemployment Rate&#39;}, xlabel=&#39;Country&#39;&gt; . 관심있는 나라만 따로 표시해보자 | . df_ur_np=df_ur.sort_values(&#39;2021&#39;,ascending=False).to_numpy() . . import matplotlib.pyplot as plt import numpy as np . plt.rcParams[&#39;figure.figsize&#39;]=(20,3) plt.xticks(rotation=&#39;vertical&#39;) plt.bar(df_ur_np[:,0],df_ur_np[:,1]) plt.title(&#39;2021 Unemployment Rate - IMF World Economics Outlook Database, April 2020&#39;) idx=np.where(df_ur_np==&#39;Korea&#39;) plt.bar(df_ur_np[idx[0],0],df_ur_np[idx[0],1],label=&#39;Korea&#39;) idx=np.where(df_ur_np==&#39;United States&#39;) plt.bar(df_ur_np[idx[0],0],df_ur_np[idx[0],1],label=&#39;United States&#39;) idx=np.where(df_ur_np==&#39;China&#39;) plt.bar(df_ur_np[idx[0],0],df_ur_np[idx[0],1],label=&#39;China&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x22b114aca90&gt; . TIP . df.head(3) . WEO Country Code ISO WEO Subject Code Country Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 0 512 | AFG | NGDP_RPCH | Afghanistan | Gross domestic product, constant prices | Annual percentages of constant price GDP are y... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 5.683 | 2.697 | 0.988 | 2.164 | 2.889 | 2.664 | 3.037 | -3.007 | 4.495 | 2018.0 | . 1 512 | AFG | PPPGDP | Afghanistan | Gross domestic product, current prices | These data form the basis for the country weig... | Purchasing power parity; international dollars | Billions | Source: National Statistics Office Latest actu... | NaN | ... | 60.181 | 62.948 | 64.231 | 66.301 | 69.501 | 73.091 | 76.624 | 74.792 | 79.678 | 2018.0 | . 2 512 | AFG | NGDPRPPPPCPCH | Afghanistan | Gross domestic product per capita, constant pr... | GDP is expressed in constant international dol... | Purchasing power parity; percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 2.236 | -0.521 | -1.941 | -0.547 | 0.358 | 1.268 | 1.654 | -4.291 | 3.063 | 2018.0 | . 3 rows × 52 columns . len(df.columns) . 52 . idx = list(range(0,52)) . idx[3]=0 idx[0]=3 print(idx) . [3, 1, 2, 0, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51] . df.iloc[:,idx] . Country ISO WEO Subject Code WEO Country Code Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 0 Afghanistan | AFG | NGDP_RPCH | 512 | Gross domestic product, constant prices | Annual percentages of constant price GDP are y... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 5.683 | 2.697 | 0.988 | 2.164 | 2.889 | 2.664 | 3.037 | -3.007 | 4.495 | 2018.0 | . 1 Afghanistan | AFG | PPPGDP | 512 | Gross domestic product, current prices | These data form the basis for the country weig... | Purchasing power parity; international dollars | Billions | Source: National Statistics Office Latest actu... | NaN | ... | 60.181 | 62.948 | 64.231 | 66.301 | 69.501 | 73.091 | 76.624 | 74.792 | 79.678 | 2018.0 | . 2 Afghanistan | AFG | NGDPRPPPPCPCH | 512 | Gross domestic product per capita, constant pr... | GDP is expressed in constant international dol... | Purchasing power parity; percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 2.236 | -0.521 | -1.941 | -0.547 | 0.358 | 1.268 | 1.654 | -4.291 | 3.063 | 2018.0 | . 3 Afghanistan | AFG | PCPIPCH | 512 | Inflation, average consumer prices | Annual percentages of average consumer prices ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.386 | 4.674 | -0.662 | 4.384 | 4.976 | 0.626 | 2.302 | 4.711 | 4.451 | 2018.0 | . 4 Afghanistan | AFG | PCPIEPCH | 512 | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.241 | 1.487 | 1.131 | 4.588 | 3.041 | 0.755 | 2.773 | 4.5 | 5 | 2018.0 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 1547 Zimbabwe | ZWE | PCPIPCH | 698 | Inflation, average consumer prices | Annual percentages of average consumer prices ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 1.632 | -0.213 | -2.41 | -1.558 | 0.907 | 10.607 | 255.292 | 319.036 | 3.7 | 2019.0 | . 1548 Zimbabwe | ZWE | PCPIEPCH | 698 | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 0.331 | -0.796 | -2.473 | -0.898 | 3.43 | 42.074 | 521.15 | 154.297 | 3 | 2019.0 | . 1549 Zimbabwe | ZWE | LUR | 698 | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 1550 Zimbabwe | ZWE | GGXCNL_NGDP | 698 | General government net lending/borrowing | Net lending (+)/ borrowing (?) is calculated a... | Percent of GDP | NaN | Source: Ministry of Finance or Treasury Latest... | NaN | ... | -0.621 | -0.421 | -1.418 | -6.242 | -8.113 | -4.499 | -2.575 | -4.931 | -1.518 | 2018.0 | . 1551 Zimbabwe | ZWE | BCA_NGDPD | 698 | Current account balance | Current account is all transactions other than... | Percent of GDP | NaN | Source: Reserve Bank of Zimbabwe and Ministry ... | NaN | ... | -13.23 | -11.563 | -7.617 | -3.58 | -1.299 | -5.896 | 1.133 | -1.914 | -1.894 | 2018.0 | . 1552 rows × 52 columns . 이렇게 원하는 순서로 열을 배열해보았음 | . . Grouping . df_ur[&#39;Criteria&#39;]=0 . df_ur.loc[ df_ur[&#39;2021&#39;] &lt; 5 , &#39;Criteria&#39; ]=&#39;Low&#39; df_ur.loc[ (df_ur[&#39;2021&#39;] &gt;= 5) &amp; (df_ur[&#39;2021&#39;] &lt; 10) , &#39;Criteria&#39; ]=&#39;Medium&#39; df_ur.loc[ df_ur[&#39;2021&#39;] &gt;=10 , &#39;Criteria&#39; ]=&#39;High&#39; . df_ur.groupby([&#39;Criteria&#39;]).mean() . 2021 . Criteria . High 14.767680 | . Low 3.547000 | . Medium 7.100353 | . df_ur.groupby([&#39;Criteria&#39;]).mean().sort_values(&#39;2021&#39;) . 2021 . Criteria . Low 3.547000 | . Medium 7.100353 | . High 14.767680 | . df_ur.groupby([&#39;Criteria&#39;]).count() . Country 2021 . Criteria . High 25 | 25 | . Low 24 | 24 | . Medium 51 | 51 | . . Data를 적당히 소분해 불러와보자 . df_new=pd.DataFrame(columns=df.columns) df_new . WEO Country Code ISO WEO Subject Code Country Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 0 rows × 52 columns . for df_chunk in pd.read_csv(&#39;WEOApr2020all.csv&#39;,chunksize=5): temp=df_chunk.loc[df_chunk[&#39;Subject Descriptor&#39;]==&#39;Unemployment rate&#39;] df_new = pd.concat([df_new,temp]) . df_new . WEO Country Code ISO WEO Subject Code Country Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 5 512 | AFG | LUR | Afghanistan | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 13 914 | ALB | LUR | Albania | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: National Statistics Office Latest actu... | 5.028 | ... | 15.9 | 17.5 | 17.1 | 15.2 | 13.7 | 12.3 | 12.0 | 11.8 | 11.5 | 2019 | . 21 612 | DZA | LUR | Algeria | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: National Statistics Office Latest actu... | 15.789 | ... | 9.829 | 10.6 | 11.214 | 10.498 | 11.709 | 11.731 | 11.383 | 15.091 | 13.909 | 2019 | . 29 614 | AGO | LUR | Angola | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 37 311 | ATG | LUR | Antigua and Barbuda | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 1517 299 | VEN | LUR | Venezuela | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.47 | 6.7 | 7.4 | 20.863 | 27.886 | 35.543 | NaN | NaN | NaN | 2011 | . 1525 582 | VNM | LUR | Vietnam | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: Other Latest actual data: 2019 Employm... | NaN | ... | 2.75 | 2.1 | 2.33 | 2.33 | 2.21 | 2.21 | 2.21 | NaN | NaN | 2019 | . 1533 474 | YEM | LUR | Yemen | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 1541 754 | ZMB | LUR | Zambia | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 1549 698 | ZWE | LUR | Zimbabwe | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 194 rows × 52 columns . . &#50620;&#44404; &#51064;&#49885; . import cv2 . img=cv2.imread(&#39;spurs_pic.jpg&#39;) plt.imshow(img) # BGR로 인식하기 때문에 RGB로 바꿔야 함 . &lt;matplotlib.image.AxesImage at 0x22b1e176ca0&gt; . rgb=cv2.cvtColor(img, cv2.COLOR_BGR2RGB) plt.imshow(rgb) . &lt;matplotlib.image.AxesImage at 0x22b1e1f3490&gt; . gray=cv2.cvtColor(rgb, cv2.COLOR_RGB2GRAY) plt.imshow(gray,cmap=&#39;gray&#39;) . &lt;matplotlib.image.AxesImage at 0x22b1e393df0&gt; . classifier=cv2.CascadeClassifier(&#39;. haarcascades haarcascade_frontalface_default.xml&#39;) . 분류할 데이터가 정해졌음 . rects = classifier.detectMultiScale(gray,scaleFactor=1.2,minNeighbors=5) . print(&#39;Face found:{} &#39;.format(len(rects))) . Face found:11 . for x,y,w,h in rects: cv2.rectangle(rgb,(x,y),(x+w,y+h),(0,255,0),2) plt.imshow(rgb) . &lt;matplotlib.image.AxesImage at 0x22b1e2e58e0&gt; . #plt.imshow(rgb) . bgr=cv2.cvtColor(rgb,cv2.COLOR_RGB2BGR) cv2.imwrite(&#39;spurs_pic_faces.jpg&#39;,bgr) # 저장했음 . True .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/30/intro.html",
            "relUrl": "/2021/12/30/intro.html",
            "date": " • Dec 30, 2021"
        }
        
    
  
    
        ,"post9": {
            "title": "2021/12/29/WED",
            "content": "import matplotlib.pyplot as plt import matplotlib.cm as cm import numpy as np . height=4 width=5 depth=3 . m=np.zeros((height,width,depth)) . plt.imshow(m) plt.grid() . 이미지의 시작은 좌측 상단임 . m[:,:,0]=255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m=np.zeros((height,width,depth)) m[:,:,1]=255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m=np.zeros((height,width,depth)) m[:,:,2]=255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m=np.ones((height,width,depth))*255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m=np.zeros((height,width,depth))*0 plt.imshow(m) plt.grid() . m=np.zeros((height,width,depth)) m[0,0,:]=255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . 첫번재 픽셀만 하얗게 만듦 . m=np.zeros((height,width,depth)) m[0,0,0]=0 m[0,0,1]=255 m[0,0,2]=0 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m=np.zeros((height,width,depth)) m[0,0,0]=0 m[0,0,1]=0 m[0,0,2]=255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m=np.zeros((height,width,depth)) m[0,0,0]=255 m[0,0,1]=0 m[0,0,2]=0 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m=np.zeros((height,width,depth)) m[:,:,:]=0 plt.imshow(m) plt.grid() . m=np.zeros((height,width,depth)) m[:,0,1]=255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m[:,-2,2]=255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m[2,:,0]=255 m[2,:,1]=255 m[2,:,2]=0 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . 이미지를 세로로 두배 늘려보자 . m_vt=np.vstack([m,m]) plt.imshow(m_vt) . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . &lt;matplotlib.image.AxesImage at 0x142b59fb310&gt; . m_hz=np.hstack([m,m]) plt.imshow(m_hz) . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . &lt;matplotlib.image.AxesImage at 0x142b389cbb0&gt; . 어둡게 해보자 . m_hz=(m_hz/255)*0.5 plt.imshow(m_hz) . &lt;matplotlib.image.AxesImage at 0x142b3c07940&gt; . 체크보드 만들기 . m=np.zeros((5,5,3)) plt.imshow(m) . &lt;matplotlib.image.AxesImage at 0x142b38af790&gt; . m[:,:,:]=1 plt.imshow(m) . &lt;matplotlib.image.AxesImage at 0x142b5915490&gt; . m[:,:,:]=0 plt.imshow(m) . &lt;matplotlib.image.AxesImage at 0x142b5a553a0&gt; . m[0::2,0::2,:]=1 plt.imshow(m) . &lt;matplotlib.image.AxesImage at 0x142b5aaf2e0&gt; . m[1::2,1::2,:]=1 plt.imshow(m) . &lt;matplotlib.image.AxesImage at 0x142b5b10040&gt; . 논리 연산을 사용해서 체크 무늬 만들어보자 . n=m.copy() idx=np.where(n==1) n[idx]=0.5 plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b5b76610&gt; . idx=np.where(n&lt;0.1) n[idx]=1 plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b5bc3f40&gt; . n=m.copy() plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b5c88160&gt; . 컬러 뒤집기 . idx1=np.where(n==1) idx2=np.where(n==0) n[idx1]=0 n[idx2]=1 plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b617d5b0&gt; . a=np.where(n==1) n[a[0],a[1],0]=0 n[a[0],a[1],2]=0 plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b6345460&gt; . flag_r=(n[:,:,0]==0) flag_g=(n[:,:,1]==0) flag_b=(n[:,:,2]==0) flag_blk= flag_r&amp;flag_g&amp;flag_b idx_blk=np.where(flag_blk==True) n[idx_blk[0],idx_blk[1],0]=1 plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b6a56880&gt; . n=m.copy() plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b700f1c0&gt; . np_sum=np.sum(n,axis=2) idx_blk=np.where(np_sum==0) n[idx_blk[0],idx_blk[1],0]=1 plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b5d23a90&gt; . np.fill_diagonal(n[:,:,0],0) np.fill_diagonal(n[:,:,1],1) np.fill_diagonal(n[:,:,2],0) plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b5db2370&gt; . m=np.linspace(0,1,10) m=m[:,np.newaxis] m=np.repeat(m,10,axis=1) plt.imshow(m,cmap=&#39;gray&#39;) . &lt;matplotlib.image.AxesImage at 0x142b6225490&gt; . m_tr=np.transpose(m) plt.imshow(m_tr,cmap=&#39;gray&#39;) . &lt;matplotlib.image.AxesImage at 0x142b68cdfd0&gt; . m_tr=np.transpose(m) plt.imshow(m_tr,cmap=&#39;jet&#39;) . &lt;matplotlib.image.AxesImage at 0x142b6a62c70&gt; . . LaTex 이용해보자 . $ begin{align} begin{cases} f(x) = frac{1}{10}x^2 &amp; text{ for } x in [0,1.5) f(x) = sum_{n=1,3,5..}^{N}{ frac{4}{ pi n} text{sin}( frac{2 pi n(x-1.5)}{T})}&amp; text{for} in[1.5,3] end{cases} end{align} $ . . x1=np.arange(0,1.5,0.01) y1=1/10*x1**2 . . x2=np.arange(1.5,3+0.01,0.01) n= 50 t=1 y2=np.zeros(x2.shape) for n in range(n): if n%2==1: series = 4/(np.pi*n)*np.sin((2*np.pi*n*(x2-1.5))/t) y2=y2+series . plt.plot(x1,y1) plt.plot(x2,y2) plt.xlabel(&#39;x&#39;) plt.xlabel(&#39;y&#39;) plt.title(&#39;Piecewise Functions&#39;) . Text(0.5, 1.0, &#39;Piecewise Functions&#39;) . . 세계 온도 변화 시각화 . import scipy import scipy.interpolate as interp import gzip import pickle as pkl . file=gzip.GzipFile(&#39;GlobalTemperatureData.pkl.gz&#39;,&#39;rb&#39;) df=pkl.load(file) file.close . &lt;bound method GzipFile.close of &lt;gzip _io.BufferedReader name=&#39;GlobalTemperatureData.pkl.gz&#39; 0x142be630940&gt;&gt; . df.keys() . dict_keys([&#39;YR1881&#39;, &#39;YR1882&#39;, &#39;YR1883&#39;, &#39;YR1884&#39;, &#39;YR1885&#39;, &#39;YR1886&#39;, &#39;YR1887&#39;, &#39;YR1888&#39;, &#39;YR1889&#39;, &#39;YR1890&#39;, &#39;YR1891&#39;, &#39;YR1892&#39;, &#39;YR1893&#39;, &#39;YR1894&#39;, &#39;YR1895&#39;, &#39;YR1896&#39;, &#39;YR1897&#39;, &#39;YR1898&#39;, &#39;YR1899&#39;, &#39;YR1900&#39;, &#39;YR1901&#39;, &#39;YR1902&#39;, &#39;YR1903&#39;, &#39;YR1904&#39;, &#39;YR1905&#39;, &#39;YR1906&#39;, &#39;YR1907&#39;, &#39;YR1908&#39;, &#39;YR1909&#39;, &#39;YR1910&#39;, &#39;YR1911&#39;, &#39;YR1912&#39;, &#39;YR1913&#39;, &#39;YR1914&#39;, &#39;YR1915&#39;, &#39;YR1916&#39;, &#39;YR1917&#39;, &#39;YR1918&#39;, &#39;YR1919&#39;, &#39;YR1920&#39;, &#39;YR1921&#39;, &#39;YR1922&#39;, &#39;YR1923&#39;, &#39;YR1924&#39;, &#39;YR1925&#39;, &#39;YR1926&#39;, &#39;YR1927&#39;, &#39;YR1928&#39;, &#39;YR1929&#39;, &#39;YR1930&#39;, &#39;YR1931&#39;, &#39;YR1932&#39;, &#39;YR1933&#39;, &#39;YR1934&#39;, &#39;YR1935&#39;, &#39;YR1936&#39;, &#39;YR1937&#39;, &#39;YR1938&#39;, &#39;YR1939&#39;, &#39;YR1940&#39;, &#39;YR1941&#39;, &#39;YR1942&#39;, &#39;YR1943&#39;, &#39;YR1944&#39;, &#39;YR1945&#39;, &#39;YR1946&#39;, &#39;YR1947&#39;, &#39;YR1948&#39;, &#39;YR1949&#39;, &#39;YR1950&#39;, &#39;YR1951&#39;, &#39;YR1952&#39;, &#39;YR1953&#39;, &#39;YR1954&#39;, &#39;YR1955&#39;, &#39;YR1956&#39;, &#39;YR1957&#39;, &#39;YR1958&#39;, &#39;YR1959&#39;, &#39;YR1960&#39;, &#39;YR1961&#39;, &#39;YR1962&#39;, &#39;YR1963&#39;, &#39;YR1964&#39;, &#39;YR1965&#39;, &#39;YR1966&#39;, &#39;YR1967&#39;, &#39;YR1968&#39;, &#39;YR1969&#39;, &#39;YR1970&#39;, &#39;YR1971&#39;, &#39;YR1972&#39;, &#39;YR1973&#39;, &#39;YR1974&#39;, &#39;YR1975&#39;, &#39;YR1976&#39;, &#39;YR1977&#39;, &#39;YR1978&#39;, &#39;YR1979&#39;, &#39;YR1980&#39;, &#39;YR1981&#39;, &#39;YR1982&#39;, &#39;YR1983&#39;, &#39;YR1984&#39;, &#39;YR1985&#39;, &#39;YR1986&#39;, &#39;YR1987&#39;, &#39;YR1988&#39;, &#39;YR1989&#39;, &#39;YR1990&#39;, &#39;YR1991&#39;, &#39;YR1992&#39;, &#39;YR1993&#39;, &#39;YR1994&#39;, &#39;YR1995&#39;, &#39;YR1996&#39;, &#39;YR1997&#39;, &#39;YR1998&#39;, &#39;YR1999&#39;, &#39;YR2000&#39;, &#39;YR2001&#39;, &#39;YR2002&#39;, &#39;YR2003&#39;, &#39;YR2004&#39;, &#39;YR2005&#39;, &#39;YR2006&#39;, &#39;YR2007&#39;, &#39;YR2008&#39;, &#39;YR2009&#39;, &#39;YR2010&#39;, &#39;YR2011&#39;, &#39;YR2012&#39;, &#39;YR2013&#39;, &#39;YR2014&#39;, &#39;YR2015&#39;, &#39;YR2016&#39;, &#39;YR2017&#39;, &#39;YR2018&#39;, &#39;YR2019&#39;]) . 연도별로 세계온도가 들어가있음 . yr=list(df.keys()) . iyr=10 df_yr=df[yr[iyr]] . df_yr.keys() . Index([&#39;i&#39;, &#39;j&#39;, &#39;lon&#39;, &#39;lat&#39;, &#39;Temperature(i,j)&#39;], dtype=&#39;object&#39;) . df_yr . i j lon lat Temperature(i,j) . 0 1 | 1 | -179 | -89 | 9999.0 | . 1 2 | 1 | -177 | -89 | 9999.0 | . 2 3 | 1 | -175 | -89 | 9999.0 | . 3 4 | 1 | -173 | -89 | 9999.0 | . 4 5 | 1 | -171 | -89 | 9999.0 | . ... ... | ... | ... | ... | ... | . 16195 176 | 90 | 171 | 89 | 9999.0 | . 16196 177 | 90 | 173 | 89 | 9999.0 | . 16197 178 | 90 | 175 | 89 | 9999.0 | . 16198 179 | 90 | 177 | 89 | 9999.0 | . 16199 180 | 90 | 179 | 89 | 9999.0 | . 16200 rows × 5 columns . 위도, 경도, 온도만 발췌하여 numpy_array로 변형해보자 . data=df_yr[[&#39;lon&#39;,&#39;lat&#39;,&#39;Temperature(i,j)&#39;]].to_numpy() . data[np.where(data&gt;9999)]=np.nan . 9999를 nan으로 바꾼 이유는 자동으로 plot이 안 되게 하기 위해서 . x=np.linspace(-180,180,100) y=np.linspace(-90,90,100) grid_x,grid_y=np.meshgrid(x,y) . data_interp=interp.griddata(data[:,[0,1]],data[:,2],(grid_x,grid_y),method=&#39;linear&#39;) . . hfig,hax=plt.subplots() im=plt.imread(&#39;world_map.png&#39;) plt.imshow(im) . &lt;matplotlib.image.AxesImage at 0x142c9a2e340&gt; . 좌표축의 중심을 왼쪽 아래로 . 그런데 지도까지 뒤집혀버림 . hfig,hax=plt.subplots() im=plt.imread(&#39;world_map.png&#39;) plt.imshow(im,origin=&#39;lower&#39;) . &lt;matplotlib.image.AxesImage at 0x142c9a903a0&gt; . 다시 지도만 뒤집어줌 . hfig,hax=plt.subplots() im=plt.imread(&#39;world_map.png&#39;) plt.imshow(np.flipud(im),origin=&#39;lower&#39;) . &lt;matplotlib.image.AxesImage at 0x142c9fd75b0&gt; . size 조정 . hfig,hax=plt.subplots() im=plt.imread(&#39;world_map.png&#39;) plt.imshow(np.flipud(im),origin=&#39;lower&#39;,extent=(0,800,0,400)) . &lt;matplotlib.image.AxesImage at 0x142ca05a2b0&gt; . hfig,hax=plt.subplots() im=plt.imread(&#39;world_map.png&#39;) plt.imshow(np.flipud(im),origin=&#39;lower&#39;,extent=(-180,180,-90,90)) plt.pcolormesh(grid_x,grid_y,data_interp,cmap=&#39;coolwarm&#39;,alpha=0.6) plt.xlim(-180,180) plt.ylim(-90,90) plt.title(&#39;global temperature change from ty1880 to&#39;+str(yr[iyr])) plt.xlabel(&#39;Altitude&#39;) plt.xlabel(&#39;Latitude&#39;) plt.colorbar(fraction=0.022,pad=0.05) plt.clim(-4,4) . C: Users ehfus AppData Local Temp/ipykernel_14492/3478053917.py:4: MatplotlibDeprecationWarning: shading=&#39;flat&#39; when X and Y have the same dimensions as C is deprecated since 3.3. Either specify the corners of the quadrilaterals with X and Y, or pass shading=&#39;auto&#39;, &#39;nearest&#39; or &#39;gouraud&#39;, or set rcParams[&#39;pcolor.shading&#39;]. This will become an error two minor releases later. plt.pcolormesh(grid_x,grid_y,data_interp,cmap=&#39;coolwarm&#39;,alpha=0.6) .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/29/intro.html",
            "relUrl": "/2021/12/29/intro.html",
            "date": " • Dec 29, 2021"
        }
        
    
  
    
        ,"post10": {
            "title": "2021/12/28/TUE",
            "content": "Function . def f() : pass . pass =&gt; 나중에 정의해줄테니 일단 f라는 함수를 정의해 놓을때 | . def f() : print(&#39;Hello&#39;) . f() . def f_(x) : print(&#39;Hello&#39; + str()) . y=f_(5555) . y . type(y) . 아무것도 안 나옴 . | output이 없는 함수이기 때문에 . | output이 있는 함수를 만들어보자 . | . def fn(x) : y=x+10 return y . y=fn(3) . y . type(y) . out=fn(123) . print(out) . out . . local &amp; global . 얘는 함수 바깥에 있는 변수임 . y=5 # global 변수 . def fn(x) : y=x+10 print(&#39;함수 안에 있는 변수, y=&#39; + str(y)) return y # local 변수 . fn(2) . print(&#39;함수 밖에 있는 변수, y=&#39; + str(y)) . . local을 global로 사용해보자 . def fn(x) : global y y=x+10 return y . fn(3) . y . . def f2(x): return x+10 . f2(3) . . input을 지정 안 하고 함수가 알아서 지정할 수 있게 할 수 있음 | . def f2(x=5): return x+10 . f2() . f2(40) . 물론 이렇게 input을 다시 줄 순 있음 | . . def f3(x1,x2): return x1+x2 . f3(3,5) . . def f4(name,age=0,lan=&#39;NONE&#39;): print(name+&#39; &#39;+str(age)+&#39; &#39;+lan) . f4(&#39;rhkrehtjd&#39;) # 이렇게 나이와 lan을 입력 안 해도 함수 만들 때 미리 지정해주고 시작해도 됨 # 그런데 입력값이 생겼을 땐 그 입력값을 사용할 수 있음 . f4(&#39;rhkrehtjd&#39;,2,&#39;R&#39;) . 순서를 바꿔 쓴다면? | . f4(&#39;rhkrehtjd&#39;,lan=&#39;python&#39;,age=123) . 이렇게 순서 바꿔쓸거면 keyword만 제대로 명시해주자 | . 그런데 이렇게 순서 바꿔쓸 수 있는건 초기화로 설정된 변수에서만 사용가능함 . | 즉 이 함수 f4에선 age하고 lan만 초기화 상태로 명했고 name은 초기화해놓지 않았기 때문에 name은 그 자리에서 input해줘야 함 . | . . def ff(*x): print(x) . ff(&#39;abc&#39;,&#39;asd&#39;,&#39;qgeqve&#39;,&#39;asdasdf&#39;) . 이렇게 input이 몇개가 들어와도 해결이 가능함 | . def fff(*x): for a in x: print(a) . fff(&#39;asd&#39;,&#39;asdqw&#39;,&#39;qwg&#39;) . . 이런식으로 input을 몇개주더라도 그 input을 다 더해주는 함수 . def qq(*args): total = 0 for a in args: total += a return total . qq(12,12,34) . . def cc(*x): com=&#39;&#39; for a in x: com +=a return com . cc(&#39;pt&#39;,&#39;Rhkrehtjd&#39;) . . #박스를 펼치는 것처럼 arguements를 하나로 받아서 펼치는... a=[10,15] list(range(a[0],a[1]+1,)) . a[1]+=1 . list(range(*a)) . . def qq(): num_s=int(input(&#39;Start num: &#39;)) num_e=int(input(&#39;End num: &#39;)) num_inc=int(input(&#39;Increment: &#39;)) out_list=list(range(num_s,num_e+1,num_inc)) return out_list . qq() . 입력 세번을 한 번에 할 수 있게 해보자 | . def qq2(): print(&#39;숫자를 다음과 같이 입력해주세요 &#39;) print(&#39;시작: ,끝: ,증가단위: &#39;) print(&#39;예시: 0,5,1&#39;) ui=input(&#39;입력해주세요: &#39;) ui_list=[int(i)for i in ui.split(&#39;,&#39;)] out_list=list(range(*ui_list)) return out_list . qq2 () . 만약 마지막 숫자도 포함하고 싶다면? | . def qq2(): print(&#39;숫자를 다음과 같이 입력해주세요 &#39;) print(&#39;시작: ,끝: ,증가단위: &#39;) print(&#39;예시: 0,5,1&#39;) ui=input(&#39;입력해주세요: &#39;) ui_list=[int(i)for i in ui.split(&#39;,&#39;)] ui_list[1]+=1 out_list=list(range(*ui_list)) return out_list . qq2() . . documentation $ to$ 함수에 도움말을 넣어보자 | . def qw(x): &quot;&quot;&quot; 여기가 함수의 도움말 &quot;&quot;&quot; return x+10 . help(qw) . print(qw.__doc__) . . annotation . def fu(num): out=num+10 return out . print(fu.__annotations__) . def fu(num:int): out=num+10 return out . print(fu.__annotations__) . input이 들어올 때 어떤 형식으로 들어와야 하는지 주석을 달아준다고 생각하면 됨 . def fu(num:int)-&gt;int: out=num+10 return out . print(fu.__annotations__) . 이렇게 output의 자료형도 주석을 달듯이 알려줄 수가 있음 . . lambda . add_one = lambda x: x+1 . add_one(1) . y=(lambda x:x+1)(10) . y . lambda를 사용할 때 이렇게 한 줄로 함수와 입력을 동시에 명해줄 수가 있음 | . def a(x): return x+10 . high_ord_function=lambda x: x+a(x) . high_ord_function(2) . . high_ord_function=lambda x, ff:x+ff(x) . high_ord_function(2,lambda x:x+1) . high_ord_function(2,lambda x:x-1) . 이런식으로 lmabda를 사용하게 되면 실시간으로 함수자체를 input으로 줘서 고차원 함수를 사용할 수 있게 됨 | . . map . import numpy as np a=np.array([1,2,3,4,5]) a*2 . a=[1,2,3,4,5] a*2 . 물론 numpy를 활용하여 각 원소들을 두배 해줄 수도 있겠지만 list에선 불가능, 그럼 꼭 numpy를 사용해야할까, 그냥 map을 사용해도 된다. . list(map(lambda x: x+10,[1,2,3])) . lambda x:x+10 이 자리에 이미 정의되어 있는 함수 이름을 그대로 넣어줘도 됨 . vip=&#39;rhkrehtjd&#39; vip.upper() . vip_list=[&#39;adqw&#39;,&#39;wfdf&#39;,&#39;sdgv&#39;] . vip_list는 list이기 때문에 upper라는 함수를 지원하지 않음 . | 그렇지만 vip_list안에 있는 str은 upper라는 함수를 사용할 수 있음 . | . vip_list=list(map(lambda x: x.upper() ,vip_list)) . vip_list . . vip_list_name_len_list=list(map(lambda x:len(x), vip_list)) . vip_list_name_len_list . . &#51473;&#50836;** filter . list(filter(lambda x: &#39;P&#39; in x, vip_list)) . 아무도 없어서 빈 list가 나왔음 . list(filter(lambda x: &#39;W&#39; in x, vip_list)) . x=[1,2,3,4,5] list(filter(lambda x: x%2==0,x)) . list(filter(lambda x: x%2!=0,x)) . . reduce . from functools import reduce . list_=[10,20,30] . def add(x,y): return x+y . reduce(add,list_) . 연속적으로 연산을 수행해준다고 생각하면 됨 . 이걸 lambda를 사용하여 해결해보자 . reduce(lambda a,b : a+b,list_) . sum(list_) . . strlist=[&#39;p&#39;,&#39;y&#39;,&#39;t&#39;,&#39;h&#39;,&#39;o&#39;,&#39;n&#39;,] . reduce(lambda x,y:x+y,strlist) . . for문 $vs$ list comprehension $vs$ lambda function . letter_list=[] for letter in &#39;python&#39;: letter_list.append(letter) print(letter_list) . [&#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;] . letter_list_2=[letter for letter in &#39;python&#39;] letter_list_2 . [&#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;] . list(map(lambda x : x, &#39;python&#39;)) . [&#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;] . . a,b=0,1 . a . 0 . 이렇게 변수 두개를 한 번에 저장해줄 수 있음 . tuple을 만드는 게 아님 . def my_fib_seq(n): a,b=0,1 seq=[a,b] for i in range(n-2): # 이미 0,1은 있으니까 -2해줌 a,b=b,a+b seq.append(b) return seq . my_fib_seq(3) . [0, 1, 1] . 이렇게 fibonachi 수열을 만들어봤음 . def my_powers(number): return number,number**2,number**3 . a=my_powers(2) . list(a) . [2, 4, 8] . number,square,cube=my_powers(2) . cube만 필요하다? . *_, cube=my_powers(2) . cube . 8 . _ . [2, 4] . 이렇게 unpacking할 수도 있음 . def my_sum(num_list): total = 0 for num in num_list: total+=num return total . my_sum([1,2,3]) . 6 . def my_mean(num_list): s=my_sum(num_list) N=len(num_list) return s/N . my_mean([8,10]) . 9.0 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/28/intro.html",
            "relUrl": "/2021/12/28/intro.html",
            "date": " • Dec 28, 2021"
        }
        
    
  
    
        ,"post11": {
            "title": "2021/12/27/MON",
            "content": "import numpy as np x_list=[1,2,3] x_tuple=1,2,3 x_set={1,2,3} x_dict={&#39;a&#39; : 1,&#39;b&#39; : 2,&#39;c&#39; : 3} x_array=np.array([1,2,3]) x_range=range(1,4,1) . for i in x_dict: print(i) . a b c . key만 나왔음, 후에 부가 설명하겠음 | . i=1 print(i) . 1 . i=2 print(i) . 2 . i=3 print(i) . 3 . 이걸 계속? . for i in [1,2,3]: print(i) . 1 2 3 . i . 3 . import time for i in [1,2,3]: print(&#39;i=&#39; + str(i)) time.sleep(1) . i=1 i=2 i=3 . 이때 i는 마지막 값인 3으로 저장될 것 | . . 1부터 100까지 = range(1,100,1) . range(101)은 0부터 100까지임 . 또는 np.linspace(1,100,100)으로도 사용가능 . . iterable object이 str일 땐? . for i in &#39;12345&#39;: print(i) . 1 2 3 4 5 . i . &#39;5&#39; . for i in &#39;python&#39;: print(i) . p y t h o n . for i in {1,2,3,4,5}: print(i) . 1 2 3 4 5 . d={&#39;P1&#39;:11,&#39;P3&#39;:31,&#39;P2&#39;:13} . d.items() . dict_items([(&#39;P1&#39;, 11), (&#39;P3&#39;, 31), (&#39;P2&#39;, 13)]) . d.keys() . dict_keys([&#39;P1&#39;, &#39;P3&#39;, &#39;P2&#39;]) . d.values() . dict_values([11, 31, 13]) . for i in d.items(): print(i) . (&#39;P1&#39;, 11) (&#39;P3&#39;, 31) (&#39;P2&#39;, 13) . i . (&#39;P2&#39;, 13) . for i in d.keys(): print(i) . P1 P3 P2 . for i in d.values(): print(i) . 11 31 13 . . for i in np.array([1,2,3]): print(i) . 1 2 3 . i . 3 . . &#48152;&#48373;&#47928; &#51473;&#52393; . for i in range(1,4,1): for j in [1,2]: print(&#39;i*j={}*{}={}&#39;.format(i,j,i*j)) . i*j=1*1=1 i*j=1*2=2 i*j=2*1=2 i*j=2*2=4 i*j=3*1=3 i*j=3*2=6 . . 반복문은 iterable일 때 사용가능 . 그렇다면 iterable?? . x_list=[1,2,3] . x_iter=iter(x_list) . next(x_iter) # 하나하나 차례로 나올 것, 그리고 마지막엔 오류 . &#39;c&#39; . x_str=&#39;abc&#39; x_iter=iter(x_str) . next(x_iter) # 하나하나 차례로 나올 것, 그리고 마지막엔 오류 . &#39;a&#39; . 값을 하나씩 불러온다는 것만 알아두자 . . for i in range(3): print(&#39;여긴 적용 O&#39;) print(&#39;--&#39;) print(&#39;여긴 적용 X&#39;) . 여긴 적용 O 여긴 적용 O 여긴 적용 O -- 여긴 적용 X . . m=np.array([1,2,3]) n=[&#39;sd&#39;,&#39;asd&#39;,&#39;asdd&#39;] q={&#39;a&#39;:11,&#39;d&#39;:22,&#39;c&#39;:123} . for i,v in enumerate(m): print(i) print(v) print(&#39; &#39;) ## i,v는 아무이름이나 가능 . 0 1 1 2 2 3 . for i,v in enumerate(q.items()): print(i) print(v) print(&#39; &#39;) ## i,v는 아무이름이나 가능 . 0 (&#39;a&#39;, 11) 1 (&#39;d&#39;, 22) 2 (&#39;c&#39;, 123) . 반복문이 몇번 돌아갔는지? | . 인덱스를 1부터 시작하게 해서 count할 수 있음 | . for i,v in enumerate(m,start=1): print(i) print(v) print(&#39; &#39;) ## i,v는 아무이름이나 가능 . 1 1 2 2 3 3 . . for i in zip(m,n): print(i) . (1, &#39;sd&#39;) (2, &#39;asd&#39;) (3, &#39;asdd&#39;) . 두 개의 container자료를 불러온 것 . list로 불러올 수 있음 . for i in zip(m,n): print(list(i)) . [1, &#39;sd&#39;] [2, &#39;asd&#39;] [3, &#39;asdd&#39;] . for i in zip(m,n,q.items()): print(list(i)) . [1, &#39;sd&#39;, (&#39;a&#39;, 11)] [2, &#39;asd&#39;, (&#39;d&#39;, 22)] [3, &#39;asdd&#39;, (&#39;c&#39;, 123)] . . 반복문 활용 예시 . s=&#39;♡Best Company♡ Tel: 123-123123&#39; for i in range(5): print(s) print(&#39; &#39;) . ♡Best Company♡ Tel: 123-123123 ♡Best Company♡ Tel: 123-123123 ♡Best Company♡ Tel: 123-123123 ♡Best Company♡ Tel: 123-123123 ♡Best Company♡ Tel: 123-123123 . a=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] for i in a: print(&#39;Name : &#39; + i) print(&#39;오잉?&#39;) print(&#39;&#39;) . Name : a 오잉? Name : b 오잉? Name : c 오잉? . x=np.array([1,2,3,4,5]) for i in x: print(i**2) time.sleep(0.5) . 1 4 9 16 25 . x=np.array([1,2,3,4,5]) for i,x in enumerate(x): print(i) print(x) print(&#39;&#39;) . 0 1 1 2 2 3 3 4 4 5 . x=np.array([1,2,3,4,5]) y=np.zeros(x.shape) for i,x in enumerate(x): y[i]=x**2 print(y) . [1. 0. 0. 0. 0.] [1. 4. 0. 0. 0.] [1. 4. 9. 0. 0.] [ 1. 4. 9. 16. 0.] [ 1. 4. 9. 16. 25.] . . a=np.array([1,2,3,]) y=a**2 . y . array([1, 4, 9], dtype=int32) . 이렇게 해결할 수 있는 걸 굳이 반복문 사용할 필요는 없음 | . . 피보나치 수열 :앞에 숫자를 계속 더해주는$ dots$ . a=np.array([0,1]) for i in range(3): a=np.append(a,a[-1]+a[-2]) print(a) . [0 1 1] [0 1 1 2] [0 1 1 2 3] . . a,b=0,1 for i in range(10): print(a) a,b=b,a+b . 0 1 1 2 3 5 8 13 21 34 . 피보나치 수열을 이렇게 표현할 수도 있음 | . . ***&#51312;&#44148;&#47928; . x=input(&#39;Type any number: &#39;) if x.isdigit(): y=int(x)+1 print(&#39;Result is {}&#39;.format(y)) else : print(&#39;정수 쳐 넣어&#39;) . 정수 쳐 넣어 . 첫번째 줄에서 입력되는 것이 숫자인지 문자인지? $ to$ isdigit을 이용!! | . x=input(&#39;Type any number: &#39;) while x.isdigit() != True : x=input(&#39;Try again: &#39;) y=int(x)+1 print(&#39;Result is {}&#39;.format(y)) . Result is 6 . while문 =&gt; 무한 반복 . x=int(input(&#39;몇살이니? : &#39;)) if x&gt;=18 : print(&#39;면허 딸 수 있겠다&#39;) elif x&gt;=15 &amp; x&lt;18 : print(&#39;승인은 가능하겠다&#39;) else : print(&#39;나이가 어려서 안 돼&#39;) . 면허 딸 수 있겠다 . x=int(input(&#39;몇살이니? : &#39;)) if x&gt;=18 : print(&#39;면허 딸 수 있겠다&#39;) elif x&gt;=15 &amp; x&lt;18 : print(&#39;승인은 가능하겠다&#39;) else : print(&#39;나이가 어려서 안 돼&#39;) . 승인은 가능하겠다 . x=int(input(&#39;몇살이니? : &#39;)) if x&gt;=18 : print(&#39;면허 딸 수 있겠다&#39;) elif x&gt;=15 and x&lt;18 : print(&#39;승인은 가능하겠다&#39;) else : print(&#39;나이가 어려서 안 돼&#39;) . 나이가 어려서 안 돼 . &#44536;&#47088;&#45936; and &#45824;&#49888;&#50640; &amp; &#49324;&#50857;&#54616;&#47732; &#50504; &#46120; . 알아보기 . . a=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;] check=input(&#39;please name: &#39;) if check in a : print(&#39;어서와&#39; +&quot; &quot; + check+&#39;야&#39;) else : print(&#39;넌 명단에 없네&#39;) . 넌 명단에 없네 . . While . vip=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;] a=[1,2] a_=[] . bool(a) . True . bool(a_) . False . while은 참일때만 실행하니까 vip리스트에 하나도 없으면, 즉 FALSE이면 실행 멈출 것 . while vip: print(vip.pop(0)) print(&#39;remaining guest #: {}&#39;.format(len(vip))) . a remaining guest #: 3 b remaining guest #: 2 c remaining guest #: 1 d remaining guest #: 0 . . pop(인덱스), 즉 해당 인덱스값 삭제 . pop =&gt; 튕겨버림 =&gt; 버려버림 . . balance=10000 # 가지고 있는 돈 interest=0.05 # 이자율 yr=0 # 시작 연도 # 통장에 10000원 넣어놓고 몇년이 지나야 20000원이 될까? . while balance &lt; 20000: balance=balance*(1+interest) yr+=1 print(&#39;# of Year : {}&#39;.format(yr)) print(&#39;Current values= {}&#39;.format(balance)) . # of Year : 1 Current values= 10500.0 # of Year : 2 Current values= 11025.0 # of Year : 3 Current values= 11576.25 # of Year : 4 Current values= 12155.0625 # of Year : 5 Current values= 12762.815625000001 # of Year : 6 Current values= 13400.956406250001 # of Year : 7 Current values= 14071.004226562502 # of Year : 8 Current values= 14774.554437890627 # of Year : 9 Current values= 15513.28215978516 # of Year : 10 Current values= 16288.946267774418 # of Year : 11 Current values= 17103.393581163138 # of Year : 12 Current values= 17958.563260221297 # of Year : 13 Current values= 18856.491423232364 # of Year : 14 Current values= 19799.315994393983 # of Year : 15 Current values= 20789.281794113682 . . 즉 15년까지 while이 진행됐다는 건 15년째 20000을 넘었기 때문에 다음 16이 진행 안 된 것 , . 따라서 15년때 20000을 넘은 것을 알 수 있음 . . for i in range(5): print(i) if i ==3 : break . 0 1 2 3 . balance=10000 # 가지고 있는 돈 interest=0.05 # 이자율 yr=0 # 시작 연도 for i in range(10000): balance=balance*(1+interest) yr+=1 print(&#39;# of Year : {}&#39;.format(yr)) print(&#39;Current values= {}&#39;.format(balance)) if balance &gt;20000 : break . # of Year : 1 Current values= 10500.0 # of Year : 2 Current values= 11025.0 # of Year : 3 Current values= 11576.25 # of Year : 4 Current values= 12155.0625 # of Year : 5 Current values= 12762.815625000001 # of Year : 6 Current values= 13400.956406250001 # of Year : 7 Current values= 14071.004226562502 # of Year : 8 Current values= 14774.554437890627 # of Year : 9 Current values= 15513.28215978516 # of Year : 10 Current values= 16288.946267774418 # of Year : 11 Current values= 17103.393581163138 # of Year : 12 Current values= 17958.563260221297 # of Year : 13 Current values= 18856.491423232364 # of Year : 14 Current values= 19799.315994393983 # of Year : 15 Current values= 20789.281794113682 . 즉 15는 20000을 넘어서 break된 것을 알 수 있음 . . for i in range(5): continue print(i) . 왜 아무것도 출력 $X$ ? . 반복문은 다섯번 반복됐으나 그럴 때마다 continue를 만나서 다시 위로 올라가서 반복했기 때문 | . for i in range(5): if i==2 : continue print(i) . 0 1 3 4 . 2와 같을 땐 밑에 줄 신경 안쓰고 그냥 바로 위로 쭉 올라감 . . temp=[18,19,20,-10,-20,-30] . for t in temp: print(&#39;T={}&#39;.format(t)) . T=18 T=19 T=20 T=-10 T=-20 T=-30 . 이때 -값은 오류라고 생각하고 print하고 싶지 않을 땐? . for t in temp: if t&lt;0 : continue print(&#39;T={}&#39;.format(t)) . T=18 T=19 T=20 . . for x in range(5): pass x=1 . x . 1 . if True: pass x=1 . x . 1 . def myfun(): pass a=23 . a . 23 . 그냥 일단 패스시켜놓고 나중에 완성 시키고 싶을 때 . . 예외처리? . age=int(input(&#39;몇살이니?: &#39;)) print(&#39;Age={}&#39;.format(age)) . Age=555 . 만약 여기서 숫자가 아닌 문자를 넣으면 value error가 발생할 것 . while True: try: age=int(input(&#39;몇살이니?: &#39;)) print(&#39;Age={}&#39;.format(age)) break except ValueError: print(&#39;숫자를 입력해주세요&#39;) . 숫자를 입력해주세요 . 숫자를 입력해주세요 . 숫자를 입력해주세요 . 숫자를 입력해주세요 . Age=555 . 숫자를 입력할 때까지 while문이 실행될 것 . a=np.array([10,20,30,40,50]) num_max=np.NINF # 음의 무한대를 의미함 for i in a: num_curr = i if num_max &lt; num_curr: num_max=num_curr . num_max . 50 . . a=np.array([1,2,3,4,5,6]) for i in a: if i%2==0: print(&#39;{}는 짝수&#39;.format(i)) else : print(&#39;{}는 홀수&#39;.format(i)) . 1는 홀수 2는 짝수 3는 홀수 4는 짝수 5는 홀수 6는 짝수 . . User Interface Example/ UI . db={&#39;a&#39;:&#39;a1&#39;,&#39;b&#39;:&#39;b1&#39;,&#39;c&#39;:&#39;c1&#39;} password_attemps=3 while password_attemps &gt; 0 : user_id = input(&#39;ID: &#39;) user_ps = input(&#39;PW: &#39;) if user_id in db.keys() and user_ps in db.values() : print(&#39; nLog in Successful!&#39;) break else: password_attemps-=1 print(&#39; nTry againㅠㅠ&#39;) print(&#39;{} 번 더 시도 가능하십니다&#39;.format(password_attemps)) . Try againㅠㅠ 2 번 더 시도 가능하십니다 . Try againㅠㅠ 1 번 더 시도 가능하십니다 . Try againㅠㅠ 0 번 더 시도 가능하십니다 . import getpass 기능을 이용해서 password입력 할 때 해당 PW를 안 보이게 해줄 수 있음 . . my_str=&#39;python&#39; my_str2=[] for letter in my_str: my_str2.append(letter) . my_str . &#39;python&#39; . my_str2 . [&#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;] . $ to$ 이걸 한 줄로 가능하게 하는 것이 List Comprehension . my_str3=[letter for letter in my_str] my_str3 . [&#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;] . list comprehension + 조건 . num=[a for a in range(20) if a%2==0] . num . [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] . num=[a for a in range(20) if a%2!=0] . num . [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] . num=[a for a in range(50) if a%5==0 and a%2==0] . num . [0, 10, 20, 30, 40] . 또는 . num=[a for a in range(50) if a%5==0 if a%2==0] . num . [0, 10, 20, 30, 40] . . aaa=[&#39;짝수&#39;if i%2==0 else &#39;홀수&#39; for i in range(10)] . aaa . [&#39;짝수&#39;, &#39;홀수&#39;, &#39;짝수&#39;, &#39;홀수&#39;, &#39;짝수&#39;, &#39;홀수&#39;, &#39;짝수&#39;, &#39;홀수&#39;, &#39;짝수&#39;, &#39;홀수&#39;] . . dict comprehension . a={i:i**2 for i in range(6)} a . {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25} . . import sys,os . print(os.getcwd()) . C: Users ehfus Downloads python Introduction . os.mkdir(&#39;my_dir&#39;) # 현재 있는 위치에서 my_dir을 하나 만듦 . os.chdir(&#39;. my_dir&#39;) . 파일 100개 만들어보자 . for i in range(100): f=open(&#39;NewFile&#39;+str(i),&#39;w&#39;) # 파일을 쓸 거니까 &#39;w&#39; f.close() . 100개의 파일에 뭘 쓰진 않았음. 이제 파일의 이름을 바꿔보자 . 반복문을 통해 100개의 파일 이름을 바꾸기 전에 100개 파일의 이름을 일단 받아오자 . flist=os.listdir(&#39;.&#39;) . flist . [&#39;NewFile0&#39;, &#39;NewFile1&#39;, &#39;NewFile10&#39;, &#39;NewFile11&#39;, &#39;NewFile12&#39;, &#39;NewFile13&#39;, &#39;NewFile14&#39;, &#39;NewFile15&#39;, &#39;NewFile16&#39;, &#39;NewFile17&#39;, &#39;NewFile18&#39;, &#39;NewFile19&#39;, &#39;NewFile2&#39;, &#39;NewFile20&#39;, &#39;NewFile21&#39;, &#39;NewFile22&#39;, &#39;NewFile23&#39;, &#39;NewFile24&#39;, &#39;NewFile25&#39;, &#39;NewFile26&#39;, &#39;NewFile27&#39;, &#39;NewFile28&#39;, &#39;NewFile29&#39;, &#39;NewFile3&#39;, &#39;NewFile30&#39;, &#39;NewFile31&#39;, &#39;NewFile32&#39;, &#39;NewFile33&#39;, &#39;NewFile34&#39;, &#39;NewFile35&#39;, &#39;NewFile36&#39;, &#39;NewFile37&#39;, &#39;NewFile38&#39;, &#39;NewFile39&#39;, &#39;NewFile4&#39;, &#39;NewFile40&#39;, &#39;NewFile41&#39;, &#39;NewFile42&#39;, &#39;NewFile43&#39;, &#39;NewFile44&#39;, &#39;NewFile45&#39;, &#39;NewFile46&#39;, &#39;NewFile47&#39;, &#39;NewFile48&#39;, &#39;NewFile49&#39;, &#39;NewFile5&#39;, &#39;NewFile50&#39;, &#39;NewFile51&#39;, &#39;NewFile52&#39;, &#39;NewFile53&#39;, &#39;NewFile54&#39;, &#39;NewFile55&#39;, &#39;NewFile56&#39;, &#39;NewFile57&#39;, &#39;NewFile58&#39;, &#39;NewFile59&#39;, &#39;NewFile6&#39;, &#39;NewFile60&#39;, &#39;NewFile61&#39;, &#39;NewFile62&#39;, &#39;NewFile63&#39;, &#39;NewFile64&#39;, &#39;NewFile65&#39;, &#39;NewFile66&#39;, &#39;NewFile67&#39;, &#39;NewFile68&#39;, &#39;NewFile69&#39;, &#39;NewFile7&#39;, &#39;NewFile70&#39;, &#39;NewFile71&#39;, &#39;NewFile72&#39;, &#39;NewFile73&#39;, &#39;NewFile74&#39;, &#39;NewFile75&#39;, &#39;NewFile76&#39;, &#39;NewFile77&#39;, &#39;NewFile78&#39;, &#39;NewFile79&#39;, &#39;NewFile8&#39;, &#39;NewFile80&#39;, &#39;NewFile81&#39;, &#39;NewFile82&#39;, &#39;NewFile83&#39;, &#39;NewFile84&#39;, &#39;NewFile85&#39;, &#39;NewFile86&#39;, &#39;NewFile87&#39;, &#39;NewFile88&#39;, &#39;NewFile89&#39;, &#39;NewFile9&#39;, &#39;NewFile90&#39;, &#39;NewFile91&#39;, &#39;NewFile92&#39;, &#39;NewFile93&#39;, &#39;NewFile94&#39;, &#39;NewFile95&#39;, &#39;NewFile96&#39;, &#39;NewFile97&#39;, &#39;NewFile98&#39;, &#39;NewFile99&#39;] . for fid in flist: f_name=fid[0:7] f_num=fid[7::] if int(f_num)&lt;50: os.replace(fid,&#39;2019_&#39;+fid) else: os.replace(fid,&#39;2020_&#39;+fid) . 2019년도 파일 2020년도 파일을 두개의 디렉토리에 각각 넣어보자 . os.mkdir(&#39;2019_data&#39;) os.mkdir(&#39;2020_data&#39;) . flist=os.listdir(&#39;.&#39;) . flist . [&#39;2019_data&#39;, &#39;2019_NewFile0&#39;, &#39;2019_NewFile1&#39;, &#39;2019_NewFile10&#39;, &#39;2019_NewFile11&#39;, &#39;2019_NewFile12&#39;, &#39;2019_NewFile13&#39;, &#39;2019_NewFile14&#39;, &#39;2019_NewFile15&#39;, &#39;2019_NewFile16&#39;, &#39;2019_NewFile17&#39;, &#39;2019_NewFile18&#39;, &#39;2019_NewFile19&#39;, &#39;2019_NewFile2&#39;, &#39;2019_NewFile20&#39;, &#39;2019_NewFile21&#39;, &#39;2019_NewFile22&#39;, &#39;2019_NewFile23&#39;, &#39;2019_NewFile24&#39;, &#39;2019_NewFile25&#39;, &#39;2019_NewFile26&#39;, &#39;2019_NewFile27&#39;, &#39;2019_NewFile28&#39;, &#39;2019_NewFile29&#39;, &#39;2019_NewFile3&#39;, &#39;2019_NewFile30&#39;, &#39;2019_NewFile31&#39;, &#39;2019_NewFile32&#39;, &#39;2019_NewFile33&#39;, &#39;2019_NewFile34&#39;, &#39;2019_NewFile35&#39;, &#39;2019_NewFile36&#39;, &#39;2019_NewFile37&#39;, &#39;2019_NewFile38&#39;, &#39;2019_NewFile39&#39;, &#39;2019_NewFile4&#39;, &#39;2019_NewFile40&#39;, &#39;2019_NewFile41&#39;, &#39;2019_NewFile42&#39;, &#39;2019_NewFile43&#39;, &#39;2019_NewFile44&#39;, &#39;2019_NewFile45&#39;, &#39;2019_NewFile46&#39;, &#39;2019_NewFile47&#39;, &#39;2019_NewFile48&#39;, &#39;2019_NewFile49&#39;, &#39;2019_NewFile5&#39;, &#39;2019_NewFile6&#39;, &#39;2019_NewFile7&#39;, &#39;2019_NewFile8&#39;, &#39;2019_NewFile9&#39;, &#39;2020_data&#39;, &#39;2020_NewFile50&#39;, &#39;2020_NewFile51&#39;, &#39;2020_NewFile52&#39;, &#39;2020_NewFile53&#39;, &#39;2020_NewFile54&#39;, &#39;2020_NewFile55&#39;, &#39;2020_NewFile56&#39;, &#39;2020_NewFile57&#39;, &#39;2020_NewFile58&#39;, &#39;2020_NewFile59&#39;, &#39;2020_NewFile60&#39;, &#39;2020_NewFile61&#39;, &#39;2020_NewFile62&#39;, &#39;2020_NewFile63&#39;, &#39;2020_NewFile64&#39;, &#39;2020_NewFile65&#39;, &#39;2020_NewFile66&#39;, &#39;2020_NewFile67&#39;, &#39;2020_NewFile68&#39;, &#39;2020_NewFile69&#39;, &#39;2020_NewFile70&#39;, &#39;2020_NewFile71&#39;, &#39;2020_NewFile72&#39;, &#39;2020_NewFile73&#39;, &#39;2020_NewFile74&#39;, &#39;2020_NewFile75&#39;, &#39;2020_NewFile76&#39;, &#39;2020_NewFile77&#39;, &#39;2020_NewFile78&#39;, &#39;2020_NewFile79&#39;, &#39;2020_NewFile80&#39;, &#39;2020_NewFile81&#39;, &#39;2020_NewFile82&#39;, &#39;2020_NewFile83&#39;, &#39;2020_NewFile84&#39;, &#39;2020_NewFile85&#39;, &#39;2020_NewFile86&#39;, &#39;2020_NewFile87&#39;, &#39;2020_NewFile88&#39;, &#39;2020_NewFile89&#39;, &#39;2020_NewFile90&#39;, &#39;2020_NewFile91&#39;, &#39;2020_NewFile92&#39;, &#39;2020_NewFile93&#39;, &#39;2020_NewFile94&#39;, &#39;2020_NewFile95&#39;, &#39;2020_NewFile96&#39;, &#39;2020_NewFile97&#39;, &#39;2020_NewFile98&#39;, &#39;2020_NewFile99&#39;] . from itertools import compress . idx = list(map(lambda x:&#39;File&#39; in x, flist)) flist2 = list(compress(flist,idx)) . flist2 . [&#39;2019_NewFile0&#39;, &#39;2019_NewFile1&#39;, &#39;2019_NewFile10&#39;, &#39;2019_NewFile11&#39;, &#39;2019_NewFile12&#39;, &#39;2019_NewFile13&#39;, &#39;2019_NewFile14&#39;, &#39;2019_NewFile15&#39;, &#39;2019_NewFile16&#39;, &#39;2019_NewFile17&#39;, &#39;2019_NewFile18&#39;, &#39;2019_NewFile19&#39;, &#39;2019_NewFile2&#39;, &#39;2019_NewFile20&#39;, &#39;2019_NewFile21&#39;, &#39;2019_NewFile22&#39;, &#39;2019_NewFile23&#39;, &#39;2019_NewFile24&#39;, &#39;2019_NewFile25&#39;, &#39;2019_NewFile26&#39;, &#39;2019_NewFile27&#39;, &#39;2019_NewFile28&#39;, &#39;2019_NewFile29&#39;, &#39;2019_NewFile3&#39;, &#39;2019_NewFile30&#39;, &#39;2019_NewFile31&#39;, &#39;2019_NewFile32&#39;, &#39;2019_NewFile33&#39;, &#39;2019_NewFile34&#39;, &#39;2019_NewFile35&#39;, &#39;2019_NewFile36&#39;, &#39;2019_NewFile37&#39;, &#39;2019_NewFile38&#39;, &#39;2019_NewFile39&#39;, &#39;2019_NewFile4&#39;, &#39;2019_NewFile40&#39;, &#39;2019_NewFile41&#39;, &#39;2019_NewFile42&#39;, &#39;2019_NewFile43&#39;, &#39;2019_NewFile44&#39;, &#39;2019_NewFile45&#39;, &#39;2019_NewFile46&#39;, &#39;2019_NewFile47&#39;, &#39;2019_NewFile48&#39;, &#39;2019_NewFile49&#39;, &#39;2019_NewFile5&#39;, &#39;2019_NewFile6&#39;, &#39;2019_NewFile7&#39;, &#39;2019_NewFile8&#39;, &#39;2019_NewFile9&#39;, &#39;2020_NewFile50&#39;, &#39;2020_NewFile51&#39;, &#39;2020_NewFile52&#39;, &#39;2020_NewFile53&#39;, &#39;2020_NewFile54&#39;, &#39;2020_NewFile55&#39;, &#39;2020_NewFile56&#39;, &#39;2020_NewFile57&#39;, &#39;2020_NewFile58&#39;, &#39;2020_NewFile59&#39;, &#39;2020_NewFile60&#39;, &#39;2020_NewFile61&#39;, &#39;2020_NewFile62&#39;, &#39;2020_NewFile63&#39;, &#39;2020_NewFile64&#39;, &#39;2020_NewFile65&#39;, &#39;2020_NewFile66&#39;, &#39;2020_NewFile67&#39;, &#39;2020_NewFile68&#39;, &#39;2020_NewFile69&#39;, &#39;2020_NewFile70&#39;, &#39;2020_NewFile71&#39;, &#39;2020_NewFile72&#39;, &#39;2020_NewFile73&#39;, &#39;2020_NewFile74&#39;, &#39;2020_NewFile75&#39;, &#39;2020_NewFile76&#39;, &#39;2020_NewFile77&#39;, &#39;2020_NewFile78&#39;, &#39;2020_NewFile79&#39;, &#39;2020_NewFile80&#39;, &#39;2020_NewFile81&#39;, &#39;2020_NewFile82&#39;, &#39;2020_NewFile83&#39;, &#39;2020_NewFile84&#39;, &#39;2020_NewFile85&#39;, &#39;2020_NewFile86&#39;, &#39;2020_NewFile87&#39;, &#39;2020_NewFile88&#39;, &#39;2020_NewFile89&#39;, &#39;2020_NewFile90&#39;, &#39;2020_NewFile91&#39;, &#39;2020_NewFile92&#39;, &#39;2020_NewFile93&#39;, &#39;2020_NewFile94&#39;, &#39;2020_NewFile95&#39;, &#39;2020_NewFile96&#39;, &#39;2020_NewFile97&#39;, &#39;2020_NewFile98&#39;, &#39;2020_NewFile99&#39;] . dir이름은 없고 파일이름만 뽑아온 것 . 두번째 방법 . flist3=list(filter(lambda x: &#39;File&#39; in x, flist)) . flist3 . [&#39;2019_NewFile0&#39;, &#39;2019_NewFile1&#39;, &#39;2019_NewFile10&#39;, &#39;2019_NewFile11&#39;, &#39;2019_NewFile12&#39;, &#39;2019_NewFile13&#39;, &#39;2019_NewFile14&#39;, &#39;2019_NewFile15&#39;, &#39;2019_NewFile16&#39;, &#39;2019_NewFile17&#39;, &#39;2019_NewFile18&#39;, &#39;2019_NewFile19&#39;, &#39;2019_NewFile2&#39;, &#39;2019_NewFile20&#39;, &#39;2019_NewFile21&#39;, &#39;2019_NewFile22&#39;, &#39;2019_NewFile23&#39;, &#39;2019_NewFile24&#39;, &#39;2019_NewFile25&#39;, &#39;2019_NewFile26&#39;, &#39;2019_NewFile27&#39;, &#39;2019_NewFile28&#39;, &#39;2019_NewFile29&#39;, &#39;2019_NewFile3&#39;, &#39;2019_NewFile30&#39;, &#39;2019_NewFile31&#39;, &#39;2019_NewFile32&#39;, &#39;2019_NewFile33&#39;, &#39;2019_NewFile34&#39;, &#39;2019_NewFile35&#39;, &#39;2019_NewFile36&#39;, &#39;2019_NewFile37&#39;, &#39;2019_NewFile38&#39;, &#39;2019_NewFile39&#39;, &#39;2019_NewFile4&#39;, &#39;2019_NewFile40&#39;, &#39;2019_NewFile41&#39;, &#39;2019_NewFile42&#39;, &#39;2019_NewFile43&#39;, &#39;2019_NewFile44&#39;, &#39;2019_NewFile45&#39;, &#39;2019_NewFile46&#39;, &#39;2019_NewFile47&#39;, &#39;2019_NewFile48&#39;, &#39;2019_NewFile49&#39;, &#39;2019_NewFile5&#39;, &#39;2019_NewFile6&#39;, &#39;2019_NewFile7&#39;, &#39;2019_NewFile8&#39;, &#39;2019_NewFile9&#39;, &#39;2020_NewFile50&#39;, &#39;2020_NewFile51&#39;, &#39;2020_NewFile52&#39;, &#39;2020_NewFile53&#39;, &#39;2020_NewFile54&#39;, &#39;2020_NewFile55&#39;, &#39;2020_NewFile56&#39;, &#39;2020_NewFile57&#39;, &#39;2020_NewFile58&#39;, &#39;2020_NewFile59&#39;, &#39;2020_NewFile60&#39;, &#39;2020_NewFile61&#39;, &#39;2020_NewFile62&#39;, &#39;2020_NewFile63&#39;, &#39;2020_NewFile64&#39;, &#39;2020_NewFile65&#39;, &#39;2020_NewFile66&#39;, &#39;2020_NewFile67&#39;, &#39;2020_NewFile68&#39;, &#39;2020_NewFile69&#39;, &#39;2020_NewFile70&#39;, &#39;2020_NewFile71&#39;, &#39;2020_NewFile72&#39;, &#39;2020_NewFile73&#39;, &#39;2020_NewFile74&#39;, &#39;2020_NewFile75&#39;, &#39;2020_NewFile76&#39;, &#39;2020_NewFile77&#39;, &#39;2020_NewFile78&#39;, &#39;2020_NewFile79&#39;, &#39;2020_NewFile80&#39;, &#39;2020_NewFile81&#39;, &#39;2020_NewFile82&#39;, &#39;2020_NewFile83&#39;, &#39;2020_NewFile84&#39;, &#39;2020_NewFile85&#39;, &#39;2020_NewFile86&#39;, &#39;2020_NewFile87&#39;, &#39;2020_NewFile88&#39;, &#39;2020_NewFile89&#39;, &#39;2020_NewFile90&#39;, &#39;2020_NewFile91&#39;, &#39;2020_NewFile92&#39;, &#39;2020_NewFile93&#39;, &#39;2020_NewFile94&#39;, &#39;2020_NewFile95&#39;, &#39;2020_NewFile96&#39;, &#39;2020_NewFile97&#39;, &#39;2020_NewFile98&#39;, &#39;2020_NewFile99&#39;] . 세번째 방법 . file4=[x for x in flist if &#39;File&#39; in x] . 네번째 방법 . import glob glob.glob(&#39;2020_NewFile??&#39;) . [&#39;2020_NewFile50&#39;, &#39;2020_NewFile51&#39;, &#39;2020_NewFile52&#39;, &#39;2020_NewFile53&#39;, &#39;2020_NewFile54&#39;, &#39;2020_NewFile55&#39;, &#39;2020_NewFile56&#39;, &#39;2020_NewFile57&#39;, &#39;2020_NewFile58&#39;, &#39;2020_NewFile59&#39;, &#39;2020_NewFile60&#39;, &#39;2020_NewFile61&#39;, &#39;2020_NewFile62&#39;, &#39;2020_NewFile63&#39;, &#39;2020_NewFile64&#39;, &#39;2020_NewFile65&#39;, &#39;2020_NewFile66&#39;, &#39;2020_NewFile67&#39;, &#39;2020_NewFile68&#39;, &#39;2020_NewFile69&#39;, &#39;2020_NewFile70&#39;, &#39;2020_NewFile71&#39;, &#39;2020_NewFile72&#39;, &#39;2020_NewFile73&#39;, &#39;2020_NewFile74&#39;, &#39;2020_NewFile75&#39;, &#39;2020_NewFile76&#39;, &#39;2020_NewFile77&#39;, &#39;2020_NewFile78&#39;, &#39;2020_NewFile79&#39;, &#39;2020_NewFile80&#39;, &#39;2020_NewFile81&#39;, &#39;2020_NewFile82&#39;, &#39;2020_NewFile83&#39;, &#39;2020_NewFile84&#39;, &#39;2020_NewFile85&#39;, &#39;2020_NewFile86&#39;, &#39;2020_NewFile87&#39;, &#39;2020_NewFile88&#39;, &#39;2020_NewFile89&#39;, &#39;2020_NewFile90&#39;, &#39;2020_NewFile91&#39;, &#39;2020_NewFile92&#39;, &#39;2020_NewFile93&#39;, &#39;2020_NewFile94&#39;, &#39;2020_NewFile95&#39;, &#39;2020_NewFile96&#39;, &#39;2020_NewFile97&#39;, &#39;2020_NewFile98&#39;, &#39;2020_NewFile99&#39;] . 이런식으로 . file5=glob.glob(&#39;*File*&#39;) . . 이제 파일들을 각 년도 dir에 넣어보자 . import shutil . for f_curr in file5: f_name = f_curr[0:12] f_num = f_curr[12::] if int(f_num) &lt; 50: shutil.move(f_curr,&#39;. 2019_data&#39;) else: shutil.move(f_curr,&#39;. 2020_data&#39;) . dir에 파일들이 각각 들어갔음 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/27/intro.html",
            "relUrl": "/2021/12/27/intro.html",
            "date": " • Dec 27, 2021"
        }
        
    
  
    
        ,"post12": {
            "title": "2021/12/26/SUN",
            "content": "import numpy as np import pandas as pd from openpyxl import load_workbook . data = {&#39;Name&#39; : [&#39;S1&#39;,&#39;S2&#39;,&#39;S3&#39;], &#39;Age&#39; : [25,28,22], &#39;Score&#39; : np.array([95,80,75])} . data[&#39;Name&#39;] . [&#39;S1&#39;, &#39;S2&#39;, &#39;S3&#39;] . df=pd.DataFrame(data) df . Name Age Score . 0 S1 | 25 | 95 | . 1 S2 | 28 | 80 | . 2 S3 | 22 | 75 | . df=pd.DataFrame(data,index=[&#39;row1&#39;,&#39;row2&#39;,&#39;row3&#39;]) df . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . 리스트도 df로 변경 가능 | . data2=[[&#39;S1&#39;,25,95],[&#39;S2&#39;,28,80],[&#39;S3&#39;,22,75]] . df2=pd.DataFrame(data2,index=[&#39;row1&#39;,&#39;row2&#39;,&#39;row3&#39;],columns=[&#39;Name&#39;,&#39;Age&#39;,&#39;Score&#39;]) . df2 . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . . Subset Observation 부분 관찰 | . df . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . df[[&#39;Name&#39;]] . Name . row1 S1 | . row2 S2 | . row3 S3 | . df[&#39;Name&#39;] . row1 S1 row2 S2 row3 S3 Name: Name, dtype: object . df[[&#39;Name&#39;,&#39;Score&#39;]] # 이렇게 list안에 넣어줘야 함 . Name Score . row1 S1 | 95 | . row2 S2 | 80 | . row3 S3 | 75 | . # 이렇게 행은 추출할 수 없음 . 그렇다면 행 추출은? . df.loc[[&#39;row1&#39;]] . Name Age Score . row1 S1 | 25 | 95 | . df.loc[&#39;row1&#39;] . Name S1 Age 25 Score 95 Name: row1, dtype: object . df.loc[[&#39;row1&#39;,&#39;row2&#39;]] . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . df.loc[&#39;row1&#39;,&#39;Name&#39;] . &#39;S1&#39; . df[&#39;Name&#39;] # df.loc[&#39;Name&#39;] 이건 안 됨. 행만 가능 . row1 S1 row2 S2 row3 S3 Name: Name, dtype: object . 사용하고 싶다면 이렇게 사용 . df.loc[:,&#39;Name&#39;] . row1 S1 row2 S2 row3 S3 Name: Name, dtype: object . df.loc[:,[&#39;Score&#39;,&#39;Name&#39;]] . Score Name . row1 95 | S1 | . row2 80 | S2 | . row3 75 | S3 | . df.loc[:,&#39;Name&#39;:&#39;Age&#39;] # : 사용할 땐 중괄호 X . Name Age . row1 S1 | 25 | . row2 S2 | 28 | . row3 S3 | 22 | . df.iloc[0,0] . &#39;S1&#39; . df.iloc[2,0] . &#39;S3&#39; . df.iloc[:,[0,2]] . Name Score . row1 S1 | 95 | . row2 S2 | 80 | . row3 S3 | 75 | . df.iloc[::2,[0,2]] . Name Score . row1 S1 | 95 | . row3 S3 | 75 | . df.iloc[-1,:] . Name S3 Age 22 Score 75 Name: row3, dtype: object . df . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . df.iloc[-1::-1,:] . Name Age Score . row3 S3 | 22 | 75 | . row2 S2 | 28 | 80 | . row1 S1 | 25 | 95 | . df.head(2) . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . df.tail(1) . Name Age Score . row3 S3 | 22 | 75 | . df.info() # 열,행갯수, 칼럼 이름. data type 등등 . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Index: 3 entries, row1 to row3 Data columns (total 3 columns): # Column Non-Null Count Dtype -- -- 0 Name 3 non-null object 1 Age 3 non-null int64 2 Score 3 non-null int32 dtypes: int32(1), int64(1), object(1) memory usage: 192.0+ bytes . df.describe() # 통계적 수치들을 알 수 있음 . Age Score . count 3.0 | 3.000000 | . mean 25.0 | 83.333333 | . std 3.0 | 10.408330 | . min 22.0 | 75.000000 | . 25% 23.5 | 77.500000 | . 50% 25.0 | 80.000000 | . 75% 26.5 | 87.500000 | . max 28.0 | 95.000000 | . df2=df.copy() . df2 . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . df2.loc[&#39;row2&#39;,&#39;Score&#39;]=np.NaN . df2 . Name Age Score . row1 S1 | 25 | 95.0 | . row2 S2 | 28 | NaN | . row3 S3 | 22 | 75.0 | . df . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . deep copy . df2.nunique() . Name 3 Age 3 Score 2 dtype: int64 . Score에 NaN들어가 있어서 Score는 nunique가 2개임 . df2[&#39;Score&#39;].nunique() . 2 . df2[&#39;Score&#39;].value_counts() ## 각 값들의 갯수를 알 수 있음 . 95.0 1 75.0 1 Name: Score, dtype: int64 . df3=df2.copy() df3.loc[&#39;row3&#39;,&#39;Score&#39;]=df2.loc[&#39;row1&#39;,&#39;Score&#39;] . df3[&#39;Score&#39;].value_counts() . 95.0 2 Name: Score, dtype: int64 . 그냥 몇개 들어있는지도 알 수 있음 . df3[&#39;Score&#39;].count() . 2 . df3[&#39;Age&#39;].count() . 3 . df[&#39;Score&#39;].sum() . 250 . df.max() . Name S3 Age 28 Score 95 dtype: object . df[&#39;Score&#39;].std() . 10.408329997330664 . df.describe() . Age Score . count 3.0 | 3.000000 | . mean 25.0 | 83.333333 | . std 3.0 | 10.408330 | . min 22.0 | 75.000000 | . 25% 23.5 | 77.500000 | . 50% 25.0 | 80.000000 | . 75% 26.5 | 87.500000 | . max 28.0 | 95.000000 | . . df4=df.copy() . df4 . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . df . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . df4=df4.iloc[:,[0,2,1]] . df4 . Name Score Age . row1 S1 | 95 | 25 | . row2 S2 | 80 | 28 | . row3 S3 | 75 | 22 | . df의 열을 변경해서 df4에 저장 . data={ &#39;class&#39; : [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;C&#39;], &#39;name&#39; : [&#39;S1&#39;,&#39;S2&#39;,&#39;S3&#39;,&#39;S4&#39;,&#39;S5&#39;,&#39;S6&#39;,&#39;S7&#39;], &#39;age&#39; : [20,19,21,22,24,25,26], &#39;score&#39; : [90,95,75,80,70,85,90]} . df=pd.DataFrame(data) df . class name age score . 0 A | S1 | 20 | 90 | . 1 B | S2 | 19 | 95 | . 2 C | S3 | 21 | 75 | . 3 A | S4 | 22 | 80 | . 4 B | S5 | 24 | 70 | . 5 C | S6 | 25 | 85 | . 6 C | S7 | 26 | 90 | . df[&#39;score&#39;]&gt;=80 . 0 True 1 True 2 False 3 True 4 False 5 True 6 True Name: score, dtype: bool . df.loc[df[&#39;score&#39;]&gt;=80] . class name age score . 0 A | S1 | 20 | 90 | . 1 B | S2 | 19 | 95 | . 3 A | S4 | 22 | 80 | . 5 C | S6 | 25 | 85 | . 6 C | S7 | 26 | 90 | . df.loc[df[&#39;score&#39;]&gt;=80,[&#39;name&#39;,&#39;age&#39;]] . name age . 0 S1 | 20 | . 1 S2 | 19 | . 3 S4 | 22 | . 5 S6 | 25 | . 6 S7 | 26 | . df[df[&#39;score&#39;]&gt;=80] . class name age score . 0 A | S1 | 20 | 90 | . 1 B | S2 | 19 | 95 | . 3 A | S4 | 22 | 80 | . 5 C | S6 | 25 | 85 | . 6 C | S7 | 26 | 90 | . df[&#39;result&#39;]=&#39;NONE&#39; . df . class name age score result . 0 A | S1 | 20 | 90 | NONE | . 1 B | S2 | 19 | 95 | NONE | . 2 C | S3 | 21 | 75 | NONE | . 3 A | S4 | 22 | 80 | NONE | . 4 B | S5 | 24 | 70 | NONE | . 5 C | S6 | 25 | 85 | NONE | . 6 C | S7 | 26 | 90 | NONE | . df.loc[df[&#39;score&#39;]&gt;=80,&#39;result&#39;]=&#39;PASS&#39; . df.loc[df[&#39;score&#39;]&lt;80,&#39;result&#39;]=&#39;FAIL&#39; . df . class name age score result . 0 A | S1 | 20 | 90 | PASS | . 1 B | S2 | 19 | 95 | PASS | . 2 C | S3 | 21 | 75 | FAIL | . 3 A | S4 | 22 | 80 | PASS | . 4 B | S5 | 24 | 70 | FAIL | . 5 C | S6 | 25 | 85 | PASS | . 6 C | S7 | 26 | 90 | PASS | . idx = df[&#39;result&#39;] == &#39;PASS&#39; . df.loc[idx] . class name age score result . 0 A | S1 | 20 | 90 | PASS | . 1 B | S2 | 19 | 95 | PASS | . 3 A | S4 | 22 | 80 | PASS | . 5 C | S6 | 25 | 85 | PASS | . 6 C | S7 | 26 | 90 | PASS | . df_sorted=df.loc[idx].sort_values(&#39;score&#39;,ascending=False) . df_sorted . class name age score result . 1 B | S2 | 19 | 95 | PASS | . 0 A | S1 | 20 | 90 | PASS | . 6 C | S7 | 26 | 90 | PASS | . 5 C | S6 | 25 | 85 | PASS | . 3 A | S4 | 22 | 80 | PASS | . excel 파일 만들고 불러오기 . df_sorted.to_excel(&#39;data_sorted.xlsx&#39;,index=False) . df_import=pd.read_excel(&#39;data_sorted.xlsx&#39;) . df_import . class name age score result . 0 B | S2 | 19 | 95 | PASS | . 1 A | S1 | 20 | 90 | PASS | . 2 C | S7 | 26 | 90 | PASS | . 3 C | S6 | 25 | 85 | PASS | . 4 A | S4 | 22 | 80 | PASS | . df.groupby(by=&#39;class&#39;).mean() . age score . class . A 21.0 | 85.000000 | . B 21.5 | 82.500000 | . C 24.0 | 83.333333 | . df.groupby(by=&#39;class&#39;).std() . age score . class . A 1.414214 | 7.071068 | . B 3.535534 | 17.677670 | . C 2.645751 | 7.637626 | . plotting . df.plot.bar(&#39;name&#39;,&#39;score&#39;) . &lt;AxesSubplot:xlabel=&#39;name&#39;&gt; . null&#52376;&#47532;&#54644;&#48372;&#51088; . df.loc[[0,2],&#39;score&#39;]=np.NaN . df . class name age score result . 0 A | S1 | 20 | NaN | PASS | . 1 B | S2 | 19 | 95.0 | PASS | . 2 C | S3 | 21 | NaN | FAIL | . 3 A | S4 | 22 | 80.0 | PASS | . 4 B | S5 | 24 | 70.0 | FAIL | . 5 C | S6 | 25 | 85.0 | PASS | . 6 C | S7 | 26 | 90.0 | PASS | . NaN이 들어간 곳을 알려줌 . df.isnull() . class name age score result . 0 False | False | False | True | False | . 1 False | False | False | False | False | . 2 False | False | False | True | False | . 3 False | False | False | False | False | . 4 False | False | False | False | False | . 5 False | False | False | False | False | . 6 False | False | False | False | False | . df.dropna() # 데이터 없는 행은 다 날림 # 따라서 0행과 2행 날림 . class name age score result . 1 B | S2 | 19 | 95.0 | PASS | . 3 A | S4 | 22 | 80.0 | PASS | . 4 B | S5 | 24 | 70.0 | FAIL | . 5 C | S6 | 25 | 85.0 | PASS | . 6 C | S7 | 26 | 90.0 | PASS | . value=0 df.fillna(value) ## NaN값만 value로 채워줌 . class name age score result . 0 A | S1 | 20 | 0.0 | PASS | . 1 B | S2 | 19 | 95.0 | PASS | . 2 C | S3 | 21 | 0.0 | FAIL | . 3 A | S4 | 22 | 80.0 | PASS | . 4 B | S5 | 24 | 70.0 | FAIL | . 5 C | S6 | 25 | 85.0 | PASS | . 6 C | S7 | 26 | 90.0 | PASS | . df.replace(np.nan,value) . class name age score result . 0 A | S1 | 20 | 0.0 | PASS | . 1 B | S2 | 19 | 95.0 | PASS | . 2 C | S3 | 21 | 0.0 | FAIL | . 3 A | S4 | 22 | 80.0 | PASS | . 4 B | S5 | 24 | 70.0 | FAIL | . 5 C | S6 | 25 | 85.0 | PASS | . 6 C | S7 | 26 | 90.0 | PASS | . df.interpolate() . class name age score result . 0 A | S1 | 20 | NaN | PASS | . 1 B | S2 | 19 | 95.0 | PASS | . 2 C | S3 | 21 | 87.5 | FAIL | . 3 A | S4 | 22 | 80.0 | PASS | . 4 B | S5 | 24 | 70.0 | FAIL | . 5 C | S6 | 25 | 85.0 | PASS | . 6 C | S7 | 26 | 90.0 | PASS | . 이렇게 위 아래 값의 평균으로 채워주기도 하는데 위아래 둘다 있는 경우에만 사용가능하다 . def add_one(x): return x+1 . add_one(1001) . 1002 . df[&#39;age&#39;]=df[&#39;age&#39;].apply(add_one) . df . class name age score result . 0 A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | . 이렇게 df의 age를 변경해줄 수 있음 . df[&#39;score&#39;].apply(np.square) . 0 NaN 1 9025.0 2 NaN 3 6400.0 4 4900.0 5 7225.0 6 8100.0 Name: score, dtype: float64 . 이런 np.square도 사용가능 . . df . class name age score result . 0 A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | . df.filter(regex=&#39;[rn]&#39;) # n 또는 r이 들어간 columns 추출 . name score result . 0 S1 | NaN | PASS | . 1 S2 | 95.0 | PASS | . 2 S3 | NaN | FAIL | . 3 S4 | 80.0 | PASS | . 4 S5 | 70.0 | FAIL | . 5 S6 | 85.0 | PASS | . 6 S7 | 90.0 | PASS | . df_vertical=pd.concat([df,df]) df_vertical . class name age score result . 0 A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | . 0 A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | . df_horizontal=pd.concat([df,df],axis=1) df_horizontal . class name age score result class name age score result . 0 A | S1 | 21 | NaN | PASS | A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | C | S7 | 27 | 90.0 | PASS | . . df.to_csv(&#39;data_text.txt&#39;,sep=&#39; t&#39;,index=False) # txt파일로 변환할 때 어떻게 구분해서 타이핑해넣을 것인가 # sep= t,여기선 지금 탭으로 구분지었음 . pd.read_csv(&#39;data_text.txt&#39;,delimiter=&#39; t&#39;) . class name age score result . 0 A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | . delimiter로 txt파일이 어떻게 이루어져 있나 알려줘야함 . . from sympy import symbols . x=symbols(&#39;x&#39;) . type(x) . sympy.core.symbol.Symbol . 2*x . $ displaystyle 2 x$ 즉 x자체가 symbol로 들어갔음 . expr=2*x . expr.subs(x,3) . $ displaystyle 6$ 미분해보자 . f=x**3 . from sympy import diff . df1=diff(f,x) . df1 . $ displaystyle 3 x^{2}$ df2=diff(df1,x) . df2 . $ displaystyle 6 x$ . from sympy import sin . f=sin(x) . df1=diff(f,x) . df1 . $ displaystyle cos{ left(x right)}$ . from sympy import integrate . integrate(f,(x,0,2*3.14)) . $ displaystyle 5.07308662478501 cdot 10^{-6}$ 0에 가깝게 나옴 . integrate(f,(x,0,3.14)) . $ displaystyle 1.99999873172754$ . from sympy import limit . limit(sin(x)/x,x,0) . $ displaystyle 1$ . import matplotlib.pyplot as plt from scipy import interpolate . x=np.array([1,2,3,4,5]) y=np.array([1,0.8,0.4,0.3,0.2]) . plt.plot(x,y,&#39;*&#39;) . [&lt;matplotlib.lines.Line2D at 0x1ee100b36a0&gt;] . f_lin=interpolate.interp1d(x,y) . x_new = np.arange(1,5,0.1) . y_new = f_lin(x_new) . fig,ax=plt.subplots() ax.plot(x,y,&#39;o&#39;,label=&#39;Data&#39;) ax.plot(x_new,y_new,label=&#39;linear&#39;) ax.legend() . &lt;matplotlib.legend.Legend at 0x1ee1015b8b0&gt; . 선형 보간됨을 알 수 있다. . . tck=interpolate.splrep(x,y,s=0) y_spl=interpolate.splev(x_new,tck,der=0) fig,ax=plt.subplots() ax.plot(x,y,&#39;o&#39;,label=&#39;Data&#39;) ax.plot(x_new,y_new,label=&#39;linear&#39;) ax.plot(x_new,y_spl,label=&#39;spline&#39;) ax.legend() . &lt;matplotlib.legend.Legend at 0x1ee10244d00&gt; . 원형 보간 추가 . . open cv . import cv2 as cv . im=cv.imread(&#39;KakaoTalk_20211210_090822964.png&#39;) . im.shape . (1080, 1920, 3) . type(im) . numpy.ndarray . BGR &#54540;&#46991; . plt.figure() plt.imshow(im) plt.title(&#39;Original&#39;) . Text(0.5, 1.0, &#39;Original&#39;) . BGR로 들어오기 때문에 RGB로 바꿔 줄 필요가 있음 . rgb=cv.cvtColor(im,cv.COLOR_BGR2RGB) plt.figure() plt.imshow(rgb) plt.title(&#39;RGB&#39;) . Text(0.5, 1.0, &#39;RGB&#39;) . GRAY=cv.cvtColor(im,cv.COLOR_BGR2GRAY) plt.figure() plt.imshow(GRAY,cmap=&#39;gray&#39;) plt.title(&#39;GRAY&#39;) . Text(0.5, 1.0, &#39;GRAY&#39;) . cmap=gray 처리 꼭 해줘야 함 | . blur=cv.blur(im,(100,100)) blur=cv.cvtColor(blur,cv.COLOR_BGR2RGB) plt.subplot(121) # 가로줄 한개, 세로줄 두개, 첫번째에 놓겠다 plt.imshow(rgb) plt.title(&#39;RGB&#39;) plt.subplot(122) # 가로줄 한개, 세로줄 두개, 두번째에 놓겠다 plt.imshow(blur) plt.title(&#39;blur&#39;) . Text(0.5, 1.0, &#39;blur&#39;) . . edges=cv.Canny(GRAY,0,100) plt.subplot(121) # 가로줄 한개, 세로줄 두개, 첫번째에 놓겠다 plt.imshow(GRAY,cmap=&#39;gray&#39;) plt.title(&#39;GRAY&#39;) plt.subplot(122) # 가로줄 한개, 세로줄 두개, 두번째에 놓겠다 plt.imshow(edges) plt.title(&#39;edge detection&#39;) . Text(0.5, 1.0, &#39;edge detection&#39;) . 머신러닝과 연관하여 비디오 영상의 움직이는 사물을 찾거나 번호판 또는 숫자 인식 여러 분야에서 활용이 가능하다 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/26/intro.html",
            "relUrl": "/2021/12/26/intro.html",
            "date": " • Dec 26, 2021"
        }
        
    
  
    
        ,"post13": {
            "title": "2021/12/25/SAT",
            "content": "import numpy as np . a=np.array([100.,101.,102.,103.]) . a.shape # 1차원 4개 요소 . (4,) . a.ndim . 1 . a[0] . 100.0 . a[1] . 101.0 . a[-1] . 103.0 . a[[1,3]] . array([101., 103.]) . a[-3:-1] . array([101., 102.]) . a[1:4:1] . array([101., 102., 103.]) . a[1:4] . array([101., 102., 103.]) . a[1:4:2] . array([101., 103.]) . a[:] . array([100., 101., 102., 103.]) . a[::2] . array([100., 102.]) . a[::-2] . array([103., 101.]) . a2=np.array([[11,12],[23 ,34]]) . a2 . array([[11, 12], [23, 34]]) . a2.shape . (2, 2) . a2.ndim . 2 . a2[0][1] # 겉차원 -&gt; 속차원 . 12 . a2[0,1] . 12 . a2[[0,1]] . array([[11, 12], [23, 34]]) . a2[:] . array([[11, 12], [23, 34]]) . a2[:,:] . array([[11, 12], [23, 34]]) . . 행렬처럼 생각하자 . a2[0,:] . array([11, 12]) . a2[1,:] . array([23, 34]) . b=a2[:,0] . b . array([11, 23]) . b.shape . (2,) . b.ndim . 1 . . b_=b[:,np.newaxis] . b_ . array([[11], [23]]) . b_.shape . (2, 1) . b_.ndim . 2 . 또는 . b.shape=(1,2) . b . array([[11, 23]]) . a3=np.array([[[ 1,2],[3,4 ],[5,6 ],[7,8 ],[9,10]]]) . a3 . array([[[ 1, 2], [ 3, 4], [ 5, 6], [ 7, 8], [ 9, 10]]]) . a3[0,0,1] . 2 . a3.shape # 큰 덩어리 1개, 작은 덩어리 5개, 그 안에 요소 2개씩 . (1, 5, 2) . a3.ndim #3차원 . 3 . a3[0,1,1] . 4 . # 당연히 없을 것 # 큰 덩어리는 하나임 . x=np.array([12,34,14,0]) . idx=np.where(x==34) . idx # 0번째 아니고 1번째 있다 . (array([1], dtype=int64),) . x[idx] . array([34]) . idx=(x==14) . idx . array([False, False, True, False]) . x[idx] . array([14]) . x[np.where(x==12)] . array([12]) . np.nonzero(x) . (array([0, 1, 2], dtype=int64),) . x[np.nonzero(x)] . array([12, 34, 14]) . x==0 . array([False, False, False, True]) . np.nonzero(x==14) . (array([2], dtype=int64),) . np.nonzero(x==0) . (array([3], dtype=int64),) . x[np.nonzero(x==0)] . array([0]) . x[np.nonzero(x==34)] . array([34]) . image processing시, 논리연산을 통한 idexing 중요 . image=np.array([[255,0,255], [255,0,255], [255,0,255]]) . image.shape # 2차원, 큰덩어리 세개, 그 안에 요소 3개 . (3, 3) . idx=np.where(image==255) . idx . (array([0, 0, 1, 1, 2, 2], dtype=int64), array([0, 2, 0, 2, 0, 2], dtype=int64)) . (0,0)(0,2)(1,0)(1,2)(2,2) 자리에 255가 있다 . image[idx]=0 . image . array([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) . 이런식으로 논리연산을 통한 indexing으로 다 검정색을 만들어버림 . . a=np.array([[10,20],[30,40]]) b=np.array([[1,2],[3,4]]) . a . array([[10, 20], [30, 40]]) . b . array([[1, 2], [3, 4]]) . a * b . array([[ 10, 40], [ 90, 160]]) . a @ b . array([[ 70, 100], [150, 220]]) . a.dot(b) #행렬 연산 . array([[ 70, 100], [150, 220]]) . a=np.zeros((3,3)) . a . array([[0., 0., 0.], [0., 0., 0.], [0., 0., 0.]]) . b=np.ones((3,3)) . b . array([[1., 1., 1.], [1., 1., 1.], [1., 1., 1.]]) . c=np.trace(b) . c . 3.0 . $x@a=y$ 에서 a행렬 구해보기 . x=np.array([[1,-3],[2,4]]) y=np.array([[1],[3]]) . x_inverse=np.linalg.inv(x) . a=x_inverse@y . a . array([[1.3], [0.1]]) . 혹은 . a=np.linalg.solve(x,y) . a . array([[1.3], [0.1]]) . 그 외에도 고유벡터, 고유값, 특이값 분해도 np에서 함수사용할 수 있다 . a=np.zeros((5,5)) np.fill_diagonal(a,12) . a #대각원소만 12로 변경 . array([[12., 0., 0., 0., 0.], [ 0., 12., 0., 0., 0.], [ 0., 0., 12., 0., 0.], [ 0., 0., 0., 12., 0.], [ 0., 0., 0., 0., 12.]]) . a=np.array([[1,2,3],[3,4,4],[5,43,6]]) . b=np.array([[1],[2],[3]]) . b . array([[1], [2], [3]]) . b=b.repeat(3,axis=1) . b . array([[1, 1, 1], [2, 2, 2], [3, 3, 3]]) . 이제 원소대 원소 곱해주면 된다 | . c=a*b . c . array([[ 1, 2, 3], [ 6, 8, 8], [ 15, 129, 18]]) . broadcasting :size알아서 처리해주는 기능 . a . array([[ 1, 2, 3], [ 3, 4, 4], [ 5, 43, 6]]) . b=np.array([[1],[2],[3]]) . a*b . array([[ 1, 2, 3], [ 6, 8, 8], [ 15, 129, 18]]) . 또는 . def f(x,y): return x*y . b=np.fromfunction(f,(3,3),dtype=int) . b #이건 그냥 임의의 행렬만 만들어준 것 . array([[0, 0, 0], [0, 1, 2], [0, 2, 4]]) . . a=np.array([10,20,30,40,50]) b=np.array([30,50]) . np.setdiff1d(a,b) . array([10, 20, 40]) . . a=np.random.randint(100) . a# 0부터99까지에서 하나 random으로 get . 13 . . import matplotlib.pyplot as plt . y=np.array([10,20,30]) . plt.plot(y) . [&lt;matplotlib.lines.Line2D at 0x23556aafb50&gt;] . x=np.array([123,413,555]) . plt.plot(x,y,&#39;r--.&#39;) #data가 들어간 곳에 dot으로 표시 . [&lt;matplotlib.lines.Line2D at 0x2355725b730&gt;] . plt.plot(x,y,&#39;b-o&#39;,label=&#39;fuck&#39;) plt.ylabel(&#39;sd&#39;) plt.xlabel(&#39;SD&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x2355757f760&gt; . hf=plt.figure() # 도화지 ha = hf.add_axes([0,0,1,1]) # 0,0자리에 1,1크기만큼 ha.plot(x,y) . [&lt;matplotlib.lines.Line2D at 0x23558ad2190&gt;] . aa,bb=plt.subplots() hong,=bb.plot(x,y) # 이렇게 aa,bb는 임의로 지명 가능 . 위에 있는 그래프를 update해보자 . a_new=np.array([200,331,335]) b_new=np.array([10,50,10]) hong.set_data(a_new,b_new) aa . 그런데 주의해야 할 점에 애초에 aa라는 도화지에 정해진 축이 있기 때문에 그 축에서 너무 멀어지는 값들을 넣어주면 aa라는 도화지에 보이지 않을 수 있음 . PLUS=1.5 a_new=np.array([200,331,335]) b_new=np.array([10,50,10]) hong.set_data(a_new,PLUS*b_new) aa . 그래프가 올라간 것을 확인할 수 있음 . a=np.linspace(0,2,100) y1=0.5*a y2=0.5*a**2 y3=0.5*a**3 plt.plot(a,y1,label=&#39;1D&#39;) plt.plot(a,y2,label=&#39;2D&#39;) plt.plot(a,y3,label=&#39;3D&#39;) plt.legend() plt.xlabel(&#39;X&#39;) plt.ylabel(&#39;Y&#39;) plt.title(&#39;GRAPH&#39;) . Text(0.5, 1.0, &#39;GRAPH&#39;) . fig,ax=plt.subplots() ax1,=ax.plot(a,y1) # 여기서 ax1 후에 comma입력해주는 이유가 속성을 나중에 다 받아오기 위해서 ax2,=ax.plot(a,y2) ax3,=ax.plot(a,y3) ax.set_xlabel(&#39;X&#39;) # plt가 아닐 땐 set을 입력해줘야 함 ax.set_ylabel(&#39;Y&#39;) ax1.set_label(&#39;1&#39;) ax2.set_label(&#39;2&#39;) ax3.set_label(&#39;3&#39;) ax.legend() . &lt;matplotlib.legend.Legend at 0x23558d352b0&gt; . ax1.set_color(&#39;k&#39;) ax2.set_color(&#39;b&#39;) ax3.set_color(&#39;r&#39;) ax.grid() ax.legend() fig . decay sin . t=np.linspace(0,100,1000) tau= 60 y=np.sin(t)*np.exp(-t/tau) plt.plot(t,y,label=&#39;Decay Oscillating Response&#39;) plt.ylabel(&#39;y[m]&#39;) plt.xlabel(&#39;t[s]&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x23558d84850&gt; . Euler eq . t=np.linspace(0,1,100) f= 1 # 주파수 y_euler=np.exp(1j*2*np.pi**f*t) y_cos = np.real(y_euler) y_sin=np.imag(y_euler) fig,ax=plt.subplots() ax.plot(t,y_cos,&#39;-r&#39;,label=&#39;cos&#39;) ax.plot(t,y_sin,&#39;--b&#39;,label=&#39;sin&#39;) ax.grid() ax.legend() . &lt;matplotlib.legend.Legend at 0x23557571610&gt; . fig,ax=plt.subplots(2,) ax[0].plot(t,y_cos,&#39;-r&#39;,label=&#39;cos&#39;) ax[1].plot(t,y_sin,&#39;--b&#39;,label=&#39;sin&#39;) ax[0].grid() ax[0].legend() ax[1].grid() ax[1].legend() . &lt;matplotlib.legend.Legend at 0x23558ec5cd0&gt; . Histogram . data=np.random.randn(500000) plt.hist(data,100,density=True) # 100개의 막대로 나누겠다, 확률밀도함수로 그리겠다 x=np.linspace(-4,4,100) sigma=1 mean=0 nd=(1/(sigma*np.sqrt(2*np.pi)))*np.exp(-0.5*((x-mean)/sigma)**2) plt.plot(x,nd,&#39;r&#39;,label=&#39;Std Normal Dist&#39;) plt.ylabel(&#39;PSD&#39;) plt.xlabel(&#39;X&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x23559322970&gt; . 3D plot . x=np.linspace(0,2*np.pi,10) y=np.linspace(0,2*np.pi,10) grid_x,grid_y=np.meshgrid(x,y) # 1차원 array를 통해 2차원 grid를 만들어줌 z=np.sin(grid_x)*np.sin(grid_y) fig=plt.figure() ax=fig.gca(projection=&#39;3d&#39;) # Get Current Axis=gca ax.plot_surface(grid_x,grid_y,z,cmap=&#39;jet&#39;) ax.set_xlabel(&#39;x&#39;) ax.set_ylabel(&#39;y&#39;) ax.set_zlabel(&#39;z&#39;) . C: Users ehfus AppData Local Temp/ipykernel_18580/1177705184.py:6: MatplotlibDeprecationWarning: Calling gca() with keyword arguments was deprecated in Matplotlib 3.4. Starting two minor releases later, gca() will take no keyword arguments. The gca() function should only be used to get the current axes, or if no axes exist, create new axes with default keyword arguments. To create a new axes with non-default arguments, use plt.axes() or plt.subplot(). ax=fig.gca(projection=&#39;3d&#39;) # Get Current Axis=gca . Text(0.5, 0, &#39;z&#39;) . Animation . # x=np.array([1,2,3,4,5]) # y=np.array([1,1,1,1,1]) # ax1, = ax.plot(x,y) # ax.set_ybound([0,11]) # for i in range(0,11,1): # ax1.set_ydata(i*y) # plt.pause(0.3) # # 원래는 animation기능으로 움직여야 함 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/25/intro.html",
            "relUrl": "/2021/12/25/intro.html",
            "date": " • Dec 25, 2021"
        }
        
    
  
    
        ,"post14": {
            "title": "2022/12/24/FRI",
            "content": "import numpy as np . np.linspace(0,4,5) # 0부터 4까지 다섯개로 쪼갠다 . array([0., 1., 2., 3., 4.]) . np.arange(10) # 0부터 10개의 숫자 . array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) . a=np.array([10,20,3]) . a.shape # 1차원 행렬에 방 세개 . (3,) . a.ndim # 1차원 . 1 . a.dtype # array에 들어간 숫자들이 어떤 형식으로? . dtype(&#39;int32&#39;) . a.size # 몇개 들어가 있니 . 3 . type(a) #몇차원이고 될 수 있음, nd=ndimension . numpy.ndarray . np.array도 sequence 타입 =&gt; index,slicing가능 | . a[2] . 3 . a[2]=30.8 . a . array([10, 20, 30]) . 소수점 날라가고 30으로 저장됨 . a.dtype . dtype(&#39;int32&#39;) . a=a.astype(&#39;float64&#39;) . a[2]=30.865 . a . array([10. , 20. , 30.865]) . a.dtype . dtype(&#39;float64&#39;) . 소수점도 가능한 자료형으로 변경해줬음 | . b=np.array([10.,20.,30.]) . b.dtype . dtype(&#39;float64&#39;) . 애초에 이렇게 dot을 지정해주고 들어가면 float으로 활용가능 | . c=np.array([10.2,20.3,50.58],&#39;int32&#39;) . c . array([10, 20, 50]) . 이렇게 &#39;int32&#39;로 지정해줄 수 있음 | . x=np.array([7,9,11]) y=x/2 . y . array([3.5, 4.5, 5.5]) . x.dtype . dtype(&#39;int32&#39;) . y.dtype . dtype(&#39;float64&#39;) . x가 정수로 시작했어도 y는 divide를 사용하고 있기에 알아서 np에서 float64로 지정함 | . int32 $vs$ int64 . x=np.array([0]) . x[0]=2147483647 . x . array([2147483647]) . x[0]=x[0]+1 . C: Users ehfus AppData Local Temp/ipykernel_11580/4237261130.py:1: RuntimeWarning: overflow encountered in long_scalars x[0]=x[0]+1 . 2147483647은 int32에서 수용할 수 있는 최대의 숫자임, 따라서 여기서 1만 더해주더라도 수용하지 못하게 됨 | . x=np.array([0],&#39;int64&#39;) . x[0]=2147483647 . x[0]+1 . 2147483648 . dtype을 int64로 바꿨기 때문에 int32에서 최대였던 것보다 더 수용할 수 있게 됨 | . a=np.array([10,&#39;abc&#39;,20]) # 꼭 list형태로 줘야 함 . a.dtype #섞여있음 . dtype(&#39;&lt;U11&#39;) . . 섞여있으면 이런 연산은 불가 | . a=np.array([[10,20,30],[40,50,60]]) . a # 2차원 . array([[10, 20, 30], [40, 50, 60]]) . a.shape # 2x3행렬로 해석해도 될듯 . (2, 3) . a.size . 6 . a=np.array([[10,20,30],[40,50,60],[5,6,8]]) . a . array([[10, 20, 30], [40, 50, 60], [ 5, 6, 8]]) . a.size . 9 . a=np.array([[10,20,30], [40,50,60], [55,54,88] ,[112,123,41]]) . a . array([[ 10, 20, 30], [ 40, 50, 60], [ 55, 54, 88], [112, 123, 41]]) . a.ndim . 2 . a.shape . (4, 3) . a=np.array([10+10j,10+60j]) . a . array([10.+10.j, 10.+60.j]) . a=np.array([10,20],&#39;complex&#39;) . a . array([10.+0.j, 20.+0.j]) . . a=np.array([10,20]) . b=np.matrix([10,20]) . a.ndim . 1 . b.ndim . 2 . # error = &gt; matrix는 2차원만 가능 . a=np.array([10,20,30]) . a=np.insert(a,2,5) # a라는 np.array의 2번째 인덱스에 5를 넣어라 . a . array([10, 20, 5, 30]) . a=np.delete(a,2) . a # 두번째 인덱스 삭제 . array([10, 20, 30]) . a=np.array([1,2,3]) . a=np.arange(3) . a # 0부터 시작해서 숫자 3개를 채워줌 . array([0, 1, 2]) . a=np.zeros(2) . a . array([0., 0.]) . a=np.zeros((2,3)) . a . array([[0., 0., 0.], [0., 0., 0.]]) . a=np.ones((2,3)) . a . array([[1., 1., 1.], [1., 1., 1.]]) . a=np.logspace(0,5,4) # log scale로! . a . array([1.00000000e+00, 4.64158883e+01, 2.15443469e+03, 1.00000000e+05]) . . a=np.array([10,20,30]) b=np.array([1,2,3]) . a+b . array([11, 22, 33]) . a-b . array([ 9, 18, 27]) . b-a . array([ -9, -18, -27]) . a*b . array([10, 40, 90]) . a/b . array([10., 10., 10.]) . c=a**2 . c . array([100, 400, 900], dtype=int32) . idx=a&lt;20 . idx . array([ True, False, False]) . a=a+1 . a . array([11, 21, 31]) . a+=1 . a . array([12, 22, 32]) . a*=2 . a . array([24, 44, 64]) . a=a*2 . a . array([ 48, 88, 128]) . a=np.array([10,50,9]) # int b=np.array([50.,5.,8.]) #float . a=a+b . a . array([60., 55., 17.]) . # a에b를 더해서 a를 업데이트 하는 건 자료형이 달라서 안 된다고 함 # 되게 하려면 자료형을 맞춰주면 됨 . c=a+b # 이건 됨 . c . array([110., 60., 25.]) . . a=np.array([10,50,9]) b=np.array([50,5,8]) . np.add(a,b) . array([60, 55, 17]) . np.subtract(a,b) . array([-40, 45, 1]) . np.divide(a,b) . array([ 0.2 , 10. , 1.125]) . np.multiply(a,b) . array([500, 250, 72]) . np.divmod(a,b) # 몫과 나머지 . (array([[0, 2, 0], [0, 0, 0]], dtype=int32), array([[ 0, 0, 1], [10, 0, 1]], dtype=int32)) . np.exp(b) . array([5.18470553e+21, 1.48413159e+02, 2.98095799e+03]) . np.sqrt(a) . array([[0. , 3.16227766, 1. ], [3.16227766, 0. , 1. ]]) . . a=np.array([10,20,3]) . np.mean(a) . 11.0 . a.mean() . 11.0 . np.average(a) . 11.0 . np.average(a,weights=[1,1,1]) . 11.0 . np.average(a,weights=[1,1,0]) . 15.0 . np.average(a,weights=[0,1,1]) . 11.5 . np.median(a) . 10.0 . np.cumsum(a) # 앞에 있는 숫자들을 더해주는 것 . array([10, 30, 33], dtype=int32) . np.cov(a) . array(73.) . np.std(a) . 6.97614984548545 . np.var(a) . 48.666666666666664 . x=np.array([10,20,30]) . x.sum() . 60 . x=np.array([10.,40.,20.,5.,15.]) . x.min() . 5.0 . x.max() . 40.0 . x.argmin() # index 0에 최솟값이 존재함 . 3 . x_min,x_min_idx=x.min(),x.argmin() . # 최솟값과 최댓값의 차이 x.ptp() . 35.0 . y=np.sort(x) . y . array([ 5., 10., 15., 20., 40.]) . idx = np.argsort(x) . idx . array([3, 0, 4, 2, 1], dtype=int64) . y . array([ 5., 10., 15., 20., 40.]) . sort된 값들이 원래 어디에 위치해 있었는지 | . x[idx] . array([ 5., 10., 15., 20., 40.]) . y=x[idx] . y . array([ 5., 10., 15., 20., 40.]) . a=np.array([20,10,30]) b=np.array([-5,25]) . np.searchsorted(a,b) . array([0, 2], dtype=int64) . d=np.arange(1,7,1) . d . array([1, 2, 3, 4, 5, 6]) . d.shape . (6,) . d.reshape(2,3) . array([[1, 2, 3], [4, 5, 6]]) . d.reshape(-1,1) . array([[1], [2], [3], [4], [5], [6]]) . d.reshape(-1,2) . array([[1, 2], [3, 4], [5, 6]]) . d.reshape(1,-1) . array([[1, 2, 3, 4, 5, 6]]) . d.reshape(2,-1) . array([[1, 2, 3], [4, 5, 6]]) . d 자체를 바꿔주는 건 아님 | . e=d.reshape(2,3) . f=np.linspace(1,10,10) . f . array([ 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.]) . g=np.linspace(1,10,10).reshape(2,5) . g . array([[ 1., 2., 3., 4., 5.], [ 6., 7., 8., 9., 10.]]) . a=np.array([[1,2],[3,4]])#2차원 . a . array([[1, 2], [3, 4]]) . np.repeat(a,2) . array([1, 1, 2, 2, 3, 3, 4, 4]) . np.repeat(a,2,axis=0) . array([[1, 2], [1, 2], [3, 4], [3, 4]]) . np.repeat(a,2,axis=1) . array([[1, 1, 2, 2], [3, 3, 4, 4]]) . np.repeat(a,[1,2],axis=0) . array([[1, 2], [3, 4], [3, 4]]) . np.repeat(a,[3,1],axis=0) . array([[1, 2], [1, 2], [1, 2], [3, 4]]) . np.repeat(a,[1,2],axis=1) . array([[1, 2, 2], [3, 4, 4]]) . np.repeat(a,[3,1],axis=1) . array([[1, 1, 1, 2], [3, 3, 3, 4]]) . a=np.array([[1],[2],[3]]) b=np.array([[4],[5],[6]]) . a.shape . (3, 1) . b.shape . (3, 1) . 둘다 차원은 2차원 | . np.concatenate((a,b),axis=0) # array 두개 연결 . array([[1], [2], [3], [4], [5], [6]]) . np.concatenate((a,b),axis=1) . array([[1, 4], [2, 5], [3, 6]]) . (a,b)이렇게 tuple 형태로 입력해줘야 함 | . a=np.array([10,20,30]) b=np.array([40,50,60]) . np.vstack((a,b)) . array([[10, 20, 30], [40, 50, 60]]) . np.hstack((a,b)) . array([10, 20, 30, 40, 50, 60]) . a=np.array([[10,20,30],[40,50,60]]) . a . array([[10, 20, 30], [40, 50, 60]]) . # 오류 발생, 왜? 세로 방향으로 2개로 나눌 수가 없어서 . a=np.hsplit(a,3) . a . [array([[10], [40]]), array([[20], [50]]), array([[30], [60]])] . a[0] . array([[10], [40]]) . a=np.array([[10,20,30],[40,50,60]]) . np.vsplit(a,2) . [array([[10, 20, 30]]), array([[40, 50, 60]])] . 이것또한 list로 저장 됨 . 어레이를 조각조각내서 리스트 안에 넣어줬기 때문에 . 그 조각을 살펴보면 np.array 형태이고 . 그 조각들을 list안에 넣어준 것 . a=np.array([[10,20,30],[40,50,60]]) . a . array([[10, 20, 30], [40, 50, 60]]) . a.transpose() . array([[10, 40], [20, 50], [30, 60]]) . 2차원의 array를 1차원의 array로 변경해보자 | . a . array([[10, 20, 30], [40, 50, 60]]) . a.ravel() . array([10, 20, 30, 40, 50, 60]) . a.reshape(-1) . array([10, 20, 30, 40, 50, 60]) . a.ravel(order=&#39;C&#39;) . array([10, 20, 30, 40, 50, 60]) . a.ravel(order=&#39;F&#39;) . array([10, 40, 20, 50, 30, 60]) . a.flatten() . array([10, 20, 30, 40, 50, 60]) . a=np.array([[1],[2],[3]]) # 2차원 형태로 넣어줌 . a . array([[1], [2], [3]]) . a_=np.array([[1,2,3]]) . a_ . array([[1, 2, 3]]) . a__=np.array([1,2,3]) # 1차원 형태로 넣어줌 . a__ . array([1, 2, 3]) . &#52264;&#51060;&#51216; . a_[0] . array([1, 2, 3]) . a[0][0] . 1 . . a.ndim . 2 . a.shape . (3, 1) . a_.shape . (1, 3) . a__.shape . (3,) . a . array([[1], [2], [3]]) . 2차원에서 1차원으로 줄이자 . b=a.squeeze() . b . array([1, 2, 3]) . b.ndim . 1 . b.shape . (3,) . a=np.array([[[1,2]],[[3,4]],[[5,6]]]) . a . array([[[1, 2]], [[3, 4]], [[5, 6]]]) . a.shape . (3, 1, 2) . a.ndim . 3 . b=a.squeeze() . b . array([[1, 2], [3, 4], [5, 6]]) . b.shape . (3, 2) . a=np.array([1,2,3]) b=np.array([4,5,6]) . a . array([1, 2, 3]) . a.shape . (3,) . a_=a[:,np.newaxis] b_=b[:,np.newaxis] # 차원 하나 추가 . a_.shape . (3, 1) . a_ . array([[1], [2], [3]]) . np.concatenate((a_,b_),axis=0) . array([[1], [2], [3], [4], [5], [6]]) . np.concatenate((a_,b_),axis=1) . array([[1, 4], [2, 5], [3, 6]]) . np.vstack((a,b)) . array([[1, 2, 3], [4, 5, 6]]) . np.vstack((a,b)).transpose() . array([[1, 4], [2, 5], [3, 6]]) . np.hstack((a,b)).reshape((2,3)).transpose() . array([[1, 4], [2, 5], [3, 6]]) . shallow copy &amp; deep copy . a=np.array([10,20,30]) . b=a . b . array([10, 20, 30]) . b[0]=909 . b . array([909, 20, 30]) . a . array([909, 20, 30]) . b is a . True . 즉 같은 메모리에 이름만 다르게 저장된 것 | . a=np.array([1,2,3,4]) . b=a.view() . b . array([1, 2, 3, 4]) . b is a . False . 일단 메모리는 달라졌음 | . b[0]=123123 . a . array([123123, 2, 3, 4]) . b . array([123123, 2, 3, 4]) . shallow copy를 했음에도 같이 업데이트 되어버림 | . b.shape=(2,2) . b . array([[123123, 2], [ 3, 4]]) . b[0][1]=111 . b . array([[123123, 111], [ 3, 4]]) . a . array([123123, 111, 3, 4]) . 즉 shallow copy란 메모리 상에 data는 같이 공유하지만 array의 shape은 공유 X | . 그렇다면 deep copy? | . a=np.array([10,20,30,40]) . b=a.copy() . b[0]=8999 . a . array([10, 20, 30, 40]) . b . array([8999, 20, 30, 40]) . a is b . False . b.base is a . False . 즉 b만의 온전한 데이터를 만들 수 있음 . . a=np.array([55,0,12,3,4]) . # 여기선 0, 즉 FALSE값이 들어있기 때문에 FALSE로 나올 것 a.all() . False . a.any() . True . a.nonzero() . (array([0, 2, 3, 4], dtype=int64),) . np.where(a&gt;0) . (array([0, 2, 3, 4], dtype=int64),) . np.where(a==0) . (array([1], dtype=int64),) . np.where(a!=0) . (array([0, 2, 3, 4], dtype=int64),) .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/24/intro.html",
            "relUrl": "/2021/12/24/intro.html",
            "date": " • Dec 24, 2021"
        }
        
    
  
    
        ,"post15": {
            "title": "2022/12/23/THU",
            "content": "s=&#39;&#39;&#39;python n n&#39;&#39;&#39; # 이렇게 해도 되고 직접 enter로 다음 줄로 넘겨도 됨 . s . &#39;python n n&#39; . print(s) . python . &#39;&#39;&#39; =&gt; 긴 str배정시에 사용 | . s=&#39;python&#39; . s.capitalize() . &#39;Python&#39; . s.find(&#39;y&#39;) . 1 . s.find(&#39;a&#39;) . -1 . s.index(&#39;t&#39;) . 2 . index 또는 find 사용시 단어가 중복되면 처음 거 기준 출력 | . a=&#39;pyathaon&#39; . a.find(&#39;a&#39;) . 2 . a.index(&#39;a&#39;) . 2 . a.isalpha() . True . s=&#39;asd342&#39; . s.isalnum() . True . a=&#39;python 3&#39; . a.isalnum() . False . s=&#39;123&#39; . # 십진법! s.isdecimal() . True . s=&#39;223311.3&#39; . s.isdecimal() . False . s.isdigit() . False . s.isnumeric() . False . s=&#39;123123123&#39; . s.isdecimal() . True . a=&#39;2034&#39; . a.isdigit() . True . a=&#39;3 u00B3&#39; . a . &#39;3³&#39; . a.isdecimal() . False . a.isdigit() . True . a.isnumeric() . True . a=&#39; u00BC&#39; . a . &#39;¼&#39; . a.isdecimal() . False . a.isdigit() . False . a.isnumeric() . True . a=&#39;Python&#39; . a.islower() . False . a.isupper() . False . 중요 | . a=&#39;PythonP&#39; . a.replace(&#39;P&#39;,&#39;Q&#39;) . &#39;QythonQ&#39; . 중요 | . a=&#39;I like python&#39; . # space 기준으로 나눠서 리스트化 a.split(&#39; &#39;) . [&#39;I&#39;, &#39;like&#39;, &#39;python&#39;] . a=&#39;I,like,python&#39; . a.split(&#39;,&#39;) . [&#39;I&#39;, &#39;like&#39;, &#39;python&#39;] . str에서 다음줄로 내릴 때 . a=&#39;I like python nHe likes python nfucking python&#39; . a . &#39;I like python nHe likes python nfucking python&#39; . print(a) . I like python He likes python fucking python . a.splitlines() . [&#39;I like python&#39;, &#39;He likes python&#39;, &#39;fucking python&#39;] . b=a.splitlines() . b[0] . &#39;I like python&#39; . b[0].upper() . &#39;I LIKE PYTHON&#39; . b[0].count(&#39;L&#39;) . 0 . . s=&#39;python&#39; . a=3 . print(s,a) . python 3 . print(s,str(a)) . python 3 . print(s+str(a)) . python3 . print(s + &#39; &#39; + str(a)) . python 3 . print(s,str(a)) . python 3 . Format . s=&#39;Python {}&#39; . s.format(25) . &#39;Python 25&#39; . s.format(1+5) . &#39;Python 6&#39; . s=&#39;Python {1} + {0}&#39; . s.format(3,&#39;asdas&#39;) . &#39;Python asdas + 3&#39; . s=&#39;Python {0} {1}&#39; . s.format(3,&#39;asd&#39;) . &#39;Python 3 asd&#39; . s=&#39;Python {1} {0}&#39; . s.format(3,&#39;asd&#39;) . &#39;Python asd 3&#39; . s= &#39;My name is {} I am {} years old&#39; . s.format(&#39;asd&#39;,12) . &#39;My name is asd I am 12 years old&#39; . print(&#39;python 3.8&#39;) . python 3.8 . ver=3.8 . print(&#39;python&#39;, ver) . python 3.8 . print(&#39;python&#39; + str(ver)) . python3.8 . print(&#39;python{}&#39;.format(ver)) . python3.8 . s=&#39;python{}&#39;.format(ver) . print(s) . python3.8 . . data=4321.123456 . print(&#39;DATA&#39;+str(data)) . DATA4321.123456 . print(&#39;DATA&#39;, data) . DATA 4321.123456 . print(&#39;DATA &#39;+str(data)) . DATA 4321.123456 . print(&#39;DATA= &#39;+str(data)) . DATA= 4321.123456 . print(&#39;DATA={}&#39;.format(data)) . DATA=4321.123456 . 중요 | . {0:&lt;10} =&gt; {0} 값을 &quot;:&lt;10&quot; 10자리로 표현할건데 왼쪽 정렬 | {1:&gt;5} =&gt; {1} 값을 &quot;:&gt;5&quot; 5자리로 표현할건데 오른쪽 정렬 | :^10 = 가운데 정렬 | . print(&#39;DATA= {:.2f}&#39;.format(data)) . DATA= 4321.12 . print(&#39;DATA= {:.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:4.0f}&#39;.format(data)) . DATA=4321 . print(&#39;DATA={:5.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:6.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:7.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:,}&#39;.format(data)) . DATA=4,321.123456 . data2=454654456.1213546 . print(&#39;DATA={:,}&#39;.format(data2)) . DATA=454,654,456.1213546 . . data자체가 float이라서 d입력하면 오류가 발생 | . int는 소수점 없으니까 .4d 이렇게 입력하면 오류 그냥 4d로 입력 | . print(&#39;DATA={:4d}&#39;.format(int(data))) . DATA=4321 . print(&#39;DATA={:5d}&#39;.format(int(data))) . DATA= 4321 . print(&#39;DATA={:8d}&#39;.format(int(data))) . DATA= 4321 . scientific notation : e라는 것을 사용하여 수를 표현해줌 | . print(&#39;data = {:e}&#39;.format(data)) . data = 4.321123e+03 . % 이용해보자 | . print(&#39;DATA=%(x)f&#39; % {&#39;x&#39; : data}) . DATA=4321.123456 . print(&#39;DATA=%(x).0f&#39; % {&#39;x&#39; : data}) . DATA=4321 . print(&#39;DATA=%(x).2f&#39; % {&#39;x&#39; : data}) . DATA=4321.12 . print(&#39;DATA=%(x)7.0f&#39; % {&#39;x&#39; : data}) . DATA= 4321 . print(&#39;DATA=%(x)8.3f&#39; % {&#39;x&#39; : data}) . DATA=4321.123 . print(&#39;DATA=%(x)8.0f&#39; % {&#39;x&#39; : data}) . DATA= 4321 . . import math math.pi . 3.141592653589793 . import numpy as np np.pi . 3.141592653589793 . math.inf . inf . np.inf . inf . math.nan #숫자가 아님을 표현할 때 . nan . np.nan . nan . math.e . 2.718281828459045 . math.floor(math.pi) . 3 . math.ceil(math.pi) . 4 . math.sqrt(math.pi) . 1.7724538509055159 . math.log(10) . 2.302585092994046 . math.log(math.e) . 1.0 . math.log10(10) . 1.0 . p=math.pi . math.sin(p/2) . 1.0 . math.sin(2*p) . -2.4492935982947064e-16 . x_degree=90 . x_radian=x_degree*(math.pi/180) . x_radian #pi/2랑 동일 . 1.5707963267948966 . math.radians(90) . 1.5707963267948966 . math.pow(2,3) . 8.0 . pow(2,3) . 8 . 2**3 . 8 . x=2 . math.isinf(x) . False . math.isnan(x) . False . math.fsum([1,2,3]) . 6.0 . # error 발생 # 원소가 int일때만 가능 . . file - input &amp; output . import os . os.chdir(&#39;c: test&#39;) . os.mkdir(&#39;temp4&#39;) . os.chdir(&#39;temp4&#39;) . os.getcwd() . &#39;c: test temp4&#39; . os.chdir(&#39;..&#39;) . os.getcwd() . &#39;c: test&#39; . os.chdir(&#39;temp&#39;) . os.getcwd() . &#39;c: test temp&#39; . os.chdir(&#39;.&#39;) . os.getcwd() . &#39;c: test temp&#39; . os.mkdir(&#39;dir0&#39;) . os.mkdir(&#39;dir3&#39;) . os.mkdir(&#39;dir4&#39;) . os.getcwd() . &#39;c: test temp&#39; . os.listdir() . [&#39;dir0&#39;, &#39;dir1&#39;, &#39;dir2&#39;, &#39;dir3&#39;, &#39;dir4&#39;, &#39;file1.txt&#39;, &#39;file2.txt&#39;, &#39;file3.txt&#39;, &#39;file4.txt&#39;] . os.rename(&#39;dir0&#39;,&#39;dir100&#39;) . os.listdir() . [&#39;dir1&#39;, &#39;dir100&#39;, &#39;dir2&#39;, &#39;dir3&#39;, &#39;dir4&#39;, &#39;file1.txt&#39;, &#39;file2.txt&#39;, &#39;file3.txt&#39;, &#39;file4.txt&#39;] . os.rmdir(&#39;dir100&#39;) . os.listdir() . [&#39;dir1&#39;, &#39;dir2&#39;, &#39;dir3&#39;, &#39;dir4&#39;, &#39;file1.txt&#39;, &#39;file2.txt&#39;, &#39;file3.txt&#39;, &#39;file4.txt&#39;] . import sys . # 파이썬에서 사용가능한 모듈들을 불러준 것 . # sys.path . os.chdir(&#39;C: Users ehfus Downloads python Introduction&#39;) . os.chdir(&#39;c: test temp&#39;) . os.getcwd() . &#39;c: test temp&#39; . . f=open(&#39;file1.txt&#39;,&#39;w&#39;)#파일 작성 . f.closed . False . f.write(&#39;fucking&#39;) . 7 . f.close() . f.closed . True . with open(&#39;file2.txt&#39;,&#39;w&#39;) as f: f.write(&#39;sibal n&#39;) f.write(&#39;jotgatne n&#39;) f.write(&#39;just joke n&#39;) . f.closed . True . fid=open(&#39;file2.txt&#39;,&#39;r&#39;) . fid.read() . &#39;sibal njotgatne njust joke n&#39; . fid.close() . fid.closed . True . fid=open(&#39;file2.txt&#39;,&#39;r&#39;) . fid.readline() . &#39;sibal n&#39; . fid.readline() . &#39;jotgatne n&#39; . fid.readline() . &#39;just joke n&#39; . fid.readline() . &#39;&#39; . 한 줄씩 불러옴 . fid.close() . fid=open(&#39;file2.txt&#39;,&#39;r&#39;) . data=[] . data.append(fid.readline()) . data.append(fid.readline()) . data.append(fid.readline()) . data . [&#39;sibal n&#39;, &#39;jotgatne n&#39;, &#39;just joke n&#39;] . 자동화 . data=[&#39;string1&#39;,&#39;string2&#39;,&#39;string3&#39;] . import json . f=open(&#39;file3.txt&#39;,&#39;w&#39;) . json.dump(data,f) . f.close() . f=open(&#39;file3.txt&#39;,&#39;r&#39;) . x=json.load(f) . x . [&#39;string1&#39;, &#39;string2&#39;, &#39;string3&#39;] . f.close() . import pickle . f=open(&#39;file4.txt&#39;,&#39;wb&#39;) # 바이너리로 쓰겠다 . 용량을 작게 할 수 있다는 장점이 있음 . pickle.dump(data,f) . f.close() . f=open(&#39;file4.txt&#39;,&#39;rb&#39;) # 바이너리 불러옴 . x= pickle.load(f) . x . [&#39;string1&#39;, &#39;string2&#39;, &#39;string3&#39;] . f.close() .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/23/intro.html",
            "relUrl": "/2021/12/23/intro.html",
            "date": " • Dec 23, 2021"
        }
        
    
  
    
        ,"post16": {
            "title": "2021/12/22/WED",
            "content": "&#51088;&#47308;&#54805; . 정수(int), 소수(float), 복소수(complex), 참거짓(bool,True,False), 문자(str) | . 문자형(str) &gt; 따옴표 하나 혹은 두개 | . &#39;a&#39;,&quot;hello&quot; # str이 tuple로 묶여있음 . (&#39;a&#39;, &#39;hello&#39;) . 자료의 형태를 알고 싶을 때 | . type(True) . bool . 자료형 변환 | . int() . 0 . str() . &#39;&#39; . bool() . False . int(1) . 1 . int(1.3) . 1 . str -&gt; int 또는 float으로 변경 가능 | . int(&#39;1&#39;) . 1 . float(&#39;3.14&#39;) . 3.14 . . float(&#39;-inf&#39;) . -inf . complex(1) . (1+0j) . complex(3+5j) . (3+5j) . complex(3,5.5) . (3+5.5j) . complex(&#39;1+3j&#39;) . (1+3j) . str(1) . &#39;1&#39; . str(2+5j) # 괄호랑 플러스,j모두 원소 하나하나로 들어감 . &#39;(2+5j)&#39; . bool(-0.8) . True . bool(&#39;&#39;) . False . bool(123) # 0이 아닌 다른 수는 모두 True . True . bool(&#39;aasdss&#39;) . True . bool(0) . False . bool(float(&#39;inf&#39;)) . True . float(&#39;inf&#39;),bool(&#39;-inf&#39;),complex(&#39;inf&#39;) . (inf, True, (inf+0j)) . &#50672;&#49328; . 1+1,3-2,5*2,5/2 . (2, 1, 10, 2.5) . 5//2 . 2 . 5%2 . 1 . divmod(5,3) # 원소 2개인 tuple로 들어감 . (1, 2) . abs(-232) . 232 . pow(5,4),5**4 . (625, 625) . &#39;asdasd&#39;+&#39;asdfeq&#39; . &#39;asdasdasdfeq&#39; . &#39;asdasd&#39;*2 . &#39;asdasdasdasd&#39; . 문자형이 다른 건 더할 수 없음 | . &#39;asdasd&#39;+str(235456) . &#39;asdasd235456&#39; . True+True . 2 . *** 비교 연산 =&gt; BOOL형태로 출력됨 | . 1&lt;0 . False . 2==3 . False . 1!=3 # 틀렸으니 맞다고 나올 것 . True . # False라고 나오긴 함 # 그런데 is나 is not은 원래 자료형이 같고 다른지를 물을 때 사용함 . type(&#39;123&#39;) is not type(True) . True . . True and False . False . True and False and True . False . 거짓이 하나라도 있으면 거짓 처리 | . True or False . True . True or False or False . True . 참이 하나라도 있으면 참 처리 | . not True . False . 참과 거짓을 반대로 바꿔주는 기능 | . 100 and 5 . 5 . True and 3 . 3 . 34 and True . True . 34 and 2 . 2 . 둘다 참일 경우(1이상인 수 혹은 True)일 땐 뒤에 걸 출력하는 것 같음 | . False and 3 . False . 0 and 100 # 하나 거짓 -&gt; 거짓 처리 . 0 . 이럴 땐 무조건 False출력 | . 1 or 100 . 1 . 100 or 1 . 100 . 100 or 1 or 300 . 100 . 3 or 1 or 45 or 0 . 3 . or 사용시엔 하나라도 참이 섞여있으면 그 중 가장 큰 참값을 출력함 | . 1 and 0 and 100 . 0 . 0(False)이 하나 있어서 0 출력 | . 1 and 5 or 100 . 5 . 1 and 5 or 100 and 1 or 3 and 100 . 5 . and 먼저 수행하는 것 같음 | . Bitwise :&#51060;&#51652;&#48277; . 2 #십진법 . 2 . bin(2) # 이진법 . &#39;0b10&#39; . bin(3) . &#39;0b11&#39; . bin(12) . &#39;0b1100&#39; . &amp; . 10&amp;6 . 2 . 10과 6을 2진법으로 처리한 후 겹치는 자리만 뽑아낸 것 | . bin(10) . &#39;0b1010&#39; . bin(6) . &#39;0b110&#39; . bin(10&amp;6) . &#39;0b10&#39; . 10|6 . 14 . bin(10|6) . &#39;0b1110&#39; . bin(10^6) . &#39;0b1100&#39; . bin(6&lt;&lt;2) . &#39;0b11000&#39; . bin(6&gt;&gt;2) . &#39;0b1&#39; . 6&gt;&gt;2 . 1 . &#48320;&#49688; . a=1 a . 1 . print(a) . 1 . b=3.225 . type(b) . float . b=546548 . b # b의 정의가 업데이트 . 546548 . d=True . print(d) . True . b=a . b # 다른 변수로 해당 변수를 업데이트 할 수 있음 . 1 . a=5 . a . 5 . b . 1 . a가 바뀌어도 a로 업데이트 된 b는 그 전 a의 자료인 1로 그대로 유지 중 . length=2 width=3 area=length*width . x=1 . y=2*x . y . 2 . a=3 . bin(a) . &#39;0b11&#39; . a.bit_length() . 2 . b=10 . bin(b) . &#39;0b1010&#39; . b.bit_length() . 4 . c=1+2j . d=c.conjugate() . d . (1-2j) . d.imag . -2.0 . c . (1+2j) . c.real # c 안의 실수 . 1.0 . c.imag # c 안의 허수 . 2.0 . a=1 . a+=1 # a에 있는 값을 1만큼 올려서 저장 . a . 2 . a-=10 . a . -8 . name=&#39;tom&#39; . name.capitalize() # 맨 앞을 대문자 처리 . &#39;Tom&#39; . name.count(&#39;2&#39;) #name이라는 변수에 2 몇개?, 대문자 소문자도 구별해서 카운트함 . 0 . name.count(&#39;o&#39;) . 1 . name.split(&#39;o&#39;) # o 없애고 나눠줌 # 리스트 형태로 저장됨 . [&#39;t&#39;, &#39;m&#39;] . a=name.split(&#39;o&#39;) . type(a[0]) . str . a[1]=&#39;o&#39; . a.append(&#39;m&#39;) # str, list에서 가능함 . a . [&#39;t&#39;, &#39;o&#39;, &#39;m&#39;] . # split은 str에서만 가능한가봄 . &#39;asdasd&#39;.capitalize() . &#39;Asdasd&#39; . a=&#39;i &#39;m student&#39; . a . &#34;i&#39;m student&#34; . 백 슬러시 다음에 심볼 적으면 심볼로 인식 | . input(&#39;enter: &#39;) . &#39;55&#39; . a=input(&#39;enter: &#39;) . a # str으로 저장됨 . &#39;55&#39; . age=int(input(&#39;enter your age: &#39;)) . age # int로 저장됨 . 565 . enter your age 이 부분은 그냥 user한테 input값 받아올 때 안내문 같은 거고 실제로 저장되는 건 입력값만 str으로 저장됨 | . del age . 변수 지우기 . a=1 b=3 a==b . False . a.__eq__(b) # a==b랑 동일 . False . a,b=10,134 # tuple을 의미하는 건 아님 . a,b=b,a . a와 b 교환 | . . str=1 . str . 1 . # error 발생 =&gt; 원래 내장 함수인 str이 위셀에서 변수명으로 저장됨으로써 함수기능을 상실함 . 즉 파이썬과 지원되는 함수와 동일한 변수명 사용하면 안 됨 . del str . Container . list. tuple. set. frozenset. dictionary. . list (수정 가능) | . asd=[10,25,&#39;123&#39;,True] # 자료형 혼합 가능 . asdasd=list([10,25,&#39;123&#39;,True]) # 이 방법으로 list만들 땐 꼭 대괄호로 묶어줘야 함 . tuple (수정 불가) | . qwe=(12,22.1,&#39;qwe&#39;) . qwe . (12, 22.1, &#39;qwe&#39;) . qweqwe=tuple([1,2,3,&#39;asdasd&#39;,True]) # 대괄호로 묶어줘야함 . qweqwe . (1, 2, 3, &#39;asdasd&#39;, True) . list와 tuple은 sequence자료형 | . vip_names = [&#39;c&#39;,&#39;d&#39;,&#39;a&#39;] . vip_names[0]=&#39;랴차&#39; . vip_names . [&#39;랴차&#39;, &#39;d&#39;, &#39;a&#39;] . 이렇게 list는 자료 수정 가능 | . slicing . my_list1=[12,123,123,123,42,14] . my_list1[0:2] #0,1번 원소 추출 . [12, 123] . my_list1[:] # 모든 자료 . [12, 123, 123, 123, 42, 14] . my_list1[::2] # 모든 자료형태에서 2단위로 추출 . [12, 123, 42] . my_list1[:3:2] # 0,1,2원소를 2단위로 추출 . [12, 123] . my_list1[::2] . [12, 123, 42] . my_list1[-1] . 14 . my_list1[-5:-1] # -1값은 해당 X . [123, 123, 123, 42] . my_list1[-5] . 123 . my_list1[-1::-1] # 뒤에서부터 가져올 땐 단위도 - 붙여줘야 함 . [14, 42, 123, 123, 123, 12] . my_list1[-1:2:-1] # 두번째 인덱스 전까지 뒤로 추출 # 시작을 -1로 해서 2로 끝났으니 마지막에 호출 단위를 -붙여서 꼭 해줘야함 # 호출단위를 안 쓰거나 플러스로 하면 아무것도 출력 안 됨 . [14, 42, 123] . my_list1[-1:1:-1] # 뒤에서부터 가져오기 뒤로 . [14, 42, 123, 123] . my_list1 . [12, 123, 123, 123, 42, 14] . my_list1[-4:5:1] . [123, 123, 42] . my_list2 = [[1,2,3,4,5],[1232]] . my_list4 = [[1,2,3,4,5], [1,2,3,4], &quot;ㅁㄴㅇㅁㄴㅇ&quot;] # 이렇게 복잡할 땐 한줄 내려서 입력해도 가능하다 . 리스트 중첩 가능 | . my_list4[0][3] . 4 . my_list4[1][::2] . [1, 3] . my_list5 = [ [10,20,[100,200,300]], [40,50,60] ] . my_list5[0][2][2] # 리스트 중첩 후 원소 불러오기 . 300 . a=[1,2] b=[123,2323] . a+b . [1, 2, 123, 2323] . a=[[1,2],[1,2,3]] . b=[[1,2,&#39;s&#39;],[1,2,3]] . a+b . [[1, 2], [1, 2, 3], [1, 2, &#39;s&#39;], [1, 2, 3]] . a*2 . [[1, 2], [1, 2, 3], [1, 2], [1, 2, 3]] . old_a=[1,2,3] . new_a=old_a . old_a[0]=2 . new_a[0] . 2 . new_a=old_a는 같은 메모리를 공유함으로써 new_a 와 old_a 모두 동시 수정됨 | . 대책은? | . new_a=old_a.copy() . new_a[0]=&#39;1&#39; . new_a . [&#39;1&#39;, 2, 3] . old_a . [2, 2, 3] . extend | . a=[1,2,3] b=[2,3,4] . a+b . [1, 2, 3, 2, 3, 4] . a.extend(b) . a . [1, 2, 3, 2, 3, 4] . a=[1,2,3] b=[2,3,4] . a+=b . a . [1, 2, 3, 2, 3, 4] . asd=[&#39;asds&#39;,&#39;sdasd&#39;,&#39;sd&#39;] . 이 자료에 원소 추가하기 | . asd.append(&#39;e&#39;) . asd . [&#39;asds&#39;, &#39;sdasd&#39;, &#39;sd&#39;, &#39;e&#39;] . asd.remove(&#39;e&#39;) . asd . [&#39;asds&#39;, &#39;sdasd&#39;, &#39;sd&#39;] . 인덱스로 원소 지우기 -&gt; pop사용 | . asd.pop(1) # &#39;sdasd&#39;가 삭제됨 . &#39;sdasd&#39; . asd . [&#39;asds&#39;, &#39;sd&#39;] . 초기화 | . asd.clear() . asd . [] . asd.insert(0,&#39;sds&#39;) . asd . [&#39;sds&#39;] . str에선 append였음 | list에선 insert , 사용할 때 5자리에 넣고 싶어도 마지막 자리에 순서대로 추가 됨 | . asd.index(&#39;sds&#39;) # 자리 번호 알기 . 0 . asd.count(&#39;sds&#39;) # 몇번 들어가 있는지 . 1 . a=[&#39;a&#39;,&#39;c&#39;,&#39;f&#39;,&#39;b&#39;] . a.sort() # 정렬중 . a # 숫자와, bool도 정렬가능 . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;f&#39;] . a=[2,&#39;False&#39;] . # 이렇게 자료형이 섞여있으면 불가능 # 지금 False가 bool형태가 아니라 str형태로 들어가있음 . asf=[True,123333,0,134] . asf.sort() . asf # 자료형이 안 섞여있으면 가능 . [0, True, 134, 123333] . qwe=[1,2,3] . qwe.reverse() . qwe . [3, 2, 1] . qwe[-1::-1] # reverse와 동일 . [1, 2, 3] . . set | . my_set1={1,2,3} . my_set2={False,5,54} . my_set3={False,5,5} . my_set3 . {False, 5} . 집합처럼 중복 원소는 하나로 처리 . set은 인덱스를 지원하지 않음 . alist=[2,3,4,1324] . my_set32412=set(alist) . my_set32412 . {2, 3, 4, 1324} . my_set32412.add(2525) . my_set32412 . {2, 3, 4, 1324, 2525} . my_set32412.update([546]) . my_set32412 . {2, 3, 4, 546, 1324, 2525} . 이렇게 순서대로 들어가게 됨 | . my_set32412.discard(1324) . my_set32412 . {2, 3, 4, 546, 2525} . my_set32412.remove(2525) . my_set32412 . {2, 3, 4, 546} . 즉 discard와 remove는 동일하나 remove는 이미 없는 값을 또 삭제하려 할 때 error메세지를 보여줌 . a={1,2,3,5} b={6,5,55,4} . a or b . {1, 2, 3, 5} . b or a . {4, 5, 6, 55} . 앞에 있는 거 출력 | . 2|4 . 6 . 이거랑 다른 거 . a|b . {1, 2, 3, 4, 5, 6, 55} . a.union(b) . {1, 2, 3, 4, 5, 6, 55} . b.union(a) . {1, 2, 3, 4, 5, 6, 55} . a&amp;b # 교집합 . {5} . a.intersection(b) . {5} . b.intersection(a) . {5} . a-b . {1, 2, 3} . a.difference(b) . {1, 2, 3} . b.difference(a) . {4, 6, 55} . a^b # 겹치는 거 빼고 출력 . {1, 2, 3, 4, 6, 55} . a.symmetric_difference(b) ## 겹치는 거 빼고 출력 . {1, 2, 3, 4, 6, 55} . b.symmetric_difference(a) # 겹치는 거 빼고 출력 . {1, 2, 3, 4, 6, 55} . a={1,2,3,4,5} b={1} . b.issubset(a) #b가 a의 부분집합? . True . a.issubset(b) # a가 b의 부분집합? . False . a.issuperset(b) # a는 b를 포함? . True . b.issuperset(a)# b는 a를 포함? . False . . a=frozenset([1,2,3,4,5]) . b=frozenset([4,5,6,7,8]) . a|b . frozenset({1, 2, 3, 4, 5, 6, 7, 8}) . a&amp;b . frozenset({4, 5}) . # 추가 불가 # frozenset이기 때문에 . c=set([1,2,3,4]) . a&amp;c . frozenset({1, 2, 3, 4}) . asq=[&#39;qw&#39;,&#39;qwa&#39;,&#39;qwsd&#39;] . door1_list = [&#39;qw&#39;] . door2_list = [&#39;qwa&#39;] . door1_list in asq . False . door1_list . [&#39;qw&#39;] . 왜 false? | . door1_list[0] . &#39;qw&#39; . door1_list[0] in asq . True . all=set(asq) . all . {&#39;qw&#39;, &#39;qwa&#39;, &#39;qwsd&#39;} . d1=set(door1_list) . d2=set(door2_list) . d1.issubset(all) . True . d2.issubset(all) . True . d_combine=d1 |d2 . d_combine . {&#39;qw&#39;, &#39;qwa&#39;} . d_combine.issubset(all) # 부분집합? . True . all-d_combine . {&#39;qwsd&#39;} . dic =&gt; key,value로 이루어져있다 | . : 이 들어가면서 set이랑은 다름 | . type(my_dict) . dict . my_dict={&#39;a&#39;:&#39;qewqwe&#39;,&#39;b&#39;:&#39;qewe&#39;,&#39;c&#39;:&#39;qwqwe&#39;} . my_dict[&#39;c&#39;] . &#39;qwqwe&#39; . 즉 따라서 순서는 중요하지 않음 . number={&#39;1&#39;:&#39;12312123123&#39;,&#39;asas&#39;:&#39;12313&#39;,&#39;asdad&#39;:&#39;12323&#39;} . number[&#39;asas&#39;] . &#39;12313&#39; . number.get(&#39;asas&#39;) . &#39;12313&#39; . number[&#39;asas&#39;]=&#39;fucking&#39; # 자료 업데이트 . number.update({&#39;1&#39;:&#39;asdasdddd&#39;}) # 자료 업데이트 . number[&#39;1&#39;] . &#39;asdasdddd&#39; . &#39;1&#39; in number # key가 들어가있는지 안 들어가 있는지 . True . number.pop(&#39;1&#39;) # 삭제 . &#39;asdasdddd&#39; . number . {&#39;asas&#39;: &#39;fucking&#39;, &#39;asdad&#39;: &#39;12323&#39;} . number.clear() . number . {} . . alist=[1,2,3,4,5] atuple=(1,2,3,4,5) aset={1,2,3,4,5} . len(alist) # 컨테이너의 값 개수를 알 수 있음 . 5 . max(aset) . 5 . min(alist) . 1 . 6 in atuple # 값 들어가있는지 체크하기 . False . 555 not in atuple . True . . list unpacking . a=[&#39;a&#39;,23,&#39;asf&#39;] . name=a[0] . age=a[1] . lan=a[2] . 이걸 한 번에 = list unpacking | . name,age,lan=a . 리스트 a에서 처음 원소만 자료로 받고 나머지는 그에 헤당한 자료형으로 남겨놓고 싶을 때 | . name, *rest = a . 응용하면 . *rest,name=a . name . &#39;asf&#39; . first,second,*rest=a . first . &#39;a&#39; . second . 23 . . a=range(0,21,2) # 20까지임 . a . range(0, 21, 2) . type(a) . range . a[2] . 4 . a.index(20) . 10 . a[10] . 20 . a[:5] . range(0, 10, 2) . a[-1] . 20 . list(range(10,51,10)) . [10, 20, 30, 40, 50] . . for i in range(5) : print(i) . 0 1 2 3 4 . for i in range(2,11,2) : print(i) . 2 4 6 8 10 . for i in range(10,2,-2) : print(i) . 10 8 6 4 . for i in range(10,1,-2) : print(i) . 10 8 6 4 2 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/22/intro.html",
            "relUrl": "/2021/12/22/intro.html",
            "date": " • Dec 22, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://rhkrehtjd.github.io/INTROpython/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  

  
  

  
      ,"page11": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://rhkrehtjd.github.io/INTROpython/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}
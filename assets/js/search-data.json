{
  
    
        "post0": {
            "title": "2021/12/22/Wed",
            "content": "&#51088;&#47308;&#54805; . 정수(int) | . 1 . 1 . 소수(float) | . 1.2 . 1.2 . 복소수(complex) | . 1.2+2j . (1.2+2j) . 문자형(str) &gt; 따옴표 하나 혹은 두개 가능 | . &#39;a&#39;,&quot;hello&quot; . (&#39;a&#39;, &#39;hello&#39;) . 참, 거짓형(bool) | . True . True . . 자료의 형태를 알고 싶을 때 | . type(True) . bool . . 자료형 변환 | . int() . 0 . str() . &#39;&#39; . bool() . False . int(1) . 1 . int(1.3) . 1 . int(1.8) . 1 . int(&#39;1&#39;) # str -&gt; int . 1 . float(&#39;3.14&#39;) # sre -&gt; float . 3.14 . 그런데 &#39;3.14&#39;이 str형태를 int로 변환할 순 없음 . float(&#39;-inf&#39;) . -inf . complex(1) . (1+0j) . complex(3+5j) . (3+5j) . complex(3,5.5) . (3+5.5j) . complex(&#39;1+3j&#39;) . (1+3j) . str(1) . &#39;1&#39; . str(2+5j) . &#39;(2+5j)&#39; . str(&quot;asdasdas&quot;) . &#39;asdasdas&#39; . bool(1) . True . bool(0) . False . bool(23123) . True . 0이 아닌 다른 수는 모두 True . bool(float(&#39;inf&#39;)) . True . float(&#39;inf&#39;),bool(&#39;-inf&#39;),complex(&#39;inf&#39;) . (inf, True, (inf+0j)) . bool(-0.8) . True . bool(&#39;&#39;) . False . bool(&#39;aasdss&#39;) . True . &#50672;&#49328; . 1+1,3-2,5*2,5/2 . (2, 1, 10, 2.5) . 5//2 . 2 . 5%2 . 1 . abs(-232) . 232 . divmod(5,3) . (1, 2) . pow(5,4),5**4 . (625, 625) . 2+1*5 . 7 . &#39;asdasd&#39;+&#39;asdfeq&#39; . &#39;asdasdasdfeq&#39; . &#39;asdasd&#39;+str(235456) . &#39;asdasd235456&#39; . # &#39;asdasd&#39;+2 . True+True . 2 . &#48708;&#44368; &#50672;&#49328; =&gt; &#44208;&#44284;&#45716; BOOL&#54805;&#53468;&#47196; &#52636;&#47141;&#46120; . 1&lt;0 . False . 2==3 . False . 틀린 지 물어보기 . 1!=3 # 틀렸으니 맞다고 나올 것 . True . 3 is 4 . &lt;&gt;:1: SyntaxWarning: &#34;is&#34; with a literal. Did you mean &#34;==&#34;? &lt;&gt;:1: SyntaxWarning: &#34;is&#34; with a literal. Did you mean &#34;==&#34;? C: Users ehfus AppData Local Temp/ipykernel_4876/1052624616.py:1: SyntaxWarning: &#34;is&#34; with a literal. Did you mean &#34;==&#34;? 3 is 4 . False . 그런데 is나 is not은 원래 자료형 비교할 때 사용함 . type(&#39;123&#39;) is not type(True) . True . True and False . False . True and False and True . False . 즉 거짓이 하나라도 있으면 거짓 처리 . True or False . True . True or False or False . True . 즉 참이 하나라도 있으면 참 처리 . not True . False . 참과 거짓을 반대로 바꿔주는 기능 . 100 and 1 # 둘다 참 -&gt; 참 처리 . 1 . 0 and 100 # 하나 거짓 -&gt; 거짓 처리 . 0 . 1 and 100 # 둘다 참 -&gt; 100 출력 # 100 and 1 일 땐 1 출력 . 100 . 100 or 1 # 둘다 참 -&gt; 100 출력 . 100 . 1 and 0 and 100 . 0 . 1 and 10 and 100 . 100 . 1 and 10 and 2 . 2 . 1 and 2 or 100 . 2 . 1 or 3 and 100 . 1 . 1 or 3 or 100 . 1 . 10 or 1 . 10 . Bitwise . 2 #십진법 . 2 . bin(2) # 이진법 . &#39;0b10&#39; . bin(3) . &#39;0b11&#39; . bin(12) . &#39;0b1100&#39; . bin(6) . &#39;0b110&#39; . ??? &amp; . 10&amp;6 . 2 . bin(10) . &#39;0b1010&#39; . bin(6) . &#39;0b110&#39; . bin(10&amp;6) . &#39;0b10&#39; . bin(10|6) . &#39;0b1110&#39; . bin(10^6) . &#39;0b1100&#39; . 10^6 . 12 . bin(6&lt;&lt;2) . &#39;0b11000&#39; . bin(6&gt;&gt;2) . &#39;0b1&#39; . 6&gt;&gt;2 . 1 . &#48320;&#49688; . a=1 a . 1 . print(a) . 1 . b=3.225 . type(b) . float . b=546548 . b # b의 정의가 업데이트 . 546548 . d=True . print(d) . True . b=a . b # 다른 변수로 해당 변수를 업데이트 할 수 있음 . 1 . a=5 . a . 5 . b . 1 . a가 바뀌어도 a로 업데이트 된 b는 그 전 a의 자료인 1로 그대로 유지 중 . length=2 width=3 area=length*width . x=1 . y=2*x . y . 2 . a=3 . bin(a) . &#39;0b11&#39; . a.bit_length() . 2 . b=10 . bin(b) . &#39;0b1010&#39; . b.bit_length() . 4 . c=1+2j . c.conjugate() . (1-2j) . c.real # c 안의 실수 . 1.0 . c.imag # c 안의 허수 . 0 . a=1 . a+=1 # a에 있는 값을 1만큼 올려서 저장 . a . 2 . a-=10 . a . -8 . name=&#39;tom&#39; . name.capitalize() # 맨 앞을 대문자 처리 . &#39;Tom&#39; . name.count(&#39;2&#39;) #name이라는 변수에 2 몇개?, 대문자 소문자도 구별해서 카운트함 . 0 . name.split(&#39;o&#39;) # o 없애고 나눠줌 # 리스트 형태로 저장됨 . [&#39;t&#39;, &#39;m&#39;] . &#39;asdasd&#39;.capitalize() . &#39;Asdasd&#39; . a=&#39;i &#39;m student&#39; . a . &#34;i&#39;m student&#34; . 즉 백 슬러시 다음에 심볼 적으면 심볼로 인식하게 됨 . a=&#39;ASDASD&#39; . a*3 . &#39;ASDASDASDASDASDASD&#39; . input을 유저한테 받아올 때 . input(&#39;enter: &#39;) . &#39;3&#39; . a=input(&#39;enter: &#39;) . a # str으로 저장됨 . &#39;3&#39; . age=int(input(&#39;enter your age: &#39;)) . age # int로 저장됨 . 23 . 변수 지우기 . del age . a=1 b=3 a==b . False . a.__eq__(b) # a==b랑 동일 . False . a,b=10,134 . a와 b 교환 . a,b=b,a . . str=1 . str(1.3) . TypeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11492/930539355.py in &lt;module&gt; -&gt; 1 str(1.3) TypeError: &#39;int&#39; object is not callable . 즉 파이썬과 지원되는 함수와 동일한 변수명 사용하면 안 됨 . Container . list. tuple. set. frozenset. dictionary. . list &#49688;&#51221; &#44032;&#45733; . asd=[10,25,&#39;123&#39;,True] # 방법 1 . asdasd=list([10,25,&#39;123&#39;,True]) # 방법 2 . tuple &#49688;&#51221; &#48520;&#44032;&#45733; . qwe=(12,22.1,&#39;qwe&#39;) . qwe . (12, 22.1, &#39;qwe&#39;) . qweqwe=tuple([1,2,3,&#39;asdasd&#39;,True]) . qweqwe . (1, 2, 3, &#39;asdasd&#39;, True) . 자료 불러오기 . asd[0] . 10 . qwe[0] . 12 . list와 tuple은 sequence자료형 . vip_names = [&#39;c&#39;,&#39;d&#39;,&#39;a&#39;] . vip_names[0]=&#39;랴차&#39; . vip_names . [&#39;랴차&#39;, &#39;d&#39;, &#39;a&#39;] . list는 자료 수정이 가능하나 . tuple은 자료 수정 불가능하다 . my_list1=[12,123,123,123,42,14] . slicing . my_list1[0:2] #0,1번 원소 추출 . [12, 123] . my_list1[:] # 모든 자료 . [12, 123, 123, 123, 42, 14] . my_list1[::2] # 모든 자료형태에서 2단위로 추출 . [12, 123, 42] . my_list1[:3:2] # 0,1,2원소를 2단위로 추출 . [12, 123] . my_list1[::2] . [12, 123, 42] . my_list1[-1] . 14 . my_list1[-5:-1] # -1값은 해당 X . [123, 123, 123, 42] . my_list1[-5] . 123 . my_list1[-1::-1] # 뒤에서부터 가져올 땐 단위도 - 붙여줘야 함 . [14, 42, 123, 123, 123, 12] . my_list1[-1:2:-1] # 두번째 인덱스 전까지 뒤로 추출 . [14, 42, 123] . my_list1[-1:1:-1] # 뒤에서부터 가져오기 뒤로 . [14, 42, 123, 123] . my_list1[-4:5:1] # 뒤에서부터 가져오기 . [123, 123, 42] . ::1,::-1 즉 플러스면 앞으로 가며 읽어주고 마이너스면 뒤로 가면서 읽어줌 . 리스트 중첩 가능 . my_list2 = [[1,2,3,4,5],[1232]] . my_list4 = [[1,2,3,4,5], [1,2,3,4], &quot;ㅁㄴㅇㅁㄴㅇ&quot;] # 이렇게 복잡할 땐 한줄 내려서 입력해도 가능하다 . my_list4[0][3] . 4 . my_list4[1][::2] . [1, 3] . my_list5 = [ [10,20,[100,200,300]], [40,50,60] ] . my_list5[0][2][2] # 리스트 중첩 후 원소 불러오기 . 300 . a=[1,2] b=[123,2323] . a+b . [1, 2, 123, 2323] . 리스트의 덧셈은 그냥 자료룰 연결함 . a=[[1,2],[1,2,3]] . b=[[1,2,&#39;s&#39;],[1,2,3]] . a+b . [[1, 2], [1, 2, 3], [1, 2, &#39;s&#39;], [1, 2, 3]] . 리스트에서 연산은 더해주는 것이기 때문에 -는 지원 . 곱셈은 지원 가능 . a*2 . [[1, 2], [1, 2, 3], [1, 2], [1, 2, 3]] . old_a=[1,2,3] . new_a=old_a . old_a[0]=2 . new_a[0] . 2 . 즉 new_a=old_a 같은 메모리를 공유함으로써 new_a 와 old_a 모두 동시 수정됨 . 대책은? . new_a=old_a.copy() . new_a[0]=&#39;1&#39; . new_a . [&#39;1&#39;, 2, 3] . old_a . [2, 2, 3] . 이렇게 안 바뀜을 알 수 있다 . extend . a=[1,2,3] b=[2,3,4] . a.extend(b) . a . [1, 2, 3, 2, 3, 4] . extend와 똑같은 기능들 . a=a+b . a . [1, 2, 3, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4] . a+=b . a . [1, 2, 3, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4] . asd=[&#39;asds&#39;,&#39;sdasd&#39;,&#39;sd&#39;] . 이 자료에 원소 추가하기 . asd.append(&#39;e&#39;) . asd . [&#39;asds&#39;, &#39;sdasd&#39;, &#39;sd&#39;, &#39;e&#39;] . asd.remove(&#39;e&#39;) . asd . [&#39;asds&#39;, &#39;sdasd&#39;, &#39;sd&#39;] . 인덱스로 원소 지우기 -&gt; pop사용 . asd.pop(1) . &#39;sd&#39; . asd . [&#39;asds&#39;] . 초기화 . asd.clear() . asd . [] . asd.insert(0,&#39;sds&#39;) . asd . [&#39;sds&#39;] . insert 함수 사용할 때 5자리에 넣고 싶어도 마지막 자리에 순서대로 추가 됨 . asd.index(&#39;sds&#39;) # 자리 번호 알기 . 0 . asd.count(&#39;sds&#39;) # 몇번 들어가 있는지 . 1 . a=[&#39;a&#39;,&#39;c&#39;,&#39;f&#39;,&#39;b&#39;] . a.sort() . a # 숫자와, bool도 정렬가능 . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;f&#39;] . a=[2,&#39;False&#39;] . a.sort() # 이렇게 자료형이 섞여있으면 불가능 . TypeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11492/873731035.py in &lt;module&gt; -&gt; 1 a.sort() # 이렇게 자료형이 섞여있으면 불가능 TypeError: &#39;&lt;&#39; not supported between instances of &#39;str&#39; and &#39;int&#39; . asf=[True,123333,0,134] . asf.sort() . asf # 자료형이 안 섞여있으면 가능 . [0, True, 134, 123333] . qwe=[1,2,3] . qwe.reverse() . qwe . [3, 2, 1] . qwe[-1::-1] # reverse와 동일 . [1, 2, 3] . data=[[&#39;s&#39;,23], [&#39;asd&#39;,2344]] . . my_set1={1,2,3} . my_set2={False,5,54} . my_set3={False,5,5} . my_set3 . {False, 5} . 즉 중복은 하나로 처리함 . set은 인덱스를 지원하지 않음 . alist=[2,3,4,1324] . my_set32412=set(alist) . my_set32412 . {2, 3, 4, 1324} . b=set() . b . set() . my_set32412.add(2525) . my_set32412 . {2, 3, 4, 1324, 2525} . my_set32412.update([1]) . my_set32412 . {1, 2, 3, 4, 1324, 2525} . my_set32412.discard(1324) . my_set32412 . {1, 2, 3, 4, 2525} . my_set32412.remove(2525) . my_set32412 . {1, 2, 3, 4} . 즉 discard와 remove는 동일하나 remove는 이미 없는 값을 또 삭제하려 할 때 error메세지를 보여줌 . a={1,2,3,5} b={6,5,55,4} . a or b . {1, 2, 3, 5} . b or a . {4, 5, 6, 55} . a|b . {1, 2, 3, 4, 5, 6, 55} . a.union(b) . {1, 2, 3, 4, 5, 6, 55} . b.union(a) . {1, 2, 3, 4, 5, 6, 55} . a&amp;b # 교집합 . {5} . a.intersection(b) . {5} . b.intersection(a) . {5} . a-b . {1, 2, 3} . a.difference(b) . {1, 2, 3} . b.difference(a) . {4, 6, 55} . a^b # 겹치는 거 빼고 출력 . {1, 2, 3, 4, 6, 55} . a.symmetric_difference(b) ## 겹치는 거 빼고 출력 . {1, 2, 3, 4, 6, 55} . b.symmetric_difference(a) # 겹치는 거 빼고 출력 . {1, 2, 3, 4, 6, 55} . a={1,2,3,4,5} b={1} . b.issubset(a) #b에 있는 값이 a에 있니 . True . a.issubset(b) # a에 있는 값이 b에 있니 . False . a.issuperset(b) #b에 있는 값이 a에 있니 . True . b.issuperset(a)# a에 있는 값이 b에 있니 . False . . a=frozenset([1,2,3,4,5]) . b=frozenset([4,5,6,7,8]) . a|b . frozenset({1, 2, 3, 4, 5, 6, 7, 8}) . a&amp;b . frozenset({4, 5}) . a.add(100) # 추가 불가 . AttributeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11492/4216742371.py in &lt;module&gt; -&gt; 1 a.add(100) # 추가 불가 AttributeError: &#39;frozenset&#39; object has no attribute &#39;add&#39; . c=set([1,2,3,4]) . a&amp;c . frozenset({1, 2, 3, 4}) . asq=[&#39;qw&#39;,&#39;qwa&#39;,&#39;qwsd&#39;] . door1_list = [&#39;qw&#39;] . door2_list = [&#39;qwa&#39;] . door1_list in asq . False . 왜 false? . door1_list[0] in asq . True . all=set(asq) . all . {&#39;qw&#39;, &#39;qwa&#39;, &#39;qwsd&#39;} . d1=set(door1_list) . d2=set(door2_list) . d1.issubset(all) . True . d2.issubset(all) . True . d_combine=d1 |d2 . d_combine . {&#39;qw&#39;, &#39;qwa&#39;} . d_combine.issubset(all) . True . all-d_combine . {&#39;qwsd&#39;} . door_list = [&#39;zxc&#39;,&#39;zxzx&#39;] . door_list2 = [&#39;zxcs&#39;,&#39;zsxzx&#39;] . d=set(door_list) . d2=set(door_list2) . combined=d1|d2 . combined.issubset(all) . False . all . {&#39;qw&#39;, &#39;qwa&#39;, &#39;qwsd&#39;} . dic =&gt; key,value로 이루어져있다 . my_dict={&#39;a&#39;:&#39;qewqwe&#39;,&#39;b&#39;:&#39;qewe&#39;,&#39;c&#39;:&#39;qwqwe&#39;} . my_dict[&#39;c&#39;] . &#39;qwqwe&#39; . 즉 따라서 순서는 중요하지 않음 . number={&#39;1&#39;:&#39;12312123123&#39;,&#39;asas&#39;:&#39;12313&#39;,&#39;asdad&#39;:&#39;12323&#39;} . number[&#39;asas&#39;] . &#39;12313&#39; . number.get(&#39;asas&#39;) . &#39;12313&#39; . number[&#39;asas&#39;]=&#39;fucking&#39; # 자료 업데이트 . number.update({&#39;1&#39;:&#39;asdasdddd&#39;}) # 자료 업데이트 . number[&#39;1&#39;] . &#39;asdasdddd&#39; . &#39;1&#39; in number # key가 들어가있는지 안 들어가 있는지 . True . number.pop(&#39;1&#39;) # 삭제 . &#39;asdasdddd&#39; . number . {&#39;asas&#39;: &#39;fucking&#39;, &#39;asdad&#39;: &#39;12323&#39;} . number.clear() . number . {} . . alist=[1,2,3,4,5] atuple=(1,2,3,4,5) aset={1,2,3,4,5} . len(alist) # 컨테이너의 값 개수를 알 수 있음 . 5 . len =&gt; comtainer에 사용 . max(aset) . 5 . min(alist) . 1 . 6 in atuple # 값 들어가있는지 체크하기 . False . flag= 6 in atuple . flag2= 555 not in atuple . flag2 . True . . list unpacking . a=[&#39;a&#39;,23,&#39;asf&#39;] . name=a[0] . age=a[1] . lan=a[2] . 이걸 한 번에 = list unpacking . name,age,lan=a . 리스트 a에서 처음 원소만 자료로 받고 나머지는 그에 헤당한 자료형으로 남겨놓고 싶을 때 . name, *remain=a . 응용하면 . *rest,name=a . name . &#39;asf&#39; . 더 응용하면 . first,second,*rest=a . . a=range(0,21,2) # 20까지임 . a . range(0, 21, 2) . 20 in a . True . a.index(20) . 10 . a[10] . 20 . a . range(0, 21, 2) . a[:5] . range(0, 10, 2) . a[-1] . 20 . list(range(10,51,10)) . [10, 20, 30, 40, 50] . . for i in range(5) : print(i) . 0 1 2 3 4 . for i in range(2,11,2) : print(i) . 2 4 6 8 10 . for i in range(10,2,-2) : print(i) . 10 8 6 4 . for i in range(10,1,-2) : print(i) . 10 8 6 4 2 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/22/intro.html",
            "relUrl": "/2021/12/22/intro.html",
            "date": " • Dec 22, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://rhkrehtjd.github.io/INTROpython/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://rhkrehtjd.github.io/INTROpython/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}
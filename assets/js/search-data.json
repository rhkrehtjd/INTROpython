{
  
    
        "post0": {
            "title": "2022/12/24/FRI",
            "content": "import numpy as np . np.linspace(0,4,5) . array([0., 1., 2., 3., 4.]) . np.arange(10) # 0부터 10개의 숫자 . array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) . a=np.array([10,20,3]) . a.shape # array의 shape을 알려줌 # 1차원 행렬에 방 세개 . (3,) . a.ndim #1차원 . 1 . a.dtype #array에 들어간 숫자들이 어떤 형식으로? . dtype(&#39;int32&#39;) . a.itemsize # 4byte 32=4*8 . 4 . a.size #몇개 들어가 있니 . 3 . type(a) #몇차원이고 될 수 있음, nd=ndimension . numpy.ndarray . np.array도 sequence 타입 =&gt; index,slicing가능 | . a[2] . 3 . a[2]=30.8 . a . array([10, 20, 30]) . 소수점 날라가고 30으로 저장됨 . a.dtype . dtype(&#39;int32&#39;) . a=a.astype(&#39;float64&#39;) . a[2]=30.865 . a . array([10. , 20. , 30.865]) . a.dtype . dtype(&#39;float64&#39;) . 소수점도 가능한 자료형으로 변경해줬음 | . b=np.array([10.,20.,30.]) . b.dtype . dtype(&#39;float64&#39;) . 애초에 이렇게 dot을 지정해주고 들어가면 float으로 활용가능 . c=np.array([10.2,20.3,50.58],&#39;int32&#39;) . c . array([10, 20, 50]) . 이렇게 &#39;int32&#39;로 지정해줄 수 있음 . x=np.array([7,9,11]) y=x/2 . y . array([3.5, 4.5, 5.5]) . x.dtype . dtype(&#39;int32&#39;) . y.dtype . dtype(&#39;float64&#39;) . x가 정수로 시작했어도 y는 divide를 사용하고 있기에 알아서 np에서 float64로 지정함 . int32 $vs$ int64 . x=np.array([0]) . x[0]=2147483647 . x . array([2147483647]) . x[0]=x[0]+1 . C: Users ehfus AppData Local Temp/ipykernel_11512/4237261130.py:1: RuntimeWarning: overflow encountered in long_scalars x[0]=x[0]+1 . 2147483647은 int32에서 수용할 수 있는 최대의 숫자임, 따라서 여기서 1만 더해주더라도 수용하지 못하게 됨 . x=np.array([0],&#39;int64&#39;) . x[0]=2147483647 . x[0]+1 . 2147483648 . dtype을 int64로 바꿨기 때문에 int32에서 최대였던 것보다 더 수용할 수 있게 됨 . a=np.array([10,&#39;abc&#39;,20]) # 꼭 list형태로 줘야 함 . a.dtype #섞여있음 . dtype(&#39;&lt;U11&#39;) . a*2 . UFuncTypeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11512/434652760.py in &lt;module&gt; -&gt; 1 a*2 UFuncTypeError: ufunc &#39;multiply&#39; did not contain a loop with signature matching types (dtype(&#39;&lt;U11&#39;), dtype(&#39;int32&#39;)) -&gt; None . 섞여있으면 이런 연산은 불가 . a=np.array([[10,20,30],[40,50,60]]) . a # 2차원 . array([[10, 20, 30], [40, 50, 60]]) . a.shape # 2x3행렬로 해석해도 될듯 . (2, 3) . a.itemsize . 4 . a.size . 6 . a=np.array([[10,20,30],[40,50,60],[5,6,8]]) . a . array([[10, 20, 30], [40, 50, 60], [ 5, 6, 8]]) . a.size . 9 . a=np.array([[10,20,30], [40,50,60], [55,54,88] ,[112,123,41]]) . a . array([[ 10, 20, 30], [ 40, 50, 60], [ 55, 54, 88], [112, 123, 41]]) . a.ndim . 2 . a.shape . (4, 3) . a=np.array([10+10j,10+60j]) . a . array([10.+10.j, 10.+60.j]) . a=np.array([10,20],&#39;complex&#39;) . a . array([10.+0.j, 20.+0.j]) . . a=np.array([10,20]) . b=np.matrix([10,20]) . a.ndim . 1 . b.ndim . 2 . b=np.matrix([[[10]]]) . ValueError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11512/2972594669.py in &lt;module&gt; -&gt; 1 b=np.matrix([[[10]]]) ~ Anaconda3 envs dv2021 lib site-packages numpy matrixlib defmatrix.py in __new__(subtype, data, dtype, copy) 147 shape = arr.shape 148 if (ndim &gt; 2): --&gt; 149 raise ValueError(&#34;matrix must be 2-dimensional&#34;) 150 elif ndim == 0: 151 shape = (1, 1) ValueError: matrix must be 2-dimensional . 2차원을 넘어간 3차원이기에 불가능 . a=np.array([10,20,30]) . a=np.insert(a,2,5) # a라는 np.array의 2번째 인덱스에 5를 넣어라 . a . array([ 5, 10, 5, 5, 20, 30]) . a=np.delete(a,5) . a # 다섯번째 인덱스 삭제 . array([ 5, 10, 5, 5, 20]) . a=np.array([1,2,3]) . a=np.arange(3) . a # 0부터 시작해서 숫자 3개를 채워줌 . array([0, 1, 2]) . a=np.zeros((2,3)) . a . array([[0., 0., 0.], [0., 0., 0.]]) . a=np.ones((2,3)) . a . array([[1., 1., 1.], [1., 1., 1.]]) . a=np.linspace(0,5,4) #0부터 5까지 4개로 . a . array([0. , 1.66666667, 3.33333333, 5. ]) . a=np.linspace(0,5,6) #0부터 5까지 6개로 . a . array([0., 1., 2., 3., 4., 5.]) . a=np.logspace(0,5,4) # log scale로! . a . array([1.00000000e+00, 4.64158883e+01, 2.15443469e+03, 1.00000000e+05]) . . a=np.array([10,20,30]) b=np.array([1,2,3]) . a+b . array([11, 22, 33]) . a-b . array([ 9, 18, 27]) . b-a . array([ -9, -18, -27]) . a*b . array([10, 40, 90]) . a/b . array([10., 10., 10.]) . c=a**2 . c . array([100, 400, 900], dtype=int32) . idx=a&lt;20 . idx . array([ True, True, True]) . type(idx) . numpy.ndarray . a=a+1 . a . array([2, 3, 4]) . a+=1 . a . array([3, 4, 5]) . a*=2 . a . array([ 6, 8, 10]) . a=a*2 . a . array([12, 16, 20]) . a=np.array([10,50,9]) # int b=np.array([50.,5.,8.]) #float . a+=b . UFuncTypeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11512/953131135.py in &lt;module&gt; -&gt; 1 a+=b UFuncTypeError: Cannot cast ufunc &#39;add&#39; output from dtype(&#39;float64&#39;) to dtype(&#39;int32&#39;) with casting rule &#39;same_kind&#39; . a에b를 더해서 a를 업데이트 하는 건 자료형이 달라서 안 된다고 함 . 되게 하려면 자료형을 맞춰주면 됨 . c=a+b # 이건 됨 . c . array([60., 55., 17.]) . . a=np.array([10,50,9]) b=np.array([50,5,8]) . np.add(a,b) . array([60, 55, 17]) . np.subtract(a,b) . array([-40, 45, 1]) . np.divide(a,b) . array([ 0.2 , 10. , 1.125]) . np.multiply(a,b) . array([500, 250, 72]) . np.divmod(a,b) # 몫과 나머지 . (array([ 0, 10, 1], dtype=int32), array([10, 0, 1], dtype=int32)) . np.exp(b) . array([5.18470553e+21, 1.48413159e+02, 2.98095799e+03]) . np.sqrt(a) . array([3.16227766, 7.07106781, 3. ]) . . a=np.array([10,20,3]) . np.mean(a) . 11.0 . a.mean() . 11.0 . np.average(a) . 11.0 . np.average(a,weights=[1,1,1]) . 11.0 . np.average(a,weights=[1,1,0]) . 15.0 . np.average(a,weights=[0,1,1]) . 11.5 . np.median(a) . 10.0 . np.cumsum(a) # 앞에 있는 숫자들을 더해주는 것 . array([10, 30, 33], dtype=int32) . np.cov(a) . array(73.) . np.std(a) . 6.97614984548545 . np.var(a) . 48.666666666666664 . x=np.array([10,20,30]) . x.sum() . 60 . x=np.array([10.,40.,20.,5.,15.]) . x.min() . 10.0 . x.max() . 50.0 . x.argmin() # index 0에 최솟값이 존재함 . 0 . x_min,x_min_idx=x.min(),x.argmin() . # 최솟값과 최댓값의 차이 x.ptp() . 40.0 . y=np.sort(x) . y . array([ 5., 10., 15., 20., 40.]) . idx = np.argsort(x) . idx . array([3, 0, 4, 2, 1], dtype=int64) . y . array([ 5., 10., 15., 20., 40.]) . sort된 값들이 원래 어디에 위치해 있었는지 . x[idx] . array([ 5., 10., 15., 20., 40.]) . y=x[idx] . y . array([ 5., 10., 15., 20., 40.]) . a=np.array([20,10,30]) b=np.array([-5,25]) . np.searchsorted(a,b) . array([0, 2], dtype=int64) . b를 a에 넣을 때 어느 자리에 넣어야 sorting이 유지가 되는지? | . d=np.arange(1,7,1) . d . array([1, 2, 3, 4, 5, 6]) . d.shape . (6,) . d.reshape(2,3) . array([[1, 2, 3], [4, 5, 6]]) . d 자체를 바꿔주는 건 아님 | . e=d.reshape(2,3) . f=np.linspace(1,10,10) . f . array([ 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.]) . g=np.linspace(1,10,10).reshape(2,5) . g . array([[ 1., 2., 3., 4., 5.], [ 6., 7., 8., 9., 10.]]) . a=np.array([[1,2],[3,4]])#2차원 . a . array([[1, 2], [3, 4]]) . np.repeat(a,2) . array([1, 1, 2, 2, 3, 3, 4, 4]) . np.repeat(a,2,axis=0) . array([[1, 2], [1, 2], [3, 4], [3, 4]]) . np.repeat(a,2,axis=1) . array([[1, 1, 2, 2], [3, 3, 4, 4]]) . np.repeat(a,[1,2],axis=0) . array([[1, 2], [3, 4], [3, 4]]) . np.repeat(a,[3,1],axis=0) . array([[1, 2], [1, 2], [1, 2], [3, 4]]) . np.repeat(a,[1,2],axis=1) . array([[1, 2, 2], [3, 4, 4]]) . np.repeat(a,[3,1],axis=1) . array([[1, 1, 1, 2], [3, 3, 3, 4]]) . a=np.array([[1],[2],[3]]) b=np.array([[4],[5],[6]]) . a.shape . (3, 1) . b.shape . (3, 1) . np.concatenate((a,b),axis=0) # array 두개 연결 . array([[1], [2], [3], [4], [5], [6]]) . np.concatenate((a,b),axis=1) . array([[1, 4], [2, 5], [3, 6]]) . (a,b)이렇게 tuple 형태로 입력해줘야 함 | . a=np.array([10,20,30]) b=np.array([40,50,60]) . np.vstack((a,b)) . array([[10, 20, 30], [40, 50, 60]]) . np.hstack((a,b)) . array([10, 20, 30, 40, 50, 60]) . a=np.array([[10,20,30],[40,50,60]]) . a . array([[10, 20, 30], [40, 50, 60]]) . # 오류 발생, 왜? 세로 방향으로 2개로 나눌 수가 없어서 . a=np.hsplit(a,3) . a . [array([[10], [40]]), array([[20], [50]]), array([[30], [60]])] . a.shape . AttributeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_2492/1739083353.py in &lt;module&gt; -&gt; 1 a.shape AttributeError: &#39;list&#39; object has no attribute &#39;shape&#39; . 보다시피 list안에 np.array가 들어갔음 . a[0] . array([[10], [40]]) . a=np.array([[10,20,30],[40,50,60]]) . np.vsplit(a,2) . [array([[10, 20, 30]]), array([[40, 50, 60]])] . 이것또한 list로 저장 됨 . 어레이를 조각조각내서 리스트 안에 넣어줬기 때문에 . 그 조각을 살펴보면 np.array 형태이고 . 그 조각들을 list안에 넣어준 것 . a=np.array([[10,20,30],[40,50,60]]) . a . array([[10, 20, 30], [40, 50, 60]]) . a.transpose() . array([[10, 40], [20, 50], [30, 60]]) . 2차원의 array를 1차원의 array로 변경 . a . array([[10, 20, 30], [40, 50, 60]]) . a.ravel() . array([10, 20, 30, 40, 50, 60]) . a.reshape(-1) . array([10, 20, 30, 40, 50, 60]) . a.ravel(order=&#39;C&#39;) . array([10, 20, 30, 40, 50, 60]) . a.ravel(order=&#39;F&#39;) . array([10, 40, 20, 50, 30, 60]) . a.flatten() . array([10, 20, 30, 40, 50, 60]) . a=np.array([[1,2,3]]) # 2차원 형태로 넣어줌 . a_=np.array([1,2,3]) # 1차원 형태로 넣어줌 . &#52264;&#51060;&#51216; . a_[0] . 1 . a[0][0] . 1 . . a.ndim . 2 . a.shape . (1, 3) . 2차원에서 1차원으로 줄이자 . b=a.squeeze() . b . array([1, 2, 3]) . b.ndim . 1 . b.shape . (3,) . a=np.array([[[1,2]],[[3,4]],[[5,6]]]) . a . array([[[1, 2]], [[3, 4]], [[5, 6]]]) . a.shape . (3, 1, 2) . a.ndim . 3 . b=a.squeeze() . b . array([[1, 2], [3, 4], [5, 6]]) . b.shape . (3, 2) . a=np.array([1,2,3]) b=np.array([4,5,6]) . a.shape . (3,) . a_=a[:,np.newaxis] b_=b[:,np.newaxis] # 차원 하나 추가 . a_.shape . (3, 1) . np.concatenate((a_,b_),axis=0) . array([[1], [2], [3], [4], [5], [6]]) . np.concatenate((a_,b_),axis=1) . array([[1, 4], [2, 5], [3, 6]]) . np.vstack((a,b)) . array([[1, 2, 3], [4, 5, 6]]) . np.vstack((a,b)).transpose() . array([[1, 4], [2, 5], [3, 6]]) . np.hstack((a,b)).reshape((2,3)).transpose() . array([[1, 4], [2, 5], [3, 6]]) . shallow copy . deep copy . a=np.array([10,20,30]) . b=a . b . array([10, 20, 30]) . b[0]=909 . b . array([909, 20, 30]) . a . array([909, 20, 30]) . b is a . True . 즉 같은 메모리에 이름만 다르게 저장된 것 . a=np.array([1,2,3,4]) . b=a.view() . b . array([1, 2, 3, 4]) . b is a . False . b[0]=123123 . a . array([123123, 2, 3, 4]) . b . array([123123, 2, 3, 4]) . shallow copy를 했음에도 같이 업데이트 되어버림 . b.shape=(2,2) . b . array([[123123, 2], [ 3, 4]]) . b[0][1]=111 . b . array([[123123, 111], [ 3, 4]]) . a . array([123123, 111, 3, 4]) . 즉 shallow copy란 메모리 상에 data는 같이 공유하지만 array의 shape은 공유 X . 그렇다면 deep copy? . a=np.array([10,20,30,40]) . b=a.copy() . b[0]=8999 . a . array([10, 20, 30, 40]) . b . array([8999, 20, 30, 40]) . a is b . False . b.base is a . False . 즉 b만의 온전한 데이터를 만들 수 있음 . . a=np.array([55,0,12,3,4]) . # 여기선 0, 즉 FALSE값이 들어있기 때문에 FALSE로 나올 것 a.all() . False . a.any() . True . a.nonzero() . (array([0, 2, 3, 4], dtype=int64),) . np.where(a&gt;0) . (array([0, 2, 3, 4], dtype=int64),) . np.where(a==0) . (array([1], dtype=int64),) . np.where(a!=0) . (array([0, 2, 3, 4], dtype=int64),) . data filtering에 유용하게 사용될 것 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/24/intro.html",
            "relUrl": "/2021/12/24/intro.html",
            "date": " • Dec 24, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "2022/12/23/THU",
            "content": "s=&#39;&#39;&#39;python &#39;&#39;&#39; . s . &#39;python n n&#39; . print(s) . python . &#39;&#39;&#39; =&gt; 긴 str배정, 그리고 n n은 두줄이 들어갔음을 알려준 것 . s=&#39;python&#39; . s.capitalize() . &#39;Python&#39; . s.find(&#39;y&#39;) . 1 . s.find(&#39;a&#39;) . -1 . s.index(&#39;a&#39;) . ValueError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_7636/2338996384.py in &lt;module&gt; 1 # find와 유사하나 index는 없으면 -1이 아니라 error발생 -&gt; 2 s.index(&#39;a&#39;) ValueError: substring not found . index 또는 find 사용시 단어가 중복되면 처음 거 기준 출력 . a=&#39;pyathaon&#39; . a.find(&#39;a&#39;) . 2 . a.index(&#39;a&#39;) . 2 . a.isalpha() . True . s=&#39;asd3&#39; . s.isalnum() . True . a=&#39;python 3&#39; . a.isalnum() . False . a=&#39;python3&#39; . a.isalnum() . True . s=&#39;123&#39; . s.isdecimal() . True . s=&#39;223311.3&#39; . s.isdecimal() . False . s.isdigit() . False . s.isnumeric() . False . s=&#39;123123123&#39; . s.isdecimal() . True . a=&#39;2034&#39; . a.isdigit() . True . a=&#39;3 u00B3&#39; . a . &#39;3³&#39; . a.isdecimal() . False . a.isdigit() . True . a.isnumeric() . True . a=&#39; u00BC&#39; . a . &#39;¼&#39; . a.isdecimal() . False . a.isdigit() . False . a.isnumeric() . True . a=&#39;Python&#39; . a.islower() . False . a.isupper() . False . a=&#39;PythonP&#39; . 중요 . a.replace(&#39;P&#39;,&#39;Q&#39;) . &#39;QythonQ&#39; . a=&#39;I like python&#39; . 중요 . # space 기준으로 나눠서 리스트化 a.split(&#39; &#39;) . [&#39;I&#39;, &#39;like&#39;, &#39;python&#39;] . a=&#39;I,like,python&#39; . a.split(&#39;,&#39;) . [&#39;I&#39;, &#39;like&#39;, &#39;python&#39;] . str에서 다음줄로 내릴 때 . a=&#39;I like python nHe likes python nfucking python&#39; . a . &#39;I like python nHe likes python nfucking python&#39; . print(a) . I like python He likes python fucking python . a.splitlines() . [&#39;I like python&#39;, &#39;He likes python&#39;, &#39;fucking python&#39;] . b=a.splitlines() . b[0] . &#39;I like python&#39; . b[0].upper() . &#39;I LIKE PYTHON&#39; . b[0].count(&#39;L&#39;) . 0 . . s=&#39;python&#39; . a=3 . print(s,a) . python 3 . print =&gt; 문자로 알아서 프린트함 . a는 int니까 str으로 변경해서 ... . print(s,str(a)) . python 3 . print(s+str(a)) . python3 . print(s + &#39; &#39; + str(a)) . python 3 . print(s,str(a)) . python 3 . Format . s=&#39;Python {}&#39; . s.format(25) . &#39;Python 25&#39; . s.format(1+5) . &#39;Python 6&#39; . s=&#39;Python {1} + {0}&#39; . s.format(3,&#39;asdas&#39;) . &#39;Python asdas + 3&#39; . s=&#39;Python {0} {1}&#39; . s.format(3,&#39;asd&#39;) . &#39;Python 3 asd&#39; . s=&#39;Python {1} {0}&#39; . s.format(3,&#39;asd&#39;) . &#39;Python asd 3&#39; . s= &#39;My name is {} I am {} years old&#39; . s.format(&#39;asd&#39;,12) . &#39;My name is asd I am 12 years old&#39; . print(&#39;python 3.8&#39;) . python 3.8 . ver=3.8 . print(&#39;python&#39;, ver) . python 3.8 . print(&#39;python&#39; + str(ver)) . python3.8 . print(&#39;python{}&#39;.format(ver)) . python3.8 . s=&#39;python{}&#39;.format(ver) . print(s) . python3.8 . . data=4321.123456 . print(&#39;DATA&#39;+str(data)) . DATA4321.123456 . print(&#39;DATA&#39;, data) . DATA 4321.123456 . print(&#39;DATA &#39;+str(data)) . DATA 4321.123456 . print(&#39;DATA= &#39;+str(data)) . DATA= 4321.123456 . print(&#39;DATA={}&#39;.format(data)) . DATA=4321.123456 . &#51473;&#50836; . {0:&lt;10} =&gt; {0} 값을 &quot;:&lt;10&quot; 10자리로 표현할건데 왼쪽 정렬 | {1:&gt;5} =&gt; {1} 값을 &quot;:&gt;5&quot; 5자리로 표현할건데 오른쪽 정렬 | :^10 = 가운데 정렬 | . print(&#39;DATA= {:.2f}&#39;.format(data)) . DATA= 4321.12 . print(&#39;DATA= {:.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:4.0f}&#39;.format(data)) . DATA=4321 . print(&#39;DATA={:5.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:6.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:7.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:,}&#39;.format(data)) . DATA=4,321.123456 . data2=454654456.1213546 . print(&#39;DATA={:,}&#39;.format(data2)) . DATA=454,654,456.1213546 . data자체가 float이라서 d입력하면 오류가 발생 . print(&#39;DATA={:.4d}&#39;.format(int(data))) . ValueError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_7636/488746504.py in &lt;module&gt; -&gt; 1 print(&#39;DATA={:.4d}&#39;.format(int(data))) ValueError: Precision not allowed in integer format specifier . int는 .없으니까 .4d이렇게 입력하면 오류 . print(&#39;DATA={:4d}&#39;.format(int(data))) . DATA=4321 . print(&#39;DATA={:5d}&#39;.format(int(data))) . DATA= 4321 . print(&#39;DATA={:8d}&#39;.format(int(data))) . DATA= 4321 . scientific notation :e라는 것을 사용하여 수를 표현해줌 . print(&#39;data = {:e}&#39;.format(data)) . data = 4.321123e+03 . print(&#39;DATA=%(x)f&#39; % {&#39;x&#39; : data}) . DATA=4321.123456 . print(&#39;DATA=%(x).0f&#39; % {&#39;x&#39; : data}) . DATA=4321 . print(&#39;DATA=%(x).2f&#39; % {&#39;x&#39; : data}) . DATA=4321.12 . print(&#39;DATA=%(x)7.0f&#39; % {&#39;x&#39; : data}) . DATA= 4321 . print(&#39;DATA=%(x)8.3f&#39; % {&#39;x&#39; : data}) . DATA=4321.123 . print(&#39;DATA=%(x)8.0f&#39; % {&#39;x&#39; : data}) . DATA= 4321 . . import math . math.pi . 3.141592653589793 . math.inf . inf . math.nan #숫자가 아님을 표현할 때 . nan . math.e . 2.718281828459045 . math.floor(math.pi) . 3 . math.ceil(math.pi) . 4 . math.sqrt(math.pi) . 1.7724538509055159 . math.log(10) . 2.302585092994046 . math.log(math.e) . 1.0 . math.log10(10) . 1.0 . p=math.pi . math.sin(p/2) . 1.0 . math.sin(2*p) . -2.4492935982947064e-16 . x_degree=90 . x_radian=x_degree*(math.pi/180) . x_radian #pi/2랑 동일 . 1.5707963267948966 . math.radians(90) . 1.5707963267948966 . math.pow(2,3) . 8.0 . pow(2,3) . 8 . 2**3 . 8 . x=2 . math.isinf(x) . False . math.isnan(x) . False . math.fsum([1,2,3]) . 6.0 . math.fsum([1,2,&#39;3&#39;]) . TypeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_7636/3003999967.py in &lt;module&gt; -&gt; 1 math.fsum([1,2,&#39;3&#39;]) TypeError: must be real number, not str . int여야 함 . . file// input output . import os . os.getcwd() . &#39;c: &#39; . os.chdir(&#39;c: test&#39;) . os.mkdir(&#39;temp2&#39;) . os.chdir(&#39;temp2&#39;) . os.getcwd() . &#39;c: test temp2&#39; . os.chdir(&#39;..&#39;) . os.getcwd() . &#39;c: test&#39; . os.chdir(&#39;temp&#39;) . os.getcwd() . &#39;c: test temp&#39; . os.chdir(&#39;.&#39;) . os.getcwd() . &#39;c: test temp&#39; . os.mkdir(&#39;dir0&#39;) . os.mkdir(&#39;dir1&#39;) . os.mkdir(&#39;dir2&#39;) . os.getcwd() . &#39;c: test temp&#39; . os.listdir() . [&#39;dir0&#39;, &#39;dir1&#39;, &#39;dir2&#39;, &#39;file1.txt&#39;, &#39;file2.txt&#39;, &#39;file3.txt&#39;, &#39;file4.txt&#39;] . os.rename(&#39;dir0&#39;,&#39;dir100&#39;) . os.listdir() . [&#39;dir1&#39;, &#39;dir100&#39;, &#39;dir2&#39;, &#39;file1.txt&#39;, &#39;file2.txt&#39;, &#39;file3.txt&#39;, &#39;file4.txt&#39;] . os.rmdir(&#39;dir100&#39;) . os.listdir() . [&#39;dir1&#39;, &#39;dir2&#39;, &#39;file1.txt&#39;, &#39;file2.txt&#39;, &#39;file3.txt&#39;, &#39;file4.txt&#39;] . import sys . # 파이썬에서 사용가능한 모듈들을 불러준 것 . # sys.path . os.chdir(&#39;C: Users ehfus Downloads python Introduction&#39;) . os.chdir(&#39;c: test temp&#39;) . os.getcwd() . &#39;c: test temp&#39; . . f=open(&#39;file1.txt&#39;,&#39;w&#39;)#파일 작성 . f.closed . False . f.write(&#39;fucking&#39;) . 7 . f.close() . f.closed . True . with open(&#39;file2.txt&#39;,&#39;w&#39;) as f: f.write(&#39;sibal n&#39;) f.write(&#39;jotgatne n&#39;) f.write(&#39;just joke n&#39;) . f.closed . True . fid=open(&#39;file2.txt&#39;,&#39;r&#39;) . fid.read() . &#39;sibal njotgatne njust joke n&#39; . fid.close() . fid.closed . True . fid=open(&#39;file2.txt&#39;,&#39;r&#39;) . fid.readline() . &#39;sibal n&#39; . fid.readline() . &#39;jotgatne n&#39; . fid.readline() . &#39;just joke n&#39; . fid.readline() . &#39;&#39; . 한 줄씩 불러옴 . fid.close() . fid=open(&#39;file2.txt&#39;,&#39;r&#39;) . data=[] . data.append(fid.readline()) . data.append(fid.readline()) . data.append(fid.readline()) . data . [&#39;sibal n&#39;, &#39;jotgatne n&#39;, &#39;just joke n&#39;] . 자동화 . fid=open(&#39;file2.txt&#39;,&#39;r&#39;) . for line in fid: line . data=[&#39;string1&#39;,&#39;string2&#39;,&#39;string3&#39;] . import json . f=open(&#39;file3.txt&#39;,&#39;w&#39;) . json.dump(data,f) . f.close() . f=open(&#39;file3.txt&#39;,&#39;r&#39;) . x=json.load(f) . x . [&#39;string1&#39;, &#39;string2&#39;, &#39;string3&#39;] . f.close() . import pickle . f=open(&#39;file4.txt&#39;,&#39;wb&#39;) # 바이너리로 쓰겠다 . 용량을 작게 할 수 있다는 장점이 있음 . pickle.dump(data,f) . f.close() . f=open(&#39;file4.txt&#39;,&#39;rb&#39;) # 바이너리 불러옴 . x= pickle.load(f) . x . [&#39;string1&#39;, &#39;string2&#39;, &#39;string3&#39;] . f.close() .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/23/intro.html",
            "relUrl": "/2021/12/23/intro.html",
            "date": " • Dec 23, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "2021/12/22/Wed",
            "content": "&#51088;&#47308;&#54805; . 정수(int) | . 1 . 1 . 소수(float) | . 1.2 . 1.2 . 복소수(complex) | . 1.2+2j . (1.2+2j) . 문자형(str) &gt; 따옴표 하나 혹은 두개 가능 | . &#39;a&#39;,&quot;hello&quot; . (&#39;a&#39;, &#39;hello&#39;) . 참, 거짓형(bool) | . True . True . . 자료의 형태를 알고 싶을 때 | . type(True) . bool . . 자료형 변환 | . int() . 0 . str() . &#39;&#39; . bool() . False . int(1) . 1 . int(1.3) . 1 . int(1.8) . 1 . int(&#39;1&#39;) # str -&gt; int . 1 . float(&#39;3.14&#39;) # sre -&gt; float . 3.14 . 그런데 &#39;3.14&#39;이 str형태를 int로 변환할 순 없음 . float(&#39;-inf&#39;) . -inf . complex(1) . (1+0j) . complex(3+5j) . (3+5j) . complex(3,5.5) . (3+5.5j) . complex(&#39;1+3j&#39;) . (1+3j) . str(1) . &#39;1&#39; . str(2+5j) . &#39;(2+5j)&#39; . str(&quot;asdasdas&quot;) . &#39;asdasdas&#39; . bool(1) . True . bool(0) . False . bool(23123) . True . 0이 아닌 다른 수는 모두 True . bool(float(&#39;inf&#39;)) . True . float(&#39;inf&#39;),bool(&#39;-inf&#39;),complex(&#39;inf&#39;) . (inf, True, (inf+0j)) . bool(-0.8) . True . bool(&#39;&#39;) . False . bool(&#39;aasdss&#39;) . True . &#50672;&#49328; . 1+1,3-2,5*2,5/2 . (2, 1, 10, 2.5) . 5//2 . 2 . 5%2 . 1 . abs(-232) . 232 . divmod(5,3) . (1, 2) . pow(5,4),5**4 . (625, 625) . 2+1*5 . 7 . &#39;asdasd&#39;+&#39;asdfeq&#39; . &#39;asdasdasdfeq&#39; . &#39;asdasd&#39;+str(235456) . &#39;asdasd235456&#39; . # &#39;asdasd&#39;+2 . True+True . 2 . &#48708;&#44368; &#50672;&#49328; =&gt; &#44208;&#44284;&#45716; BOOL&#54805;&#53468;&#47196; &#52636;&#47141;&#46120; . 1&lt;0 . False . 2==3 . False . 틀린 지 물어보기 . 1!=3 # 틀렸으니 맞다고 나올 것 . True . 3 is 4 . &lt;&gt;:1: SyntaxWarning: &#34;is&#34; with a literal. Did you mean &#34;==&#34;? &lt;&gt;:1: SyntaxWarning: &#34;is&#34; with a literal. Did you mean &#34;==&#34;? C: Users ehfus AppData Local Temp/ipykernel_4876/1052624616.py:1: SyntaxWarning: &#34;is&#34; with a literal. Did you mean &#34;==&#34;? 3 is 4 . False . 그런데 is나 is not은 원래 자료형 비교할 때 사용함 . type(&#39;123&#39;) is not type(True) . True . True and False . False . True and False and True . False . 즉 거짓이 하나라도 있으면 거짓 처리 . True or False . True . True or False or False . True . 즉 참이 하나라도 있으면 참 처리 . not True . False . 참과 거짓을 반대로 바꿔주는 기능 . 100 and 1 # 둘다 참 -&gt; 참 처리 . 1 . 0 and 100 # 하나 거짓 -&gt; 거짓 처리 . 0 . 1 and 100 # 둘다 참 -&gt; 100 출력 # 100 and 1 일 땐 1 출력 . 100 . 100 or 1 # 둘다 참 -&gt; 100 출력 . 100 . 1 and 0 and 100 . 0 . 1 and 10 and 100 . 100 . 1 and 10 and 2 . 2 . 1 and 2 or 100 . 2 . 1 or 3 and 100 . 1 . 1 or 3 or 100 . 1 . 10 or 1 . 10 . Bitwise . 2 #십진법 . 2 . bin(2) # 이진법 . &#39;0b10&#39; . bin(3) . &#39;0b11&#39; . bin(12) . &#39;0b1100&#39; . bin(6) . &#39;0b110&#39; . ??? &amp; . 10&amp;6 . 2 . bin(10) . &#39;0b1010&#39; . bin(6) . &#39;0b110&#39; . bin(10&amp;6) . &#39;0b10&#39; . bin(10|6) . &#39;0b1110&#39; . bin(10^6) . &#39;0b1100&#39; . 10^6 . 12 . bin(6&lt;&lt;2) . &#39;0b11000&#39; . bin(6&gt;&gt;2) . &#39;0b1&#39; . 6&gt;&gt;2 . 1 . &#48320;&#49688; . a=1 a . 1 . print(a) . 1 . b=3.225 . type(b) . float . b=546548 . b # b의 정의가 업데이트 . 546548 . d=True . print(d) . True . b=a . b # 다른 변수로 해당 변수를 업데이트 할 수 있음 . 1 . a=5 . a . 5 . b . 1 . a가 바뀌어도 a로 업데이트 된 b는 그 전 a의 자료인 1로 그대로 유지 중 . length=2 width=3 area=length*width . x=1 . y=2*x . y . 2 . a=3 . bin(a) . &#39;0b11&#39; . a.bit_length() . 2 . b=10 . bin(b) . &#39;0b1010&#39; . b.bit_length() . 4 . c=1+2j . c.conjugate() . (1-2j) . c.real # c 안의 실수 . 1.0 . c.imag # c 안의 허수 . 0 . a=1 . a+=1 # a에 있는 값을 1만큼 올려서 저장 . a . 2 . a-=10 . a . -8 . name=&#39;tom&#39; . name.capitalize() # 맨 앞을 대문자 처리 . &#39;Tom&#39; . name.count(&#39;2&#39;) #name이라는 변수에 2 몇개?, 대문자 소문자도 구별해서 카운트함 . 0 . name.split(&#39;o&#39;) # o 없애고 나눠줌 # 리스트 형태로 저장됨 . [&#39;t&#39;, &#39;m&#39;] . &#39;asdasd&#39;.capitalize() . &#39;Asdasd&#39; . a=&#39;i &#39;m student&#39; . a . &#34;i&#39;m student&#34; . 즉 백 슬러시 다음에 심볼 적으면 심볼로 인식하게 됨 . a=&#39;ASDASD&#39; . a*3 . &#39;ASDASDASDASDASDASD&#39; . input을 유저한테 받아올 때 . input(&#39;enter: &#39;) . &#39;3&#39; . a=input(&#39;enter: &#39;) . a # str으로 저장됨 . &#39;3&#39; . age=int(input(&#39;enter your age: &#39;)) . age # int로 저장됨 . 23 . 변수 지우기 . del age . a=1 b=3 a==b . False . a.__eq__(b) # a==b랑 동일 . False . a,b=10,134 . a와 b 교환 . a,b=b,a . . str=1 . str(1.3) . TypeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11492/930539355.py in &lt;module&gt; -&gt; 1 str(1.3) TypeError: &#39;int&#39; object is not callable . 즉 파이썬과 지원되는 함수와 동일한 변수명 사용하면 안 됨 . Container . list. tuple. set. frozenset. dictionary. . list &#49688;&#51221; &#44032;&#45733; . asd=[10,25,&#39;123&#39;,True] # 방법 1 . asdasd=list([10,25,&#39;123&#39;,True]) # 방법 2 . tuple &#49688;&#51221; &#48520;&#44032;&#45733; . qwe=(12,22.1,&#39;qwe&#39;) . qwe . (12, 22.1, &#39;qwe&#39;) . qweqwe=tuple([1,2,3,&#39;asdasd&#39;,True]) . qweqwe . (1, 2, 3, &#39;asdasd&#39;, True) . 자료 불러오기 . asd[0] . 10 . qwe[0] . 12 . list와 tuple은 sequence자료형 . vip_names = [&#39;c&#39;,&#39;d&#39;,&#39;a&#39;] . vip_names[0]=&#39;랴차&#39; . vip_names . [&#39;랴차&#39;, &#39;d&#39;, &#39;a&#39;] . list는 자료 수정이 가능하나 . tuple은 자료 수정 불가능하다 . my_list1=[12,123,123,123,42,14] . slicing . my_list1[0:2] #0,1번 원소 추출 . [12, 123] . my_list1[:] # 모든 자료 . [12, 123, 123, 123, 42, 14] . my_list1[::2] # 모든 자료형태에서 2단위로 추출 . [12, 123, 42] . my_list1[:3:2] # 0,1,2원소를 2단위로 추출 . [12, 123] . my_list1[::2] . [12, 123, 42] . my_list1[-1] . 14 . my_list1[-5:-1] # -1값은 해당 X . [123, 123, 123, 42] . my_list1[-5] . 123 . my_list1[-1::-1] # 뒤에서부터 가져올 땐 단위도 - 붙여줘야 함 . [14, 42, 123, 123, 123, 12] . my_list1[-1:2:-1] # 두번째 인덱스 전까지 뒤로 추출 . [14, 42, 123] . my_list1[-1:1:-1] # 뒤에서부터 가져오기 뒤로 . [14, 42, 123, 123] . my_list1[-4:5:1] # 뒤에서부터 가져오기 . [123, 123, 42] . ::1,::-1 즉 플러스면 앞으로 가며 읽어주고 마이너스면 뒤로 가면서 읽어줌 . 리스트 중첩 가능 . my_list2 = [[1,2,3,4,5],[1232]] . my_list4 = [[1,2,3,4,5], [1,2,3,4], &quot;ㅁㄴㅇㅁㄴㅇ&quot;] # 이렇게 복잡할 땐 한줄 내려서 입력해도 가능하다 . my_list4[0][3] . 4 . my_list4[1][::2] . [1, 3] . my_list5 = [ [10,20,[100,200,300]], [40,50,60] ] . my_list5[0][2][2] # 리스트 중첩 후 원소 불러오기 . 300 . a=[1,2] b=[123,2323] . a+b . [1, 2, 123, 2323] . 리스트의 덧셈은 그냥 자료룰 연결함 . a=[[1,2],[1,2,3]] . b=[[1,2,&#39;s&#39;],[1,2,3]] . a+b . [[1, 2], [1, 2, 3], [1, 2, &#39;s&#39;], [1, 2, 3]] . 리스트에서 연산은 더해주는 것이기 때문에 -는 지원 . 곱셈은 지원 가능 . a*2 . [[1, 2], [1, 2, 3], [1, 2], [1, 2, 3]] . old_a=[1,2,3] . new_a=old_a . old_a[0]=2 . new_a[0] . 2 . 즉 new_a=old_a 같은 메모리를 공유함으로써 new_a 와 old_a 모두 동시 수정됨 . 대책은? . new_a=old_a.copy() . new_a[0]=&#39;1&#39; . new_a . [&#39;1&#39;, 2, 3] . old_a . [2, 2, 3] . 이렇게 안 바뀜을 알 수 있다 . extend . a=[1,2,3] b=[2,3,4] . a.extend(b) . a . [1, 2, 3, 2, 3, 4] . extend와 똑같은 기능들 . a=a+b . a . [1, 2, 3, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4] . a+=b . a . [1, 2, 3, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4] . asd=[&#39;asds&#39;,&#39;sdasd&#39;,&#39;sd&#39;] . 이 자료에 원소 추가하기 . asd.append(&#39;e&#39;) . asd . [&#39;asds&#39;, &#39;sdasd&#39;, &#39;sd&#39;, &#39;e&#39;] . asd.remove(&#39;e&#39;) . asd . [&#39;asds&#39;, &#39;sdasd&#39;, &#39;sd&#39;] . 인덱스로 원소 지우기 -&gt; pop사용 . asd.pop(1) . &#39;sd&#39; . asd . [&#39;asds&#39;] . 초기화 . asd.clear() . asd . [] . asd.insert(0,&#39;sds&#39;) . asd . [&#39;sds&#39;] . insert 함수 사용할 때 5자리에 넣고 싶어도 마지막 자리에 순서대로 추가 됨 . asd.index(&#39;sds&#39;) # 자리 번호 알기 . 0 . asd.count(&#39;sds&#39;) # 몇번 들어가 있는지 . 1 . a=[&#39;a&#39;,&#39;c&#39;,&#39;f&#39;,&#39;b&#39;] . a.sort() . a # 숫자와, bool도 정렬가능 . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;f&#39;] . a=[2,&#39;False&#39;] . a.sort() # 이렇게 자료형이 섞여있으면 불가능 . TypeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11492/873731035.py in &lt;module&gt; -&gt; 1 a.sort() # 이렇게 자료형이 섞여있으면 불가능 TypeError: &#39;&lt;&#39; not supported between instances of &#39;str&#39; and &#39;int&#39; . asf=[True,123333,0,134] . asf.sort() . asf # 자료형이 안 섞여있으면 가능 . [0, True, 134, 123333] . qwe=[1,2,3] . qwe.reverse() . qwe . [3, 2, 1] . qwe[-1::-1] # reverse와 동일 . [1, 2, 3] . data=[[&#39;s&#39;,23], [&#39;asd&#39;,2344]] . . my_set1={1,2,3} . my_set2={False,5,54} . my_set3={False,5,5} . my_set3 . {False, 5} . 즉 중복은 하나로 처리함 . set은 인덱스를 지원하지 않음 . alist=[2,3,4,1324] . my_set32412=set(alist) . my_set32412 . {2, 3, 4, 1324} . b=set() . b . set() . my_set32412.add(2525) . my_set32412 . {2, 3, 4, 1324, 2525} . my_set32412.update([1]) . my_set32412 . {1, 2, 3, 4, 1324, 2525} . my_set32412.discard(1324) . my_set32412 . {1, 2, 3, 4, 2525} . my_set32412.remove(2525) . my_set32412 . {1, 2, 3, 4} . 즉 discard와 remove는 동일하나 remove는 이미 없는 값을 또 삭제하려 할 때 error메세지를 보여줌 . a={1,2,3,5} b={6,5,55,4} . a or b . {1, 2, 3, 5} . b or a . {4, 5, 6, 55} . a|b . {1, 2, 3, 4, 5, 6, 55} . a.union(b) . {1, 2, 3, 4, 5, 6, 55} . b.union(a) . {1, 2, 3, 4, 5, 6, 55} . a&amp;b # 교집합 . {5} . a.intersection(b) . {5} . b.intersection(a) . {5} . a-b . {1, 2, 3} . a.difference(b) . {1, 2, 3} . b.difference(a) . {4, 6, 55} . a^b # 겹치는 거 빼고 출력 . {1, 2, 3, 4, 6, 55} . a.symmetric_difference(b) ## 겹치는 거 빼고 출력 . {1, 2, 3, 4, 6, 55} . b.symmetric_difference(a) # 겹치는 거 빼고 출력 . {1, 2, 3, 4, 6, 55} . a={1,2,3,4,5} b={1} . b.issubset(a) #b에 있는 값이 a에 있니 . True . a.issubset(b) # a에 있는 값이 b에 있니 . False . a.issuperset(b) #b에 있는 값이 a에 있니 . True . b.issuperset(a)# a에 있는 값이 b에 있니 . False . . a=frozenset([1,2,3,4,5]) . b=frozenset([4,5,6,7,8]) . a|b . frozenset({1, 2, 3, 4, 5, 6, 7, 8}) . a&amp;b . frozenset({4, 5}) . a.add(100) # 추가 불가 . AttributeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11492/4216742371.py in &lt;module&gt; -&gt; 1 a.add(100) # 추가 불가 AttributeError: &#39;frozenset&#39; object has no attribute &#39;add&#39; . c=set([1,2,3,4]) . a&amp;c . frozenset({1, 2, 3, 4}) . asq=[&#39;qw&#39;,&#39;qwa&#39;,&#39;qwsd&#39;] . door1_list = [&#39;qw&#39;] . door2_list = [&#39;qwa&#39;] . door1_list in asq . False . 왜 false? . door1_list[0] in asq . True . all=set(asq) . all . {&#39;qw&#39;, &#39;qwa&#39;, &#39;qwsd&#39;} . d1=set(door1_list) . d2=set(door2_list) . d1.issubset(all) . True . d2.issubset(all) . True . d_combine=d1 |d2 . d_combine . {&#39;qw&#39;, &#39;qwa&#39;} . d_combine.issubset(all) . True . all-d_combine . {&#39;qwsd&#39;} . door_list = [&#39;zxc&#39;,&#39;zxzx&#39;] . door_list2 = [&#39;zxcs&#39;,&#39;zsxzx&#39;] . d=set(door_list) . d2=set(door_list2) . combined=d1|d2 . combined.issubset(all) . False . all . {&#39;qw&#39;, &#39;qwa&#39;, &#39;qwsd&#39;} . dic =&gt; key,value로 이루어져있다 . my_dict={&#39;a&#39;:&#39;qewqwe&#39;,&#39;b&#39;:&#39;qewe&#39;,&#39;c&#39;:&#39;qwqwe&#39;} . my_dict[&#39;c&#39;] . &#39;qwqwe&#39; . 즉 따라서 순서는 중요하지 않음 . number={&#39;1&#39;:&#39;12312123123&#39;,&#39;asas&#39;:&#39;12313&#39;,&#39;asdad&#39;:&#39;12323&#39;} . number[&#39;asas&#39;] . &#39;12313&#39; . number.get(&#39;asas&#39;) . &#39;12313&#39; . number[&#39;asas&#39;]=&#39;fucking&#39; # 자료 업데이트 . number.update({&#39;1&#39;:&#39;asdasdddd&#39;}) # 자료 업데이트 . number[&#39;1&#39;] . &#39;asdasdddd&#39; . &#39;1&#39; in number # key가 들어가있는지 안 들어가 있는지 . True . number.pop(&#39;1&#39;) # 삭제 . &#39;asdasdddd&#39; . number . {&#39;asas&#39;: &#39;fucking&#39;, &#39;asdad&#39;: &#39;12323&#39;} . number.clear() . number . {} . . alist=[1,2,3,4,5] atuple=(1,2,3,4,5) aset={1,2,3,4,5} . len(alist) # 컨테이너의 값 개수를 알 수 있음 . 5 . len =&gt; comtainer에 사용 . max(aset) . 5 . min(alist) . 1 . 6 in atuple # 값 들어가있는지 체크하기 . False . flag= 6 in atuple . flag2= 555 not in atuple . flag2 . True . . list unpacking . a=[&#39;a&#39;,23,&#39;asf&#39;] . name=a[0] . age=a[1] . lan=a[2] . 이걸 한 번에 = list unpacking . name,age,lan=a . 리스트 a에서 처음 원소만 자료로 받고 나머지는 그에 헤당한 자료형으로 남겨놓고 싶을 때 . name, *remain=a . 응용하면 . *rest,name=a . name . &#39;asf&#39; . 더 응용하면 . first,second,*rest=a . . a=range(0,21,2) # 20까지임 . a . range(0, 21, 2) . 20 in a . True . a.index(20) . 10 . a[10] . 20 . a . range(0, 21, 2) . a[:5] . range(0, 10, 2) . a[-1] . 20 . list(range(10,51,10)) . [10, 20, 30, 40, 50] . . for i in range(5) : print(i) . 0 1 2 3 4 . for i in range(2,11,2) : print(i) . 2 4 6 8 10 . for i in range(10,2,-2) : print(i) . 10 8 6 4 . for i in range(10,1,-2) : print(i) . 10 8 6 4 2 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/22/intro.html",
            "relUrl": "/2021/12/22/intro.html",
            "date": " • Dec 22, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://rhkrehtjd.github.io/INTROpython/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://rhkrehtjd.github.io/INTROpython/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}
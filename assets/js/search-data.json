{
  
    
        "post0": {
            "title": "2021/12/27/MON",
            "content": "import numpy as np x_list=[1,2,3] x_tuple=1,2,3 x_set={1,2,3} x_dict={&#39;a&#39; : 1,&#39;b&#39; : 2,&#39;c&#39; : 3} x_array=np.array([1,2,3]) x_range=range(1,4,1) . for i in x_dict: print(i) . a b c . key만 나왔음, 후에 부가 설명하겠음 | . i=1 print(i) . 1 . i=2 print(i) . 2 . i=3 print(i) . 3 . 이걸 계속? . for i in [1,2,3]: print(i) . 1 2 3 . i . 3 . import time for i in [1,2,3]: print(&#39;i=&#39; + str(i)) time.sleep(1) . i=1 i=2 i=3 . 이때 i는 마지막 값인 3으로 저장될 것 | . . 1부터 100까지 = range(1,100,1) . range(101)은 0부터 100까지임 . 또는 np.linspace(1,100,100)으로도 사용가능 . . iterable object이 str일 땐? . for i in &#39;12345&#39;: print(i) . 1 2 3 4 5 . i . &#39;5&#39; . for i in &#39;python&#39;: print(i) . p y t h o n . for i in {1,2,3,4,5}: print(i) . 1 2 3 4 5 . d={&#39;P1&#39;:11,&#39;P3&#39;:31,&#39;P2&#39;:13} . d.items() . dict_items([(&#39;P1&#39;, 11), (&#39;P3&#39;, 31), (&#39;P2&#39;, 13)]) . d.keys() . dict_keys([&#39;P1&#39;, &#39;P3&#39;, &#39;P2&#39;]) . d.values() . dict_values([11, 31, 13]) . for i in d.items(): print(i) . (&#39;P1&#39;, 11) (&#39;P3&#39;, 31) (&#39;P2&#39;, 13) . i . (&#39;P2&#39;, 13) . for i in d.keys(): print(i) . P1 P3 P2 . for i in d.values(): print(i) . 11 31 13 . . for i in np.array([1,2,3]): print(i) . 1 2 3 . i . 3 . . &#48152;&#48373;&#47928; &#51473;&#52393; . for i in range(1,4,1): for j in [1,2]: print(&#39;i*j={}*{}={}&#39;.format(i,j,i*j)) . i*j=1*1=1 i*j=1*2=2 i*j=2*1=2 i*j=2*2=4 i*j=3*1=3 i*j=3*2=6 . . 반복문은 iterable일 때 사용가능 . 그렇다면 iterable?? . x_list=[1,2,3] . x_iter=iter(x_list) . next(x_iter) # 하나하나 차례로 나올 것, 그리고 마지막엔 오류 . &#39;c&#39; . x_str=&#39;abc&#39; x_iter=iter(x_str) . next(x_iter) # 하나하나 차례로 나올 것, 그리고 마지막엔 오류 . &#39;a&#39; . 값을 하나씩 불러온다는 것만 알아두자 . . for i in range(3): print(&#39;여긴 적용 O&#39;) print(&#39;--&#39;) print(&#39;여긴 적용 X&#39;) . 여긴 적용 O 여긴 적용 O 여긴 적용 O -- 여긴 적용 X . . m=np.array([1,2,3]) n=[&#39;sd&#39;,&#39;asd&#39;,&#39;asdd&#39;] q={&#39;a&#39;:11,&#39;d&#39;:22,&#39;c&#39;:123} . for i,v in enumerate(m): print(i) print(v) print(&#39; &#39;) ## i,v는 아무이름이나 가능 . 0 1 1 2 2 3 . for i,v in enumerate(q.items()): print(i) print(v) print(&#39; &#39;) ## i,v는 아무이름이나 가능 . 0 (&#39;a&#39;, 11) 1 (&#39;d&#39;, 22) 2 (&#39;c&#39;, 123) . 반복문이 몇번 돌아갔는지? | . 인덱스를 1부터 시작하게 해서 count할 수 있음 | . for i,v in enumerate(m,start=1): print(i) print(v) print(&#39; &#39;) ## i,v는 아무이름이나 가능 . 1 1 2 2 3 3 . . for i in zip(m,n): print(i) . (1, &#39;sd&#39;) (2, &#39;asd&#39;) (3, &#39;asdd&#39;) . 두 개의 container자료를 불러온 것 . list로 불러올 수 있음 . for i in zip(m,n): print(list(i)) . [1, &#39;sd&#39;] [2, &#39;asd&#39;] [3, &#39;asdd&#39;] . for i in zip(m,n,q.items()): print(list(i)) . [1, &#39;sd&#39;, (&#39;a&#39;, 11)] [2, &#39;asd&#39;, (&#39;d&#39;, 22)] [3, &#39;asdd&#39;, (&#39;c&#39;, 123)] . . 반복문 활용 예시 . s=&#39;♡Best Company♡ Tel: 123-123123&#39; for i in range(5): print(s) print(&#39; &#39;) . ♡Best Company♡ Tel: 123-123123 ♡Best Company♡ Tel: 123-123123 ♡Best Company♡ Tel: 123-123123 ♡Best Company♡ Tel: 123-123123 ♡Best Company♡ Tel: 123-123123 . a=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] for i in a: print(&#39;Name : &#39; + i) print(&#39;오잉?&#39;) print(&#39;&#39;) . Name : a 오잉? Name : b 오잉? Name : c 오잉? . x=np.array([1,2,3,4,5]) for i in x: print(i**2) time.sleep(0.5) . 1 4 9 16 25 . x=np.array([1,2,3,4,5]) for i,x in enumerate(x): print(i) print(x) print(&#39;&#39;) . 0 1 1 2 2 3 3 4 4 5 . x=np.array([1,2,3,4,5]) y=np.zeros(x.shape) for i,x in enumerate(x): y[i]=x**2 print(y) . [1. 0. 0. 0. 0.] [1. 4. 0. 0. 0.] [1. 4. 9. 0. 0.] [ 1. 4. 9. 16. 0.] [ 1. 4. 9. 16. 25.] . . a=np.array([1,2,3,]) y=a**2 . y . array([1, 4, 9], dtype=int32) . 이렇게 해결할 수 있는 걸 굳이 반복문 사용할 필요는 없음 | . . 피보나치 수열 :앞에 숫자를 계속 더해주는$ dots$ . a=np.array([0,1]) for i in range(3): a=np.append(a,a[-1]+a[-2]) print(a) . [0 1 1] [0 1 1 2] [0 1 1 2 3] . . a,b=0,1 for i in range(10): print(a) a,b=b,a+b . 0 1 1 2 3 5 8 13 21 34 . 피보나치 수열을 이렇게 표현할 수도 있음 | . . ***&#51312;&#44148;&#47928; . x=input(&#39;Type any number: &#39;) if x.isdigit(): y=int(x)+1 print(&#39;Result is {}&#39;.format(y)) else : print(&#39;정수 쳐 넣어&#39;) . 정수 쳐 넣어 . 첫번째 줄에서 입력되는 것이 숫자인지 문자인지? $ to$ isdigit을 이용!! | . x=input(&#39;Type any number: &#39;) while x.isdigit() != True : x=input(&#39;Try again: &#39;) y=int(x)+1 print(&#39;Result is {}&#39;.format(y)) . Result is 6 . while문 =&gt; 무한 반복 . x=int(input(&#39;몇살이니? : &#39;)) if x&gt;=18 : print(&#39;면허 딸 수 있겠다&#39;) elif x&gt;=15 &amp; x&lt;18 : print(&#39;승인은 가능하겠다&#39;) else : print(&#39;나이가 어려서 안 돼&#39;) . 면허 딸 수 있겠다 . x=int(input(&#39;몇살이니? : &#39;)) if x&gt;=18 : print(&#39;면허 딸 수 있겠다&#39;) elif x&gt;=15 &amp; x&lt;18 : print(&#39;승인은 가능하겠다&#39;) else : print(&#39;나이가 어려서 안 돼&#39;) . 승인은 가능하겠다 . x=int(input(&#39;몇살이니? : &#39;)) if x&gt;=18 : print(&#39;면허 딸 수 있겠다&#39;) elif x&gt;=15 and x&lt;18 : print(&#39;승인은 가능하겠다&#39;) else : print(&#39;나이가 어려서 안 돼&#39;) . 나이가 어려서 안 돼 . &#44536;&#47088;&#45936; and &#45824;&#49888;&#50640; &amp; &#49324;&#50857;&#54616;&#47732; &#50504; &#46120; . 알아보기 . . a=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;] check=input(&#39;please name: &#39;) if check in a : print(&#39;어서와&#39; +&quot; &quot; + check+&#39;야&#39;) else : print(&#39;넌 명단에 없네&#39;) . 넌 명단에 없네 . . While . vip=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;] a=[1,2] a_=[] . bool(a) . True . bool(a_) . False . while은 참일때만 실행하니까 vip리스트에 하나도 없으면, 즉 FALSE이면 실행 멈출 것 . while vip: print(vip.pop(0)) print(&#39;remaining guest #: {}&#39;.format(len(vip))) . a remaining guest #: 3 b remaining guest #: 2 c remaining guest #: 1 d remaining guest #: 0 . . pop(인덱스), 즉 해당 인덱스값 삭제 . pop =&gt; 튕겨버림 =&gt; 버려버림 . . balance=10000 # 가지고 있는 돈 interest=0.05 # 이자율 yr=0 # 시작 연도 # 통장에 10000원 넣어놓고 몇년이 지나야 20000원이 될까? . while balance &lt; 20000: balance=balance*(1+interest) yr+=1 print(&#39;# of Year : {}&#39;.format(yr)) print(&#39;Current values= {}&#39;.format(balance)) . # of Year : 1 Current values= 10500.0 # of Year : 2 Current values= 11025.0 # of Year : 3 Current values= 11576.25 # of Year : 4 Current values= 12155.0625 # of Year : 5 Current values= 12762.815625000001 # of Year : 6 Current values= 13400.956406250001 # of Year : 7 Current values= 14071.004226562502 # of Year : 8 Current values= 14774.554437890627 # of Year : 9 Current values= 15513.28215978516 # of Year : 10 Current values= 16288.946267774418 # of Year : 11 Current values= 17103.393581163138 # of Year : 12 Current values= 17958.563260221297 # of Year : 13 Current values= 18856.491423232364 # of Year : 14 Current values= 19799.315994393983 # of Year : 15 Current values= 20789.281794113682 . . 즉 15년까지 while이 진행됐다는 건 15년째 20000을 넘었기 때문에 다음 16이 진행 안 된 것 , . 따라서 15년때 20000을 넘은 것을 알 수 있음 . . for i in range(5): print(i) if i ==3 : break . 0 1 2 3 . balance=10000 # 가지고 있는 돈 interest=0.05 # 이자율 yr=0 # 시작 연도 for i in range(10000): balance=balance*(1+interest) yr+=1 print(&#39;# of Year : {}&#39;.format(yr)) print(&#39;Current values= {}&#39;.format(balance)) if balance &gt;20000 : break . # of Year : 1 Current values= 10500.0 # of Year : 2 Current values= 11025.0 # of Year : 3 Current values= 11576.25 # of Year : 4 Current values= 12155.0625 # of Year : 5 Current values= 12762.815625000001 # of Year : 6 Current values= 13400.956406250001 # of Year : 7 Current values= 14071.004226562502 # of Year : 8 Current values= 14774.554437890627 # of Year : 9 Current values= 15513.28215978516 # of Year : 10 Current values= 16288.946267774418 # of Year : 11 Current values= 17103.393581163138 # of Year : 12 Current values= 17958.563260221297 # of Year : 13 Current values= 18856.491423232364 # of Year : 14 Current values= 19799.315994393983 # of Year : 15 Current values= 20789.281794113682 . 즉 15는 20000을 넘어서 break된 것을 알 수 있음 . . for i in range(5): continue print(i) . 왜 아무것도 출력 $X$ ? . 반복문은 다섯번 반복됐으나 그럴 때마다 continue를 만나서 다시 위로 올라가서 반복했기 때문 | . for i in range(5): if i==2 : continue print(i) . 0 1 3 4 . 2와 같을 땐 밑에 줄 신경 안쓰고 그냥 바로 위로 쭉 올라감 . . temp=[18,19,20,-10,-20,-30] . for t in temp: print(&#39;T={}&#39;.format(t)) . T=18 T=19 T=20 T=-10 T=-20 T=-30 . 이때 -값은 오류라고 생각하고 print하고 싶지 않을 땐? . for t in temp: if t&lt;0 : continue print(&#39;T={}&#39;.format(t)) . T=18 T=19 T=20 . . for x in range(5): pass x=1 . x . 1 . if True: pass x=1 . x . 1 . def myfun(): pass a=23 . a . 23 . 그냥 일단 패스시켜놓고 나중에 완성 시키고 싶을 때 . . 예외처리? . age=int(input(&#39;몇살이니?: &#39;)) print(&#39;Age={}&#39;.format(age)) . Age=555 . 만약 여기서 숫자가 아닌 문자를 넣으면 value error가 발생할 것 . while True: try: age=int(input(&#39;몇살이니?: &#39;)) print(&#39;Age={}&#39;.format(age)) break except ValueError: print(&#39;숫자를 입력해주세요&#39;) . 숫자를 입력해주세요 . 숫자를 입력해주세요 . 숫자를 입력해주세요 . 숫자를 입력해주세요 . Age=555 . 숫자를 입력할 때까지 while문이 실행될 것 . a=np.array([10,20,30,40,50]) num_max=np.NINF # 음의 무한대를 의미함 for i in a: num_curr = i if num_max &lt; num_curr: num_max=num_curr . num_max . 50 . . a=np.array([1,2,3,4,5,6]) for i in a: if i%2==0: print(&#39;{}는 짝수&#39;.format(i)) else : print(&#39;{}는 홀수&#39;.format(i)) . 1는 홀수 2는 짝수 3는 홀수 4는 짝수 5는 홀수 6는 짝수 . . User Interface Example/ UI . db={&#39;a&#39;:&#39;a1&#39;,&#39;b&#39;:&#39;b1&#39;,&#39;c&#39;:&#39;c1&#39;} password_attemps=3 while password_attemps &gt; 0 : user_id = input(&#39;ID: &#39;) user_ps = input(&#39;PW: &#39;) if user_id in db.keys() and user_ps in db.values() : print(&#39; nLog in Successful!&#39;) break else: password_attemps-=1 print(&#39; nTry againㅠㅠ&#39;) print(&#39;{} 번 더 시도 가능하십니다&#39;.format(password_attemps)) . Try againㅠㅠ 2 번 더 시도 가능하십니다 . Try againㅠㅠ 1 번 더 시도 가능하십니다 . Try againㅠㅠ 0 번 더 시도 가능하십니다 . import getpass 기능을 이용해서 password입력 할 때 해당 PW를 안 보이게 해줄 수 있음 . . my_str=&#39;python&#39; my_str2=[] for letter in my_str: my_str2.append(letter) . my_str . &#39;python&#39; . my_str2 . [&#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;] . $ to$ 이걸 한 줄로 가능하게 하는 것이 List Comprehension . my_str3=[letter for letter in my_str] my_str3 . [&#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;] . list comprehension + 조건 . num=[a for a in range(20) if a%2==0] . num . [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] . num=[a for a in range(20) if a%2!=0] . num . [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] . num=[a for a in range(50) if a%5==0 and a%2==0] . num . [0, 10, 20, 30, 40] . 또는 . num=[a for a in range(50) if a%5==0 if a%2==0] . num . [0, 10, 20, 30, 40] . . aaa=[&#39;짝수&#39;if i%2==0 else &#39;홀수&#39; for i in range(10)] . aaa . [&#39;짝수&#39;, &#39;홀수&#39;, &#39;짝수&#39;, &#39;홀수&#39;, &#39;짝수&#39;, &#39;홀수&#39;, &#39;짝수&#39;, &#39;홀수&#39;, &#39;짝수&#39;, &#39;홀수&#39;] . . dict comprehension . a={i:i**2 for i in range(6)} a . {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25} . . import sys,os . print(os.getcwd()) . C: Users ehfus Downloads python Introduction . os.mkdir(&#39;my_dir&#39;) # 현재 있는 위치에서 my_dir을 하나 만듦 . os.chdir(&#39;. my_dir&#39;) . 파일 100개 만들어보자 . for i in range(100): f=open(&#39;NewFile&#39;+str(i),&#39;w&#39;) # 파일을 쓸 거니까 &#39;w&#39; f.close() . 100개의 파일에 뭘 쓰진 않았음. 이제 파일의 이름을 바꿔보자 . 반복문을 통해 100개의 파일 이름을 바꾸기 전에 100개 파일의 이름을 일단 받아오자 . flist=os.listdir(&#39;.&#39;) . flist . [&#39;NewFile0&#39;, &#39;NewFile1&#39;, &#39;NewFile10&#39;, &#39;NewFile11&#39;, &#39;NewFile12&#39;, &#39;NewFile13&#39;, &#39;NewFile14&#39;, &#39;NewFile15&#39;, &#39;NewFile16&#39;, &#39;NewFile17&#39;, &#39;NewFile18&#39;, &#39;NewFile19&#39;, &#39;NewFile2&#39;, &#39;NewFile20&#39;, &#39;NewFile21&#39;, &#39;NewFile22&#39;, &#39;NewFile23&#39;, &#39;NewFile24&#39;, &#39;NewFile25&#39;, &#39;NewFile26&#39;, &#39;NewFile27&#39;, &#39;NewFile28&#39;, &#39;NewFile29&#39;, &#39;NewFile3&#39;, &#39;NewFile30&#39;, &#39;NewFile31&#39;, &#39;NewFile32&#39;, &#39;NewFile33&#39;, &#39;NewFile34&#39;, &#39;NewFile35&#39;, &#39;NewFile36&#39;, &#39;NewFile37&#39;, &#39;NewFile38&#39;, &#39;NewFile39&#39;, &#39;NewFile4&#39;, &#39;NewFile40&#39;, &#39;NewFile41&#39;, &#39;NewFile42&#39;, &#39;NewFile43&#39;, &#39;NewFile44&#39;, &#39;NewFile45&#39;, &#39;NewFile46&#39;, &#39;NewFile47&#39;, &#39;NewFile48&#39;, &#39;NewFile49&#39;, &#39;NewFile5&#39;, &#39;NewFile50&#39;, &#39;NewFile51&#39;, &#39;NewFile52&#39;, &#39;NewFile53&#39;, &#39;NewFile54&#39;, &#39;NewFile55&#39;, &#39;NewFile56&#39;, &#39;NewFile57&#39;, &#39;NewFile58&#39;, &#39;NewFile59&#39;, &#39;NewFile6&#39;, &#39;NewFile60&#39;, &#39;NewFile61&#39;, &#39;NewFile62&#39;, &#39;NewFile63&#39;, &#39;NewFile64&#39;, &#39;NewFile65&#39;, &#39;NewFile66&#39;, &#39;NewFile67&#39;, &#39;NewFile68&#39;, &#39;NewFile69&#39;, &#39;NewFile7&#39;, &#39;NewFile70&#39;, &#39;NewFile71&#39;, &#39;NewFile72&#39;, &#39;NewFile73&#39;, &#39;NewFile74&#39;, &#39;NewFile75&#39;, &#39;NewFile76&#39;, &#39;NewFile77&#39;, &#39;NewFile78&#39;, &#39;NewFile79&#39;, &#39;NewFile8&#39;, &#39;NewFile80&#39;, &#39;NewFile81&#39;, &#39;NewFile82&#39;, &#39;NewFile83&#39;, &#39;NewFile84&#39;, &#39;NewFile85&#39;, &#39;NewFile86&#39;, &#39;NewFile87&#39;, &#39;NewFile88&#39;, &#39;NewFile89&#39;, &#39;NewFile9&#39;, &#39;NewFile90&#39;, &#39;NewFile91&#39;, &#39;NewFile92&#39;, &#39;NewFile93&#39;, &#39;NewFile94&#39;, &#39;NewFile95&#39;, &#39;NewFile96&#39;, &#39;NewFile97&#39;, &#39;NewFile98&#39;, &#39;NewFile99&#39;] . for fid in flist: f_name=fid[0:7] f_num=fid[7::] if int(f_num)&lt;50: os.replace(fid,&#39;2019_&#39;+fid) else: os.replace(fid,&#39;2020_&#39;+fid) . 2019년도 파일 2020년도 파일을 두개의 디렉토리에 각각 넣어보자 . os.mkdir(&#39;2019_data&#39;) os.mkdir(&#39;2020_data&#39;) . flist=os.listdir(&#39;.&#39;) . flist . [&#39;2019_data&#39;, &#39;2019_NewFile0&#39;, &#39;2019_NewFile1&#39;, &#39;2019_NewFile10&#39;, &#39;2019_NewFile11&#39;, &#39;2019_NewFile12&#39;, &#39;2019_NewFile13&#39;, &#39;2019_NewFile14&#39;, &#39;2019_NewFile15&#39;, &#39;2019_NewFile16&#39;, &#39;2019_NewFile17&#39;, &#39;2019_NewFile18&#39;, &#39;2019_NewFile19&#39;, &#39;2019_NewFile2&#39;, &#39;2019_NewFile20&#39;, &#39;2019_NewFile21&#39;, &#39;2019_NewFile22&#39;, &#39;2019_NewFile23&#39;, &#39;2019_NewFile24&#39;, &#39;2019_NewFile25&#39;, &#39;2019_NewFile26&#39;, &#39;2019_NewFile27&#39;, &#39;2019_NewFile28&#39;, &#39;2019_NewFile29&#39;, &#39;2019_NewFile3&#39;, &#39;2019_NewFile30&#39;, &#39;2019_NewFile31&#39;, &#39;2019_NewFile32&#39;, &#39;2019_NewFile33&#39;, &#39;2019_NewFile34&#39;, &#39;2019_NewFile35&#39;, &#39;2019_NewFile36&#39;, &#39;2019_NewFile37&#39;, &#39;2019_NewFile38&#39;, &#39;2019_NewFile39&#39;, &#39;2019_NewFile4&#39;, &#39;2019_NewFile40&#39;, &#39;2019_NewFile41&#39;, &#39;2019_NewFile42&#39;, &#39;2019_NewFile43&#39;, &#39;2019_NewFile44&#39;, &#39;2019_NewFile45&#39;, &#39;2019_NewFile46&#39;, &#39;2019_NewFile47&#39;, &#39;2019_NewFile48&#39;, &#39;2019_NewFile49&#39;, &#39;2019_NewFile5&#39;, &#39;2019_NewFile6&#39;, &#39;2019_NewFile7&#39;, &#39;2019_NewFile8&#39;, &#39;2019_NewFile9&#39;, &#39;2020_data&#39;, &#39;2020_NewFile50&#39;, &#39;2020_NewFile51&#39;, &#39;2020_NewFile52&#39;, &#39;2020_NewFile53&#39;, &#39;2020_NewFile54&#39;, &#39;2020_NewFile55&#39;, &#39;2020_NewFile56&#39;, &#39;2020_NewFile57&#39;, &#39;2020_NewFile58&#39;, &#39;2020_NewFile59&#39;, &#39;2020_NewFile60&#39;, &#39;2020_NewFile61&#39;, &#39;2020_NewFile62&#39;, &#39;2020_NewFile63&#39;, &#39;2020_NewFile64&#39;, &#39;2020_NewFile65&#39;, &#39;2020_NewFile66&#39;, &#39;2020_NewFile67&#39;, &#39;2020_NewFile68&#39;, &#39;2020_NewFile69&#39;, &#39;2020_NewFile70&#39;, &#39;2020_NewFile71&#39;, &#39;2020_NewFile72&#39;, &#39;2020_NewFile73&#39;, &#39;2020_NewFile74&#39;, &#39;2020_NewFile75&#39;, &#39;2020_NewFile76&#39;, &#39;2020_NewFile77&#39;, &#39;2020_NewFile78&#39;, &#39;2020_NewFile79&#39;, &#39;2020_NewFile80&#39;, &#39;2020_NewFile81&#39;, &#39;2020_NewFile82&#39;, &#39;2020_NewFile83&#39;, &#39;2020_NewFile84&#39;, &#39;2020_NewFile85&#39;, &#39;2020_NewFile86&#39;, &#39;2020_NewFile87&#39;, &#39;2020_NewFile88&#39;, &#39;2020_NewFile89&#39;, &#39;2020_NewFile90&#39;, &#39;2020_NewFile91&#39;, &#39;2020_NewFile92&#39;, &#39;2020_NewFile93&#39;, &#39;2020_NewFile94&#39;, &#39;2020_NewFile95&#39;, &#39;2020_NewFile96&#39;, &#39;2020_NewFile97&#39;, &#39;2020_NewFile98&#39;, &#39;2020_NewFile99&#39;] . from itertools import compress . idx = list(map(lambda x:&#39;File&#39; in x, flist)) flist2 = list(compress(flist,idx)) . flist2 . [&#39;2019_NewFile0&#39;, &#39;2019_NewFile1&#39;, &#39;2019_NewFile10&#39;, &#39;2019_NewFile11&#39;, &#39;2019_NewFile12&#39;, &#39;2019_NewFile13&#39;, &#39;2019_NewFile14&#39;, &#39;2019_NewFile15&#39;, &#39;2019_NewFile16&#39;, &#39;2019_NewFile17&#39;, &#39;2019_NewFile18&#39;, &#39;2019_NewFile19&#39;, &#39;2019_NewFile2&#39;, &#39;2019_NewFile20&#39;, &#39;2019_NewFile21&#39;, &#39;2019_NewFile22&#39;, &#39;2019_NewFile23&#39;, &#39;2019_NewFile24&#39;, &#39;2019_NewFile25&#39;, &#39;2019_NewFile26&#39;, &#39;2019_NewFile27&#39;, &#39;2019_NewFile28&#39;, &#39;2019_NewFile29&#39;, &#39;2019_NewFile3&#39;, &#39;2019_NewFile30&#39;, &#39;2019_NewFile31&#39;, &#39;2019_NewFile32&#39;, &#39;2019_NewFile33&#39;, &#39;2019_NewFile34&#39;, &#39;2019_NewFile35&#39;, &#39;2019_NewFile36&#39;, &#39;2019_NewFile37&#39;, &#39;2019_NewFile38&#39;, &#39;2019_NewFile39&#39;, &#39;2019_NewFile4&#39;, &#39;2019_NewFile40&#39;, &#39;2019_NewFile41&#39;, &#39;2019_NewFile42&#39;, &#39;2019_NewFile43&#39;, &#39;2019_NewFile44&#39;, &#39;2019_NewFile45&#39;, &#39;2019_NewFile46&#39;, &#39;2019_NewFile47&#39;, &#39;2019_NewFile48&#39;, &#39;2019_NewFile49&#39;, &#39;2019_NewFile5&#39;, &#39;2019_NewFile6&#39;, &#39;2019_NewFile7&#39;, &#39;2019_NewFile8&#39;, &#39;2019_NewFile9&#39;, &#39;2020_NewFile50&#39;, &#39;2020_NewFile51&#39;, &#39;2020_NewFile52&#39;, &#39;2020_NewFile53&#39;, &#39;2020_NewFile54&#39;, &#39;2020_NewFile55&#39;, &#39;2020_NewFile56&#39;, &#39;2020_NewFile57&#39;, &#39;2020_NewFile58&#39;, &#39;2020_NewFile59&#39;, &#39;2020_NewFile60&#39;, &#39;2020_NewFile61&#39;, &#39;2020_NewFile62&#39;, &#39;2020_NewFile63&#39;, &#39;2020_NewFile64&#39;, &#39;2020_NewFile65&#39;, &#39;2020_NewFile66&#39;, &#39;2020_NewFile67&#39;, &#39;2020_NewFile68&#39;, &#39;2020_NewFile69&#39;, &#39;2020_NewFile70&#39;, &#39;2020_NewFile71&#39;, &#39;2020_NewFile72&#39;, &#39;2020_NewFile73&#39;, &#39;2020_NewFile74&#39;, &#39;2020_NewFile75&#39;, &#39;2020_NewFile76&#39;, &#39;2020_NewFile77&#39;, &#39;2020_NewFile78&#39;, &#39;2020_NewFile79&#39;, &#39;2020_NewFile80&#39;, &#39;2020_NewFile81&#39;, &#39;2020_NewFile82&#39;, &#39;2020_NewFile83&#39;, &#39;2020_NewFile84&#39;, &#39;2020_NewFile85&#39;, &#39;2020_NewFile86&#39;, &#39;2020_NewFile87&#39;, &#39;2020_NewFile88&#39;, &#39;2020_NewFile89&#39;, &#39;2020_NewFile90&#39;, &#39;2020_NewFile91&#39;, &#39;2020_NewFile92&#39;, &#39;2020_NewFile93&#39;, &#39;2020_NewFile94&#39;, &#39;2020_NewFile95&#39;, &#39;2020_NewFile96&#39;, &#39;2020_NewFile97&#39;, &#39;2020_NewFile98&#39;, &#39;2020_NewFile99&#39;] . dir이름은 없고 파일이름만 뽑아온 것 . 두번째 방법 . flist3=list(filter(lambda x: &#39;File&#39; in x, flist)) . flist3 . [&#39;2019_NewFile0&#39;, &#39;2019_NewFile1&#39;, &#39;2019_NewFile10&#39;, &#39;2019_NewFile11&#39;, &#39;2019_NewFile12&#39;, &#39;2019_NewFile13&#39;, &#39;2019_NewFile14&#39;, &#39;2019_NewFile15&#39;, &#39;2019_NewFile16&#39;, &#39;2019_NewFile17&#39;, &#39;2019_NewFile18&#39;, &#39;2019_NewFile19&#39;, &#39;2019_NewFile2&#39;, &#39;2019_NewFile20&#39;, &#39;2019_NewFile21&#39;, &#39;2019_NewFile22&#39;, &#39;2019_NewFile23&#39;, &#39;2019_NewFile24&#39;, &#39;2019_NewFile25&#39;, &#39;2019_NewFile26&#39;, &#39;2019_NewFile27&#39;, &#39;2019_NewFile28&#39;, &#39;2019_NewFile29&#39;, &#39;2019_NewFile3&#39;, &#39;2019_NewFile30&#39;, &#39;2019_NewFile31&#39;, &#39;2019_NewFile32&#39;, &#39;2019_NewFile33&#39;, &#39;2019_NewFile34&#39;, &#39;2019_NewFile35&#39;, &#39;2019_NewFile36&#39;, &#39;2019_NewFile37&#39;, &#39;2019_NewFile38&#39;, &#39;2019_NewFile39&#39;, &#39;2019_NewFile4&#39;, &#39;2019_NewFile40&#39;, &#39;2019_NewFile41&#39;, &#39;2019_NewFile42&#39;, &#39;2019_NewFile43&#39;, &#39;2019_NewFile44&#39;, &#39;2019_NewFile45&#39;, &#39;2019_NewFile46&#39;, &#39;2019_NewFile47&#39;, &#39;2019_NewFile48&#39;, &#39;2019_NewFile49&#39;, &#39;2019_NewFile5&#39;, &#39;2019_NewFile6&#39;, &#39;2019_NewFile7&#39;, &#39;2019_NewFile8&#39;, &#39;2019_NewFile9&#39;, &#39;2020_NewFile50&#39;, &#39;2020_NewFile51&#39;, &#39;2020_NewFile52&#39;, &#39;2020_NewFile53&#39;, &#39;2020_NewFile54&#39;, &#39;2020_NewFile55&#39;, &#39;2020_NewFile56&#39;, &#39;2020_NewFile57&#39;, &#39;2020_NewFile58&#39;, &#39;2020_NewFile59&#39;, &#39;2020_NewFile60&#39;, &#39;2020_NewFile61&#39;, &#39;2020_NewFile62&#39;, &#39;2020_NewFile63&#39;, &#39;2020_NewFile64&#39;, &#39;2020_NewFile65&#39;, &#39;2020_NewFile66&#39;, &#39;2020_NewFile67&#39;, &#39;2020_NewFile68&#39;, &#39;2020_NewFile69&#39;, &#39;2020_NewFile70&#39;, &#39;2020_NewFile71&#39;, &#39;2020_NewFile72&#39;, &#39;2020_NewFile73&#39;, &#39;2020_NewFile74&#39;, &#39;2020_NewFile75&#39;, &#39;2020_NewFile76&#39;, &#39;2020_NewFile77&#39;, &#39;2020_NewFile78&#39;, &#39;2020_NewFile79&#39;, &#39;2020_NewFile80&#39;, &#39;2020_NewFile81&#39;, &#39;2020_NewFile82&#39;, &#39;2020_NewFile83&#39;, &#39;2020_NewFile84&#39;, &#39;2020_NewFile85&#39;, &#39;2020_NewFile86&#39;, &#39;2020_NewFile87&#39;, &#39;2020_NewFile88&#39;, &#39;2020_NewFile89&#39;, &#39;2020_NewFile90&#39;, &#39;2020_NewFile91&#39;, &#39;2020_NewFile92&#39;, &#39;2020_NewFile93&#39;, &#39;2020_NewFile94&#39;, &#39;2020_NewFile95&#39;, &#39;2020_NewFile96&#39;, &#39;2020_NewFile97&#39;, &#39;2020_NewFile98&#39;, &#39;2020_NewFile99&#39;] . 세번째 방법 . file4=[x for x in flist if &#39;File&#39; in x] . 네번째 방법 . import glob glob.glob(&#39;2020_NewFile??&#39;) . [&#39;2020_NewFile50&#39;, &#39;2020_NewFile51&#39;, &#39;2020_NewFile52&#39;, &#39;2020_NewFile53&#39;, &#39;2020_NewFile54&#39;, &#39;2020_NewFile55&#39;, &#39;2020_NewFile56&#39;, &#39;2020_NewFile57&#39;, &#39;2020_NewFile58&#39;, &#39;2020_NewFile59&#39;, &#39;2020_NewFile60&#39;, &#39;2020_NewFile61&#39;, &#39;2020_NewFile62&#39;, &#39;2020_NewFile63&#39;, &#39;2020_NewFile64&#39;, &#39;2020_NewFile65&#39;, &#39;2020_NewFile66&#39;, &#39;2020_NewFile67&#39;, &#39;2020_NewFile68&#39;, &#39;2020_NewFile69&#39;, &#39;2020_NewFile70&#39;, &#39;2020_NewFile71&#39;, &#39;2020_NewFile72&#39;, &#39;2020_NewFile73&#39;, &#39;2020_NewFile74&#39;, &#39;2020_NewFile75&#39;, &#39;2020_NewFile76&#39;, &#39;2020_NewFile77&#39;, &#39;2020_NewFile78&#39;, &#39;2020_NewFile79&#39;, &#39;2020_NewFile80&#39;, &#39;2020_NewFile81&#39;, &#39;2020_NewFile82&#39;, &#39;2020_NewFile83&#39;, &#39;2020_NewFile84&#39;, &#39;2020_NewFile85&#39;, &#39;2020_NewFile86&#39;, &#39;2020_NewFile87&#39;, &#39;2020_NewFile88&#39;, &#39;2020_NewFile89&#39;, &#39;2020_NewFile90&#39;, &#39;2020_NewFile91&#39;, &#39;2020_NewFile92&#39;, &#39;2020_NewFile93&#39;, &#39;2020_NewFile94&#39;, &#39;2020_NewFile95&#39;, &#39;2020_NewFile96&#39;, &#39;2020_NewFile97&#39;, &#39;2020_NewFile98&#39;, &#39;2020_NewFile99&#39;] . 이런식으로 . file5=glob.glob(&#39;*File*&#39;) . . 이제 파일들을 각 년도 dir에 넣어보자 . import shutil . for f_curr in file5: f_name = f_curr[0:12] f_num = f_curr[12::] if int(f_num) &lt; 50: shutil.move(f_curr,&#39;. 2019_data&#39;) else: shutil.move(f_curr,&#39;. 2020_data&#39;) . dir에 파일들이 각각 들어갔음 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/27/intro.html",
            "relUrl": "/2021/12/27/intro.html",
            "date": " • Dec 27, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "2021/12/26/SUN",
            "content": "import numpy as np import pandas as pd !pip install openpyxl from openpyxl import load_workbook . Requirement already satisfied: openpyxl in c: users ehfus anaconda3 envs dv2021 lib site-packages (3.0.9) Requirement already satisfied: et-xmlfile in c: users ehfus anaconda3 envs dv2021 lib site-packages (from openpyxl) (1.1.0) . data = {&#39;Name&#39; : [&#39;S1&#39;,&#39;S2&#39;,&#39;S3&#39;], &#39;Age&#39; : [25,28,22], &#39;Score&#39; : np.array([95,80,75])} print(data) . {&#39;Name&#39;: [&#39;S1&#39;, &#39;S2&#39;, &#39;S3&#39;], &#39;Age&#39;: [25, 28, 22], &#39;Score&#39;: array([95, 80, 75])} . data[&#39;Name&#39;] . [&#39;S1&#39;, &#39;S2&#39;, &#39;S3&#39;] . df=pd.DataFrame(data) . df . Name Age Score . 0 S1 | 25 | 95 | . 1 S2 | 28 | 80 | . 2 S3 | 22 | 75 | . df=pd.DataFrame(data,index=[&#39;row1&#39;,&#39;row2&#39;,&#39;row3&#39;]) df . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . 리스트도 df로 변경 가능 . data2=[[&#39;S1&#39;,25,95],[&#39;S2&#39;,28,80],[&#39;S3&#39;,22,75]] . df2=pd.DataFrame(data2,index=[&#39;row1&#39;,&#39;row2&#39;,&#39;row3&#39;],columns=[&#39;Name&#39;,&#39;Age&#39;,&#39;Score&#39;]) . df2 . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . . Subset Observation . df . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . df[[&#39;Name&#39;]] . Name . row1 S1 | . row2 S2 | . row3 S3 | . df[&#39;Name&#39;] . row1 S1 row2 S2 row3 S3 Name: Name, dtype: object . df[[&#39;Name&#39;,&#39;Score&#39;]] # 이렇게 list안에 넣어줘야 함 . Name Score . row1 S1 | 95 | . row2 S2 | 80 | . row3 S3 | 75 | . # 이렇게 행은 추출할 수 없음 . 그렇다면? . df.loc[[&#39;row1&#39;]] . Name Age Score . row1 S1 | 25 | 95 | . df.loc[&#39;row1&#39;] . Name S1 Age 25 Score 95 Name: row1, dtype: object . df.loc[[&#39;row1&#39;,&#39;row2&#39;]] . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . df.loc[&#39;row1&#39;,&#39;Name&#39;] . &#39;S1&#39; . df[&#39;Name&#39;] #df.loc[&#39;Name&#39;] 이건 안 됨 . row1 S1 row2 S2 row3 S3 Name: Name, dtype: object . 이렇게 사용 . df.loc[:,&#39;Name&#39;] . row1 S1 row2 S2 row3 S3 Name: Name, dtype: object . df.loc[:,[&#39;Score&#39;,&#39;Name&#39;]] . Score Name . row1 95 | S1 | . row2 80 | S2 | . row3 75 | S3 | . df.loc[:,&#39;Name&#39;:&#39;Age&#39;] # : 사용할 땐 중괄호 X . Name Age . row1 S1 | 25 | . row2 S2 | 28 | . row3 S3 | 22 | . df.iloc[0,0] . &#39;S1&#39; . df.iloc[2,0] . &#39;S3&#39; . df.iloc[:,[0,2]] . Name Score . row1 S1 | 95 | . row2 S2 | 80 | . row3 S3 | 75 | . df.iloc[::2,[0,2]] . Name Score . row1 S1 | 95 | . row3 S3 | 75 | . df.iloc[-1,:] . Name S3 Age 22 Score 75 Name: row3, dtype: object . df.iloc[-1::-1,:] . Name Age Score . row3 S3 | 22 | 75 | . row2 S2 | 28 | 80 | . row1 S1 | 25 | 95 | . 마지막부터 data가 뒤집혀서 불리어짐 . df.head(2) . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . df.tail(1) . Name Age Score . row3 S3 | 22 | 75 | . default는 5갠가 여섯개임 - 괄호안에 원하는 숫자 삽입가능 . df.info() # 열,행갯수, 칼럼 이름. data type 등등 . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Index: 3 entries, row1 to row3 Data columns (total 3 columns): # Column Non-Null Count Dtype -- -- 0 Name 3 non-null object 1 Age 3 non-null int64 2 Score 3 non-null int32 dtypes: int32(1), int64(1), object(1) memory usage: 192.0+ bytes . df.describe() # 통계적 수치들을 알 수 있음 . Age Score . count 3.0 | 3.000000 | . mean 25.0 | 83.333333 | . std 3.0 | 10.408330 | . min 22.0 | 75.000000 | . 25% 23.5 | 77.500000 | . 50% 25.0 | 80.000000 | . 75% 26.5 | 87.500000 | . max 28.0 | 95.000000 | . df2=df.copy() . df2 . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . df2.loc[&#39;row2&#39;,&#39;Score&#39;]=np.NaN . df2 . Name Age Score . row1 S1 | 25 | 95.0 | . row2 S2 | 28 | NaN | . row3 S3 | 22 | 75.0 | . df2.nunique() . Name 3 Age 3 Score 2 dtype: int64 . Score에 NaN들어가 있어서 Score는 nunique가 2개임 . df2[&#39;Score&#39;].nunique() . 2 . df2[&#39;Score&#39;].value_counts() ## 각 값들의 갯수를 알 수 있음 . 95.0 1 75.0 1 Name: Score, dtype: int64 . df3=df2.copy() df3.loc[&#39;row3&#39;,&#39;Score&#39;]=df2.loc[&#39;row1&#39;,&#39;Score&#39;] . df3[&#39;Score&#39;].value_counts() . 95.0 2 Name: Score, dtype: int64 . 그냥 몇개 들어있는지도 알 수 있음 . df3[&#39;Score&#39;].count() . 2 . df3[&#39;Age&#39;].count() . 3 . df[&#39;Score&#39;].sum() . 250 . df.max() . Name S3 Age 28 Score 95 dtype: object . df[&#39;Score&#39;].std() . 10.408329997330664 . df.describe() . Age Score . count 3.0 | 3.000000 | . mean 25.0 | 83.333333 | . std 3.0 | 10.408330 | . min 22.0 | 75.000000 | . 25% 23.5 | 77.500000 | . 50% 25.0 | 80.000000 | . 75% 26.5 | 87.500000 | . max 28.0 | 95.000000 | . 동일 . . df4=df.copy() . df4 . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . df4=df4.iloc[:,[0,2,1]] . df4 . Name Score Age . row1 S1 | 95 | 25 | . row2 S2 | 80 | 28 | . row3 S3 | 75 | 22 | . df4의 열을 변경해줬음 . data={ &#39;class&#39; : [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;C&#39;], &#39;name&#39; : [&#39;S1&#39;,&#39;S2&#39;,&#39;S3&#39;,&#39;S4&#39;,&#39;S5&#39;,&#39;S6&#39;,&#39;S7&#39;], &#39;age&#39; : [20,19,21,22,24,25,26], &#39;score&#39; : [90,95,75,80,70,85,90]} . df=pd.DataFrame(data) df . class name age score . 0 A | S1 | 20 | 90 | . 1 B | S2 | 19 | 95 | . 2 C | S3 | 21 | 75 | . 3 A | S4 | 22 | 80 | . 4 B | S5 | 24 | 70 | . 5 C | S6 | 25 | 85 | . 6 C | S7 | 26 | 90 | . df[&#39;score&#39;]&gt;=80 . 0 True 1 True 2 False 3 True 4 False 5 True 6 True Name: score, dtype: bool . df.loc[df[&#39;score&#39;]&gt;=80] . class name age score . 0 A | S1 | 20 | 90 | . 1 B | S2 | 19 | 95 | . 3 A | S4 | 22 | 80 | . 5 C | S6 | 25 | 85 | . 6 C | S7 | 26 | 90 | . df.loc[df[&#39;score&#39;]&gt;=80,[&#39;name&#39;,&#39;age&#39;]] . name age . 0 S1 | 20 | . 1 S2 | 19 | . 3 S4 | 22 | . 5 S6 | 25 | . 6 S7 | 26 | . df[df[&#39;score&#39;]&gt;=80] . class name age score . 0 A | S1 | 20 | 90 | . 1 B | S2 | 19 | 95 | . 3 A | S4 | 22 | 80 | . 5 C | S6 | 25 | 85 | . 6 C | S7 | 26 | 90 | . df[&#39;result&#39;]=&#39;NONE&#39; . df . class name age score result . 0 A | S1 | 20 | 90 | NONE | . 1 B | S2 | 19 | 95 | NONE | . 2 C | S3 | 21 | 75 | NONE | . 3 A | S4 | 22 | 80 | NONE | . 4 B | S5 | 24 | 70 | NONE | . 5 C | S6 | 25 | 85 | NONE | . 6 C | S7 | 26 | 90 | NONE | . df.loc[df[&#39;score&#39;]&gt;=80,&#39;result&#39;]=&#39;PASS&#39; . df.loc[df[&#39;score&#39;]&lt;80,&#39;result&#39;]=&#39;FAIL&#39; . df . class name age score result . 0 A | S1 | 20 | 90 | PASS | . 1 B | S2 | 19 | 95 | PASS | . 2 C | S3 | 21 | 75 | FAIL | . 3 A | S4 | 22 | 80 | PASS | . 4 B | S5 | 24 | 70 | FAIL | . 5 C | S6 | 25 | 85 | PASS | . 6 C | S7 | 26 | 90 | PASS | . idx = df[&#39;result&#39;] == &#39;PASS&#39; . df.loc[idx] . class name age score result . 0 A | S1 | 20 | 90 | PASS | . 1 B | S2 | 19 | 95 | PASS | . 3 A | S4 | 22 | 80 | PASS | . 5 C | S6 | 25 | 85 | PASS | . 6 C | S7 | 26 | 90 | PASS | . df_sorted=df.loc[idx].sort_values(&#39;score&#39;,ascending=False) . df_sorted . class name age score result . 1 B | S2 | 19 | 95 | PASS | . 0 A | S1 | 20 | 90 | PASS | . 6 C | S7 | 26 | 90 | PASS | . 5 C | S6 | 25 | 85 | PASS | . 3 A | S4 | 22 | 80 | PASS | . excel 파일 만들고 불러오기 . df_sorted.to_excel(&#39;data_sorted.xlsx&#39;,index=False) . df_import=pd.read_excel(&#39;data_sorted.xlsx&#39;) . df_import . class name age score result . 0 B | S2 | 19 | 95 | PASS | . 1 A | S1 | 20 | 90 | PASS | . 2 C | S7 | 26 | 90 | PASS | . 3 C | S6 | 25 | 85 | PASS | . 4 A | S4 | 22 | 80 | PASS | . grouping . df.groupby(by=&#39;class&#39;).mean() . age score . class . A 21.0 | 85.000000 | . B 21.5 | 82.500000 | . C 24.0 | 83.333333 | . df.groupby(by=&#39;class&#39;).std() . age score . class . A 1.414214 | 7.071068 | . B 3.535534 | 17.677670 | . C 2.645751 | 7.637626 | . plotting . df.plot.bar(&#39;name&#39;,&#39;score&#39;) . &lt;AxesSubplot:xlabel=&#39;name&#39;&gt; . null&#52376;&#47532;&#54644;&#48372;&#51088; . df.loc[[0,2],&#39;score&#39;]=np.NaN . df . class name age score result . 0 A | S1 | 20 | NaN | PASS | . 1 B | S2 | 19 | 95.0 | PASS | . 2 C | S3 | 21 | NaN | FAIL | . 3 A | S4 | 22 | 80.0 | PASS | . 4 B | S5 | 24 | 70.0 | FAIL | . 5 C | S6 | 25 | 85.0 | PASS | . 6 C | S7 | 26 | 90.0 | PASS | . NaN이 들어간 곳을 알려줌 . df.isnull() . class name age score result . 0 False | False | False | True | False | . 1 False | False | False | False | False | . 2 False | False | False | True | False | . 3 False | False | False | False | False | . 4 False | False | False | False | False | . 5 False | False | False | False | False | . 6 False | False | False | False | False | . df.dropna()#데이터 없는 행은 다 날림 . class name age score result . 1 B | S2 | 19 | 95.0 | PASS | . 3 A | S4 | 22 | 80.0 | PASS | . 4 B | S5 | 24 | 70.0 | FAIL | . 5 C | S6 | 25 | 85.0 | PASS | . 6 C | S7 | 26 | 90.0 | PASS | . value=0 df.fillna(value) ## NaN값만 value로 채워줌 . class name age score result . 0 A | S1 | 20 | 0.0 | PASS | . 1 B | S2 | 19 | 95.0 | PASS | . 2 C | S3 | 21 | 0.0 | FAIL | . 3 A | S4 | 22 | 80.0 | PASS | . 4 B | S5 | 24 | 70.0 | FAIL | . 5 C | S6 | 25 | 85.0 | PASS | . 6 C | S7 | 26 | 90.0 | PASS | . df.replace(np.nan,value) . class name age score result . 0 A | S1 | 20 | 0.0 | PASS | . 1 B | S2 | 19 | 95.0 | PASS | . 2 C | S3 | 21 | 0.0 | FAIL | . 3 A | S4 | 22 | 80.0 | PASS | . 4 B | S5 | 24 | 70.0 | FAIL | . 5 C | S6 | 25 | 85.0 | PASS | . 6 C | S7 | 26 | 90.0 | PASS | . df.interpolate() . class name age score result . 0 A | S1 | 20 | NaN | PASS | . 1 B | S2 | 19 | 95.0 | PASS | . 2 C | S3 | 21 | 87.5 | FAIL | . 3 A | S4 | 22 | 80.0 | PASS | . 4 B | S5 | 24 | 70.0 | FAIL | . 5 C | S6 | 25 | 85.0 | PASS | . 6 C | S7 | 26 | 90.0 | PASS | . 이렇게 위 아래 값의 평균으로 채워주기도 하는데 위아래 둘다 있는 경우에만 사용가능하다 . def add_one(x): return x+1 . add_one(1001) . 1002 . df[&#39;age&#39;]=df[&#39;age&#39;].apply(add_one) . df . class name age score result . 0 A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | . 이렇게 df의 age를 변경해줄 수 있음 . df[&#39;score&#39;].apply(np.square) . 0 NaN 1 9025.0 2 NaN 3 6400.0 4 4900.0 5 7225.0 6 8100.0 Name: score, dtype: float64 . 이런 np.square도 사용가능 . . df.filter(regex=&#39;[rn]&#39;) # nr이 들어간 columns 추출 . name score result . 0 S1 | NaN | PASS | . 1 S2 | 95.0 | PASS | . 2 S3 | NaN | FAIL | . 3 S4 | 80.0 | PASS | . 4 S5 | 70.0 | FAIL | . 5 S6 | 85.0 | PASS | . 6 S7 | 90.0 | PASS | . df_vertical=pd.concat([df,df]) df_vertical . class name age score result . 0 A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | . 0 A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | . df_horizontal=pd.concat([df,df],axis=1) df_horizontal . class name age score result class name age score result . 0 A | S1 | 21 | NaN | PASS | A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | C | S7 | 27 | 90.0 | PASS | . . df.to_csv(&#39;data_text.txt&#39;,sep=&#39; t&#39;,index=False) # txt파일로 변환할 때 어떻게 구분해서 타이핑해넣을 것인가 # =sep로 !,여기선 지금 탭으로 구분지었음 . pd.read_csv(&#39;data_text.txt&#39;,delimiter=&#39; t&#39;) . class name age score result . 0 A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | . delimiter로 txt파일이 어떻게 이루어져 있나 알려줘야함 . . from sympy import symbols . x=symbols(&#39;x&#39;) . type(x) . sympy.core.symbol.Symbol . 2*x . $ displaystyle 2 x$ 즉 x자체가 symbol로 들어갔음 . expr=2*x . expr.subs(x,3) . $ displaystyle 6$ 미분해보자 . f=x**3 . from sympy import diff . df1=diff(f,x) . df1 . $ displaystyle 3 x^{2}$ df2=diff(df1,x) . df2 . $ displaystyle 6 x$ . from sympy import sin . f=sin(x) . df1=diff(f,x) . df1 . $ displaystyle cos{ left(x right)}$ . from sympy import integrate . integrate(f,(x,0,2*3.14)) . $ displaystyle 5.07308662478501 cdot 10^{-6}$ 0에 가깝게 나옴 . integrate(f,(x,0,3.14)) . $ displaystyle 1.99999873172754$ . from sympy import limit . limit(sin(x)/x,x,0) . $ displaystyle 1$ . !pip install scipy . Requirement already satisfied: scipy in c: users ehfus anaconda3 envs dv2021 lib site-packages (1.7.1) Requirement already satisfied: numpy&lt;1.23.0,&gt;=1.16.5 in c: users ehfus anaconda3 envs dv2021 lib site-packages (from scipy) (1.21.4) . import matplotlib.pyplot as plt from scipy import interpolate . x=np.array([1,2,3,4,5]) y=np.array([1,0.8,0.4,0.3,0.2]) . plt.plot(x,y,&#39;*&#39;) . [&lt;matplotlib.lines.Line2D at 0x27a654355e0&gt;] . f_lin=interpolate.interp1d(x,y) . x_new = np.arange(1,5,0.1) . y_new = f_lin(x_new) . fig,ax=plt.subplots() ax.plot(x,y,&#39;o&#39;,label=&#39;Data&#39;) ax.plot(x_new,y_new,label=&#39;linear&#39;) ax.legend() . &lt;matplotlib.legend.Legend at 0x27a655d0a60&gt; . 선형 보간됨을 알 수 있다. . . tck=interpolate.splrep(x,y,s=0) y_spl=interpolate.splev(x_new,tck,der=0) fig,ax=plt.subplots() ax.plot(x,y,&#39;o&#39;,label=&#39;Data&#39;) ax.plot(x_new,y_new,label=&#39;linear&#39;) ax.plot(x_new,y_spl,label=&#39;spline&#39;) ax.legend() . &lt;matplotlib.legend.Legend at 0x27a7588db50&gt; . 원형 보간 추가 . . open cv . import cv2 as cv . im=cv.imread(&#39;KakaoTalk_20211210_090822964.png&#39;) . im.shape . (1080, 1920, 3) . type(im) . numpy.ndarray . BGR &#54540;&#46991; . plt.figure() plt.imshow(im) plt.title(&#39;Original&#39;) . Text(0.5, 1.0, &#39;Original&#39;) . BGR로 들어오기 때문에 RGB로 바꿔 줄 필요가 있음 . rgb=cv.cvtColor(im,cv.COLOR_BGR2RGB) plt.figure() plt.imshow(rgb) plt.title(&#39;RGB&#39;) . Text(0.5, 1.0, &#39;RGB&#39;) . GRAY=cv.cvtColor(im,cv.COLOR_BGR2GRAY) plt.figure() plt.imshow(GRAY,cmap=&#39;gray&#39;) plt.title(&#39;GRAY&#39;) . Text(0.5, 1.0, &#39;GRAY&#39;) . cmap=gray 처리 꼭 해줘야 함 | . blur=cv.blur(im,(100,100)) blur=cv.cvtColor(blur,cv.COLOR_BGR2RGB) plt.subplot(121) # 가로줄 한개, 세로줄 두개, 첫번째에 놓겠다 plt.imshow(rgb) plt.title(&#39;RGB&#39;) plt.subplot(122) # 가로줄 한개, 세로줄 두개, 두번째에 놓겠다 plt.imshow(blur) plt.title(&#39;blur&#39;) . Text(0.5, 1.0, &#39;blur&#39;) . . . edges=cv.Canny(GRAY,0,100) plt.subplot(121) # 가로줄 한개, 세로줄 두개, 첫번째에 놓겠다 plt.imshow(GRAY,cmap=&#39;gray&#39;) plt.title(&#39;GRAY&#39;) plt.subplot(122) # 가로줄 한개, 세로줄 두개, 두번째에 놓겠다 plt.imshow(edges) plt.title(&#39;edge detection&#39;) . Text(0.5, 1.0, &#39;edge detection&#39;) . 머신러닝과 연관하여 비디오 영상의 움직이는 사물을 찾거나 번호판 또는 숫자 인식 여러 분야에서 활용이 가능하다 . .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/26/intro.html",
            "relUrl": "/2021/12/26/intro.html",
            "date": " • Dec 26, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "2021/12/25/SAT",
            "content": "import numpy as np . a=np.array([100.,101.,102.,103.]) . a.shape # 1차원 4개 요소 . (4,) . a.ndim . 1 . a[0] . 100.0 . a[1] . 101.0 . a[-1] . 103.0 . a[[1,3]] . array([101., 103.]) . a[-3:-1] . array([101., 102.]) . a[1:4:1] . array([101., 102., 103.]) . a[1:4] . array([101., 102., 103.]) . a[1:4:2] . array([101., 103.]) . a[:] . array([100., 101., 102., 103.]) . a[::2] . array([100., 102.]) . a[::-2] . array([103., 101.]) . a2=np.array([[11,12],[23 ,34]]) . a2.shape . (2, 2) . a2.ndim . 2 . a2[0][1] # 겉차원 -&gt; 속차원 . 12 . a2[0,1] . 12 . a2[:] . array([[11, 12], [23, 34]]) . a2[:,:] . array([[11, 12], [23, 34]]) . a2[0,:] . array([11, 12]) . a2[1,:] . array([23, 34]) . b=a2[:,0] . b . array([11, 23]) . b.shape . (2,) . b.ndim . 1 . b_=b[:,np.newaxis] . b_ . array([[11], [23]]) . b_.shape . (2, 1) . b.ndim . 1 . 또는 . b.shape=(1,2) . b . array([[11, 23]]) . a3=np.array([[[ 1,2],[3,4 ],[5,6 ],[7,8 ],[9,10]]]) . a3 . array([[[ 1, 2], [ 3, 4], [ 5, 6], [ 7, 8], [ 9, 10]]]) . a3.shape # 큰 덩어리 1개, 작은 덩어리 5개, 그 안에 요소 2개씩 . (1, 5, 2) . a3.ndim #3차원 . 3 . a3[0,1,1] . 4 . # 큰 덩어리는 하나임 # a3[1] . x=np.array([12,34,14]) . idx=np.where(x==34) . idx # 0번째 아니고 1번째 있다 . (array([1], dtype=int64),) . x[idx] . array([34]) . idx=(x==14) . idx . array([False, False, True]) . x[idx] . array([14]) . x[np.where(x==12)] . array([12]) . x[np.nonzero(x==34)] . array([34]) . image processing시, 논리연산을 통한 idexing 중요 . 대충 적용해보자 . image=np.array([[255,0,255], [255,0,255], [255,0,255]]) . image.shape # 2차원, 큰덩어리 세개, 그 안에 요소 3개 . (3, 3) . idx=np.where(image==255) . image[idx]=0 . image . array([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) . 이런식으로 논리연산을 통한 indexing으로 다 검정색을 만들어버림 . . a=np.array([[10,20],[30,40]]) b=np.array([[1,2],[3,4]]) . a * b . array([[ 10, 40], [ 90, 160]]) . a @ b #행렬 연산 . array([[ 70, 100], [150, 220]]) . a.dot(b) #행렬 연산 . array([[ 70, 100], [150, 220]]) . a=np.zeros((3,3)) . b=np.ones((3,3)) . c=np.trace(a) . $x@a=y$ 에서 a행렬 구해보기 . x=np.array([[1,-3],[2,4]]) y=np.array([[1],[3]]) . x_inverse=np.linalg.inv(x) . a=x_inverse@y . a . array([[1.3], [0.1]]) . 혹은 . a=np.linalg.solve(x,y) . a . array([[1.3], [0.1]]) . 이렇게도 해결 가능하다 . 그 외에도 고유벡터, 고유값, 특이값 분해도 np에서 함수사용할 수 있다 . a=np.zeros((5,5)) np.fill_diagonal(a,12) . a#대각원소만 12로 변경 . array([[12., 0., 0., 0., 0.], [ 0., 12., 0., 0., 0.], [ 0., 0., 12., 0., 0.], [ 0., 0., 0., 12., 0.], [ 0., 0., 0., 0., 12.]]) . a=np.array([[1,2,3],[3,4,4],[5,43,6]]) . b=np.array([[1],[2],[3]]) . b=b.repeat(3,axis=1) . b . array([[1, 1, 1], [2, 2, 2], [3, 3, 3]]) . 이제 원소대 원소 곱해주면 된다 | . c=a*b . c . array([[ 1, 2, 3], [ 6, 8, 8], [ 15, 129, 18]]) . broadcasting :size알아서 처리해주는 기능 . a . array([[ 1, 2, 3], [ 3, 4, 4], [ 5, 43, 6]]) . b=np.array([[1],[2],[3]]) . a*b . array([[ 1, 2, 3], [ 6, 8, 8], [ 15, 129, 18]]) . 또는 . def f(x,y): return x*y . b=np.fromfunction(f,(5,4),dtype=int) . b #이건 그냥 임의의 행렬만 만들어준 것 . array([[ 0, 0, 0, 0], [ 0, 1, 2, 3], [ 0, 2, 4, 6], [ 0, 3, 6, 9], [ 0, 4, 8, 12]]) . . a=np.array([10,20,30,40,50]) b=np.array([30,50]) . np.setdiff1d(a,b) . array([10, 20, 40]) . . a=np.random.randint(100) . a# 0부터99까지에서 하나 random으로 get . 2 . . import matplotlib.pyplot as plt %matplotlib inline . y=np.array([10,20,30]) . plt.plot(y) . [&lt;matplotlib.lines.Line2D at 0x1d56dcc9f40&gt;] . x=np.array([123,413,555]) . plt.plot(x,y,&#39;r--.&#39;) #data가 들어간 곳에 dot으로 표시 . [&lt;matplotlib.lines.Line2D at 0x1d56dfbc370&gt;] . plt.plot(x,y,&#39;b-o&#39;,label=&#39;fuck&#39;) plt.ylabel(&#39;sd&#39;) plt.xlabel(&#39;SD&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x1d56f28e1c0&gt; . hf=plt.figure() # 도화지 ha = hf.add_axes([0,0,1,1]) ha.plot(x,y) . [&lt;matplotlib.lines.Line2D at 0x1d56f3b10d0&gt;] . aa,bb=plt.subplots() hong,=bb.plot(x,y) # 이렇게 aa,bb는 임의로 지명 가능 . 위에 있는 그래프를 update해보자 . a_new=np.array([200,331,335]) b_new=np.array([10,50,10]) hong.set_data(a_new,b_new) aa . 그런데 주의해야 할 점에 애초에 aa라는 도화지에 정해진 축이 있기 때문에 그 축에서 너무 멀어지는 값들을 넣어주면 aa라는 도화지에 보이지 않을 수 있음 . PLUS=1.5 a_new=np.array([200,331,335]) b_new=np.array([10,50,10]) hong.set_data(a_new,PLUS*b_new) aa . 그래프가 올라간 것을 확인할 수 있음 . a=np.linspace(0,2,100) y1=0.5*a y2=0.5*a**2 y3=0.5*a**3 plt.plot(a,y1,label=&#39;1D&#39;) plt.plot(a,y2,label=&#39;2D&#39;) plt.plot(a,y3,label=&#39;3D&#39;) plt.legend() plt.xlabel(&#39;X&#39;) plt.ylabel(&#39;Y&#39;) plt.title(&#39;GRAPH&#39;) . Text(0.5, 1.0, &#39;GRAPH&#39;) . fig,ax=plt.subplots() ax1,=ax.plot(a,y1) # 여기서 ax1 후에 comma입력해주는 이유가 속성을 나중에 다 받아오기 위해서 ax2,=ax.plot(a,y2) ax3,=ax.plot(a,y3) ax.set_xlabel(&#39;X&#39;) # plt가 아닐 땐 set을 입력해줘야 함 ax.set_ylabel(&#39;Y&#39;) ax1.set_label(&#39;1&#39;) ax2.set_label(&#39;2&#39;) ax3.set_label(&#39;3&#39;) ax.legend() . &lt;matplotlib.legend.Legend at 0x1d570be0d90&gt; . ax1.set_color(&#39;k&#39;) ax2.set_color(&#39;b&#39;) ax3.set_color(&#39;r&#39;) ax.grid() ax.legend() fig . decay sin . t=np.linspace(0,100,1000) tau= 60 y=np.sin(t)*np.exp(-t/tau) plt.plot(t,y,label=&#39;Decay Oscillating Response&#39;) plt.ylabel(&#39;y[m]&#39;) plt.xlabel(&#39;t[s]&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x1d571e860d0&gt; . t가 커질수록 진폭이 천천히 줄어들게 됨 . Euler eq . t=np.linspace(0,1,100) f= 1 # 주파수 y_euler=np.exp(1j*2*np.pi**f*t) y_cos = np.real(y_euler) y_sin=np.imag(y_euler) fig,ax=plt.subplots() ax.plot(t,y_cos,&#39;-r&#39;,label=&#39;cos&#39;) ax.plot(t,y_sin,&#39;--b&#39;,label=&#39;sin&#39;) ax.grid() ax.legend() . &lt;matplotlib.legend.Legend at 0x1d5720b8640&gt; . fig,ax=plt.subplots(2,) ax[0].plot(t,y_cos,&#39;-r&#39;,label=&#39;cos&#39;) ax[1].plot(t,y_sin,&#39;--b&#39;,label=&#39;sin&#39;) ax[0].grid() ax[0].legend() ax[1].grid() ax[1].legend() . &lt;matplotlib.legend.Legend at 0x1d572190dc0&gt; . Histogram . data=np.random.randn(500000) plt.hist(data,100,density=True) # 100개의 막대로 나누겠다, 확률밀도함수로 그리겠다 x=np.linspace(-4,4,100) sigma=1 mean=0 nd=(1/(sigma*np.sqrt(2*np.pi)))*np.exp(-0.5*((x-mean)/sigma)**2) plt.plot(x,nd,&#39;r&#39;,label=&#39;Std Normal Dist&#39;) plt.ylabel(&#39;PSD&#39;) plt.xlabel(&#39;X&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x1d572746820&gt; . 3D plot . x=np.linspace(0,2*np.pi,10) y=np.linspace(0,2*np.pi,10) grid_x,grid_y=np.meshgrid(x,y) # 1차원 array를 통해 2차원 grid를 만들어줌 z=np.sin(grid_x)*np.sin(grid_y) fig=plt.figure() ax=fig.gca(projection=&#39;3d&#39;) # Get Current Axis=gca ax.plot_surface(grid_x,grid_y,z,cmap=&#39;jet&#39;) ax.set_xlabel(&#39;x&#39;) ax.set_ylabel(&#39;y&#39;) ax.set_zlabel(&#39;z&#39;) . C: Users ehfus AppData Local Temp/ipykernel_7852/1177705184.py:6: MatplotlibDeprecationWarning: Calling gca() with keyword arguments was deprecated in Matplotlib 3.4. Starting two minor releases later, gca() will take no keyword arguments. The gca() function should only be used to get the current axes, or if no axes exist, create new axes with default keyword arguments. To create a new axes with non-default arguments, use plt.axes() or plt.subplot(). ax=fig.gca(projection=&#39;3d&#39;) # Get Current Axis=gca . Text(0.5, 0, &#39;z&#39;) . Animation . # x=np.array([1,2,3,4,5]) # y=np.array([1,1,1,1,1]) # ax1, = ax.plot(x,y) # ax.set_ybound([0,11]) # for i in range(0,11,1): # ax1.set_ydata(i*y) # plt.pause(0.3) # # 원래는 animation기능으로 움직여야 함 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/25/intro.html",
            "relUrl": "/2021/12/25/intro.html",
            "date": " • Dec 25, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "2022/12/24/FRI",
            "content": "import numpy as np . np.linspace(0,4,5) . array([0., 1., 2., 3., 4.]) . np.arange(10) # 0부터 10개의 숫자 . array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) . a=np.array([10,20,3]) . a.shape # array의 shape을 알려줌 # 1차원 행렬에 방 세개 . (3,) . a.ndim #1차원 . 1 . a.dtype #array에 들어간 숫자들이 어떤 형식으로? . dtype(&#39;int32&#39;) . a.itemsize # 4byte 32=4*8 . 4 . a.size #몇개 들어가 있니 . 3 . type(a) #몇차원이고 될 수 있음, nd=ndimension . numpy.ndarray . np.array도 sequence 타입 =&gt; index,slicing가능 | . a[2] . 3 . a[2]=30.8 . a . array([10, 20, 30]) . 소수점 날라가고 30으로 저장됨 . a.dtype . dtype(&#39;int32&#39;) . a=a.astype(&#39;float64&#39;) . a[2]=30.865 . a . array([10. , 20. , 30.865]) . a.dtype . dtype(&#39;float64&#39;) . 소수점도 가능한 자료형으로 변경해줬음 | . b=np.array([10.,20.,30.]) . b.dtype . dtype(&#39;float64&#39;) . 애초에 이렇게 dot을 지정해주고 들어가면 float으로 활용가능 . c=np.array([10.2,20.3,50.58],&#39;int32&#39;) . c . array([10, 20, 50]) . 이렇게 &#39;int32&#39;로 지정해줄 수 있음 . x=np.array([7,9,11]) y=x/2 . y . array([3.5, 4.5, 5.5]) . x.dtype . dtype(&#39;int32&#39;) . y.dtype . dtype(&#39;float64&#39;) . x가 정수로 시작했어도 y는 divide를 사용하고 있기에 알아서 np에서 float64로 지정함 . int32 $vs$ int64 . x=np.array([0]) . x[0]=2147483647 . x . array([2147483647]) . x[0]=x[0]+1 . C: Users ehfus AppData Local Temp/ipykernel_11512/4237261130.py:1: RuntimeWarning: overflow encountered in long_scalars x[0]=x[0]+1 . 2147483647은 int32에서 수용할 수 있는 최대의 숫자임, 따라서 여기서 1만 더해주더라도 수용하지 못하게 됨 . x=np.array([0],&#39;int64&#39;) . x[0]=2147483647 . x[0]+1 . 2147483648 . dtype을 int64로 바꿨기 때문에 int32에서 최대였던 것보다 더 수용할 수 있게 됨 . a=np.array([10,&#39;abc&#39;,20]) # 꼭 list형태로 줘야 함 . a.dtype #섞여있음 . dtype(&#39;&lt;U11&#39;) . a*2 . UFuncTypeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11512/434652760.py in &lt;module&gt; -&gt; 1 a*2 UFuncTypeError: ufunc &#39;multiply&#39; did not contain a loop with signature matching types (dtype(&#39;&lt;U11&#39;), dtype(&#39;int32&#39;)) -&gt; None . 섞여있으면 이런 연산은 불가 . a=np.array([[10,20,30],[40,50,60]]) . a # 2차원 . array([[10, 20, 30], [40, 50, 60]]) . a.shape # 2x3행렬로 해석해도 될듯 . (2, 3) . a.itemsize . 4 . a.size . 6 . a=np.array([[10,20,30],[40,50,60],[5,6,8]]) . a . array([[10, 20, 30], [40, 50, 60], [ 5, 6, 8]]) . a.size . 9 . a=np.array([[10,20,30], [40,50,60], [55,54,88] ,[112,123,41]]) . a . array([[ 10, 20, 30], [ 40, 50, 60], [ 55, 54, 88], [112, 123, 41]]) . a.ndim . 2 . a.shape . (4, 3) . a=np.array([10+10j,10+60j]) . a . array([10.+10.j, 10.+60.j]) . a=np.array([10,20],&#39;complex&#39;) . a . array([10.+0.j, 20.+0.j]) . . a=np.array([10,20]) . b=np.matrix([10,20]) . a.ndim . 1 . b.ndim . 2 . b=np.matrix([[[10]]]) . ValueError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11512/2972594669.py in &lt;module&gt; -&gt; 1 b=np.matrix([[[10]]]) ~ Anaconda3 envs dv2021 lib site-packages numpy matrixlib defmatrix.py in __new__(subtype, data, dtype, copy) 147 shape = arr.shape 148 if (ndim &gt; 2): --&gt; 149 raise ValueError(&#34;matrix must be 2-dimensional&#34;) 150 elif ndim == 0: 151 shape = (1, 1) ValueError: matrix must be 2-dimensional . 2차원을 넘어간 3차원이기에 불가능 . a=np.array([10,20,30]) . a=np.insert(a,2,5) # a라는 np.array의 2번째 인덱스에 5를 넣어라 . a . array([ 5, 10, 5, 5, 20, 30]) . a=np.delete(a,5) . a # 다섯번째 인덱스 삭제 . array([ 5, 10, 5, 5, 20]) . a=np.array([1,2,3]) . a=np.arange(3) . a # 0부터 시작해서 숫자 3개를 채워줌 . array([0, 1, 2]) . a=np.zeros((2,3)) . a . array([[0., 0., 0.], [0., 0., 0.]]) . a=np.ones((2,3)) . a . array([[1., 1., 1.], [1., 1., 1.]]) . a=np.linspace(0,5,4) #0부터 5까지 4개로 . a . array([0. , 1.66666667, 3.33333333, 5. ]) . a=np.linspace(0,5,6) #0부터 5까지 6개로 . a . array([0., 1., 2., 3., 4., 5.]) . a=np.logspace(0,5,4) # log scale로! . a . array([1.00000000e+00, 4.64158883e+01, 2.15443469e+03, 1.00000000e+05]) . . a=np.array([10,20,30]) b=np.array([1,2,3]) . a+b . array([11, 22, 33]) . a-b . array([ 9, 18, 27]) . b-a . array([ -9, -18, -27]) . a*b . array([10, 40, 90]) . a/b . array([10., 10., 10.]) . c=a**2 . c . array([100, 400, 900], dtype=int32) . idx=a&lt;20 . idx . array([ True, True, True]) . type(idx) . numpy.ndarray . a=a+1 . a . array([2, 3, 4]) . a+=1 . a . array([3, 4, 5]) . a*=2 . a . array([ 6, 8, 10]) . a=a*2 . a . array([12, 16, 20]) . a=np.array([10,50,9]) # int b=np.array([50.,5.,8.]) #float . a+=b . UFuncTypeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11512/953131135.py in &lt;module&gt; -&gt; 1 a+=b UFuncTypeError: Cannot cast ufunc &#39;add&#39; output from dtype(&#39;float64&#39;) to dtype(&#39;int32&#39;) with casting rule &#39;same_kind&#39; . a에b를 더해서 a를 업데이트 하는 건 자료형이 달라서 안 된다고 함 . 되게 하려면 자료형을 맞춰주면 됨 . c=a+b # 이건 됨 . c . array([60., 55., 17.]) . . a=np.array([10,50,9]) b=np.array([50,5,8]) . np.add(a,b) . array([60, 55, 17]) . np.subtract(a,b) . array([-40, 45, 1]) . np.divide(a,b) . array([ 0.2 , 10. , 1.125]) . np.multiply(a,b) . array([500, 250, 72]) . np.divmod(a,b) # 몫과 나머지 . (array([ 0, 10, 1], dtype=int32), array([10, 0, 1], dtype=int32)) . np.exp(b) . array([5.18470553e+21, 1.48413159e+02, 2.98095799e+03]) . np.sqrt(a) . array([3.16227766, 7.07106781, 3. ]) . . a=np.array([10,20,3]) . np.mean(a) . 11.0 . a.mean() . 11.0 . np.average(a) . 11.0 . np.average(a,weights=[1,1,1]) . 11.0 . np.average(a,weights=[1,1,0]) . 15.0 . np.average(a,weights=[0,1,1]) . 11.5 . np.median(a) . 10.0 . np.cumsum(a) # 앞에 있는 숫자들을 더해주는 것 . array([10, 30, 33], dtype=int32) . np.cov(a) . array(73.) . np.std(a) . 6.97614984548545 . np.var(a) . 48.666666666666664 . x=np.array([10,20,30]) . x.sum() . 60 . x=np.array([10.,40.,20.,5.,15.]) . x.min() . 10.0 . x.max() . 50.0 . x.argmin() # index 0에 최솟값이 존재함 . 0 . x_min,x_min_idx=x.min(),x.argmin() . # 최솟값과 최댓값의 차이 x.ptp() . 40.0 . y=np.sort(x) . y . array([ 5., 10., 15., 20., 40.]) . idx = np.argsort(x) . idx . array([3, 0, 4, 2, 1], dtype=int64) . y . array([ 5., 10., 15., 20., 40.]) . sort된 값들이 원래 어디에 위치해 있었는지 . x[idx] . array([ 5., 10., 15., 20., 40.]) . y=x[idx] . y . array([ 5., 10., 15., 20., 40.]) . a=np.array([20,10,30]) b=np.array([-5,25]) . np.searchsorted(a,b) . array([0, 2], dtype=int64) . b를 a에 넣을 때 어느 자리에 넣어야 sorting이 유지가 되는지? | . d=np.arange(1,7,1) . d . array([1, 2, 3, 4, 5, 6]) . d.shape . (6,) . d.reshape(2,3) . array([[1, 2, 3], [4, 5, 6]]) . d 자체를 바꿔주는 건 아님 | . e=d.reshape(2,3) . f=np.linspace(1,10,10) . f . array([ 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.]) . g=np.linspace(1,10,10).reshape(2,5) . g . array([[ 1., 2., 3., 4., 5.], [ 6., 7., 8., 9., 10.]]) . a=np.array([[1,2],[3,4]])#2차원 . a . array([[1, 2], [3, 4]]) . np.repeat(a,2) . array([1, 1, 2, 2, 3, 3, 4, 4]) . np.repeat(a,2,axis=0) . array([[1, 2], [1, 2], [3, 4], [3, 4]]) . np.repeat(a,2,axis=1) . array([[1, 1, 2, 2], [3, 3, 4, 4]]) . np.repeat(a,[1,2],axis=0) . array([[1, 2], [3, 4], [3, 4]]) . np.repeat(a,[3,1],axis=0) . array([[1, 2], [1, 2], [1, 2], [3, 4]]) . np.repeat(a,[1,2],axis=1) . array([[1, 2, 2], [3, 4, 4]]) . np.repeat(a,[3,1],axis=1) . array([[1, 1, 1, 2], [3, 3, 3, 4]]) . a=np.array([[1],[2],[3]]) b=np.array([[4],[5],[6]]) . a.shape . (3, 1) . b.shape . (3, 1) . np.concatenate((a,b),axis=0) # array 두개 연결 . array([[1], [2], [3], [4], [5], [6]]) . np.concatenate((a,b),axis=1) . array([[1, 4], [2, 5], [3, 6]]) . (a,b)이렇게 tuple 형태로 입력해줘야 함 | . a=np.array([10,20,30]) b=np.array([40,50,60]) . np.vstack((a,b)) . array([[10, 20, 30], [40, 50, 60]]) . np.hstack((a,b)) . array([10, 20, 30, 40, 50, 60]) . a=np.array([[10,20,30],[40,50,60]]) . a . array([[10, 20, 30], [40, 50, 60]]) . # 오류 발생, 왜? 세로 방향으로 2개로 나눌 수가 없어서 . a=np.hsplit(a,3) . a . [array([[10], [40]]), array([[20], [50]]), array([[30], [60]])] . a.shape . AttributeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_2492/1739083353.py in &lt;module&gt; -&gt; 1 a.shape AttributeError: &#39;list&#39; object has no attribute &#39;shape&#39; . 보다시피 list안에 np.array가 들어갔음 . a[0] . array([[10], [40]]) . a=np.array([[10,20,30],[40,50,60]]) . np.vsplit(a,2) . [array([[10, 20, 30]]), array([[40, 50, 60]])] . 이것또한 list로 저장 됨 . 어레이를 조각조각내서 리스트 안에 넣어줬기 때문에 . 그 조각을 살펴보면 np.array 형태이고 . 그 조각들을 list안에 넣어준 것 . a=np.array([[10,20,30],[40,50,60]]) . a . array([[10, 20, 30], [40, 50, 60]]) . a.transpose() . array([[10, 40], [20, 50], [30, 60]]) . 2차원의 array를 1차원의 array로 변경 . a . array([[10, 20, 30], [40, 50, 60]]) . a.ravel() . array([10, 20, 30, 40, 50, 60]) . a.reshape(-1) . array([10, 20, 30, 40, 50, 60]) . a.ravel(order=&#39;C&#39;) . array([10, 20, 30, 40, 50, 60]) . a.ravel(order=&#39;F&#39;) . array([10, 40, 20, 50, 30, 60]) . a.flatten() . array([10, 20, 30, 40, 50, 60]) . a=np.array([[1,2,3]]) # 2차원 형태로 넣어줌 . a_=np.array([1,2,3]) # 1차원 형태로 넣어줌 . &#52264;&#51060;&#51216; . a_[0] . 1 . a[0][0] . 1 . . a.ndim . 2 . a.shape . (1, 3) . 2차원에서 1차원으로 줄이자 . b=a.squeeze() . b . array([1, 2, 3]) . b.ndim . 1 . b.shape . (3,) . a=np.array([[[1,2]],[[3,4]],[[5,6]]]) . a . array([[[1, 2]], [[3, 4]], [[5, 6]]]) . a.shape . (3, 1, 2) . a.ndim . 3 . b=a.squeeze() . b . array([[1, 2], [3, 4], [5, 6]]) . b.shape . (3, 2) . a=np.array([1,2,3]) b=np.array([4,5,6]) . a.shape . (3,) . a_=a[:,np.newaxis] b_=b[:,np.newaxis] # 차원 하나 추가 . a_.shape . (3, 1) . np.concatenate((a_,b_),axis=0) . array([[1], [2], [3], [4], [5], [6]]) . np.concatenate((a_,b_),axis=1) . array([[1, 4], [2, 5], [3, 6]]) . np.vstack((a,b)) . array([[1, 2, 3], [4, 5, 6]]) . np.vstack((a,b)).transpose() . array([[1, 4], [2, 5], [3, 6]]) . np.hstack((a,b)).reshape((2,3)).transpose() . array([[1, 4], [2, 5], [3, 6]]) . shallow copy . deep copy . a=np.array([10,20,30]) . b=a . b . array([10, 20, 30]) . b[0]=909 . b . array([909, 20, 30]) . a . array([909, 20, 30]) . b is a . True . 즉 같은 메모리에 이름만 다르게 저장된 것 . a=np.array([1,2,3,4]) . b=a.view() . b . array([1, 2, 3, 4]) . b is a . False . b[0]=123123 . a . array([123123, 2, 3, 4]) . b . array([123123, 2, 3, 4]) . shallow copy를 했음에도 같이 업데이트 되어버림 . b.shape=(2,2) . b . array([[123123, 2], [ 3, 4]]) . b[0][1]=111 . b . array([[123123, 111], [ 3, 4]]) . a . array([123123, 111, 3, 4]) . 즉 shallow copy란 메모리 상에 data는 같이 공유하지만 array의 shape은 공유 X . 그렇다면 deep copy? . a=np.array([10,20,30,40]) . b=a.copy() . b[0]=8999 . a . array([10, 20, 30, 40]) . b . array([8999, 20, 30, 40]) . a is b . False . b.base is a . False . 즉 b만의 온전한 데이터를 만들 수 있음 . . a=np.array([55,0,12,3,4]) . # 여기선 0, 즉 FALSE값이 들어있기 때문에 FALSE로 나올 것 a.all() . False . a.any() . True . a.nonzero() . (array([0, 2, 3, 4], dtype=int64),) . np.where(a&gt;0) . (array([0, 2, 3, 4], dtype=int64),) . np.where(a==0) . (array([1], dtype=int64),) . np.where(a!=0) . (array([0, 2, 3, 4], dtype=int64),) . data filtering에 유용하게 사용될 것 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/24/intro.html",
            "relUrl": "/2021/12/24/intro.html",
            "date": " • Dec 24, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "2022/12/23/THU",
            "content": "s=&#39;&#39;&#39;python &#39;&#39;&#39; . s . &#39;python n n&#39; . print(s) . python . &#39;&#39;&#39; =&gt; 긴 str배정, 그리고 n n은 두줄이 들어갔음을 알려준 것 . s=&#39;python&#39; . s.capitalize() . &#39;Python&#39; . s.find(&#39;y&#39;) . 1 . s.find(&#39;a&#39;) . -1 . s.index(&#39;a&#39;) . ValueError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_7636/2338996384.py in &lt;module&gt; 1 # find와 유사하나 index는 없으면 -1이 아니라 error발생 -&gt; 2 s.index(&#39;a&#39;) ValueError: substring not found . index 또는 find 사용시 단어가 중복되면 처음 거 기준 출력 . a=&#39;pyathaon&#39; . a.find(&#39;a&#39;) . 2 . a.index(&#39;a&#39;) . 2 . a.isalpha() . True . s=&#39;asd3&#39; . s.isalnum() . True . a=&#39;python 3&#39; . a.isalnum() . False . a=&#39;python3&#39; . a.isalnum() . True . s=&#39;123&#39; . s.isdecimal() . True . s=&#39;223311.3&#39; . s.isdecimal() . False . s.isdigit() . False . s.isnumeric() . False . s=&#39;123123123&#39; . s.isdecimal() . True . a=&#39;2034&#39; . a.isdigit() . True . a=&#39;3 u00B3&#39; . a . &#39;3³&#39; . a.isdecimal() . False . a.isdigit() . True . a.isnumeric() . True . a=&#39; u00BC&#39; . a . &#39;¼&#39; . a.isdecimal() . False . a.isdigit() . False . a.isnumeric() . True . a=&#39;Python&#39; . a.islower() . False . a.isupper() . False . a=&#39;PythonP&#39; . 중요 . a.replace(&#39;P&#39;,&#39;Q&#39;) . &#39;QythonQ&#39; . a=&#39;I like python&#39; . 중요 . # space 기준으로 나눠서 리스트化 a.split(&#39; &#39;) . [&#39;I&#39;, &#39;like&#39;, &#39;python&#39;] . a=&#39;I,like,python&#39; . a.split(&#39;,&#39;) . [&#39;I&#39;, &#39;like&#39;, &#39;python&#39;] . str에서 다음줄로 내릴 때 . a=&#39;I like python nHe likes python nfucking python&#39; . a . &#39;I like python nHe likes python nfucking python&#39; . print(a) . I like python He likes python fucking python . a.splitlines() . [&#39;I like python&#39;, &#39;He likes python&#39;, &#39;fucking python&#39;] . b=a.splitlines() . b[0] . &#39;I like python&#39; . b[0].upper() . &#39;I LIKE PYTHON&#39; . b[0].count(&#39;L&#39;) . 0 . . s=&#39;python&#39; . a=3 . print(s,a) . python 3 . print =&gt; 문자로 알아서 프린트함 . a는 int니까 str으로 변경해서 ... . print(s,str(a)) . python 3 . print(s+str(a)) . python3 . print(s + &#39; &#39; + str(a)) . python 3 . print(s,str(a)) . python 3 . Format . s=&#39;Python {}&#39; . s.format(25) . &#39;Python 25&#39; . s.format(1+5) . &#39;Python 6&#39; . s=&#39;Python {1} + {0}&#39; . s.format(3,&#39;asdas&#39;) . &#39;Python asdas + 3&#39; . s=&#39;Python {0} {1}&#39; . s.format(3,&#39;asd&#39;) . &#39;Python 3 asd&#39; . s=&#39;Python {1} {0}&#39; . s.format(3,&#39;asd&#39;) . &#39;Python asd 3&#39; . s= &#39;My name is {} I am {} years old&#39; . s.format(&#39;asd&#39;,12) . &#39;My name is asd I am 12 years old&#39; . print(&#39;python 3.8&#39;) . python 3.8 . ver=3.8 . print(&#39;python&#39;, ver) . python 3.8 . print(&#39;python&#39; + str(ver)) . python3.8 . print(&#39;python{}&#39;.format(ver)) . python3.8 . s=&#39;python{}&#39;.format(ver) . print(s) . python3.8 . . data=4321.123456 . print(&#39;DATA&#39;+str(data)) . DATA4321.123456 . print(&#39;DATA&#39;, data) . DATA 4321.123456 . print(&#39;DATA &#39;+str(data)) . DATA 4321.123456 . print(&#39;DATA= &#39;+str(data)) . DATA= 4321.123456 . print(&#39;DATA={}&#39;.format(data)) . DATA=4321.123456 . &#51473;&#50836; . {0:&lt;10} =&gt; {0} 값을 &quot;:&lt;10&quot; 10자리로 표현할건데 왼쪽 정렬 | {1:&gt;5} =&gt; {1} 값을 &quot;:&gt;5&quot; 5자리로 표현할건데 오른쪽 정렬 | :^10 = 가운데 정렬 | . print(&#39;DATA= {:.2f}&#39;.format(data)) . DATA= 4321.12 . print(&#39;DATA= {:.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:4.0f}&#39;.format(data)) . DATA=4321 . print(&#39;DATA={:5.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:6.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:7.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:,}&#39;.format(data)) . DATA=4,321.123456 . data2=454654456.1213546 . print(&#39;DATA={:,}&#39;.format(data2)) . DATA=454,654,456.1213546 . data자체가 float이라서 d입력하면 오류가 발생 . print(&#39;DATA={:.4d}&#39;.format(int(data))) . ValueError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_7636/488746504.py in &lt;module&gt; -&gt; 1 print(&#39;DATA={:.4d}&#39;.format(int(data))) ValueError: Precision not allowed in integer format specifier . int는 .없으니까 .4d이렇게 입력하면 오류 . print(&#39;DATA={:4d}&#39;.format(int(data))) . DATA=4321 . print(&#39;DATA={:5d}&#39;.format(int(data))) . DATA= 4321 . print(&#39;DATA={:8d}&#39;.format(int(data))) . DATA= 4321 . scientific notation :e라는 것을 사용하여 수를 표현해줌 . print(&#39;data = {:e}&#39;.format(data)) . data = 4.321123e+03 . print(&#39;DATA=%(x)f&#39; % {&#39;x&#39; : data}) . DATA=4321.123456 . print(&#39;DATA=%(x).0f&#39; % {&#39;x&#39; : data}) . DATA=4321 . print(&#39;DATA=%(x).2f&#39; % {&#39;x&#39; : data}) . DATA=4321.12 . print(&#39;DATA=%(x)7.0f&#39; % {&#39;x&#39; : data}) . DATA= 4321 . print(&#39;DATA=%(x)8.3f&#39; % {&#39;x&#39; : data}) . DATA=4321.123 . print(&#39;DATA=%(x)8.0f&#39; % {&#39;x&#39; : data}) . DATA= 4321 . . import math . math.pi . 3.141592653589793 . math.inf . inf . math.nan #숫자가 아님을 표현할 때 . nan . math.e . 2.718281828459045 . math.floor(math.pi) . 3 . math.ceil(math.pi) . 4 . math.sqrt(math.pi) . 1.7724538509055159 . math.log(10) . 2.302585092994046 . math.log(math.e) . 1.0 . math.log10(10) . 1.0 . p=math.pi . math.sin(p/2) . 1.0 . math.sin(2*p) . -2.4492935982947064e-16 . x_degree=90 . x_radian=x_degree*(math.pi/180) . x_radian #pi/2랑 동일 . 1.5707963267948966 . math.radians(90) . 1.5707963267948966 . math.pow(2,3) . 8.0 . pow(2,3) . 8 . 2**3 . 8 . x=2 . math.isinf(x) . False . math.isnan(x) . False . math.fsum([1,2,3]) . 6.0 . math.fsum([1,2,&#39;3&#39;]) . TypeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_7636/3003999967.py in &lt;module&gt; -&gt; 1 math.fsum([1,2,&#39;3&#39;]) TypeError: must be real number, not str . int여야 함 . . file// input output . import os . os.getcwd() . &#39;c: &#39; . os.chdir(&#39;c: test&#39;) . os.mkdir(&#39;temp2&#39;) . os.chdir(&#39;temp2&#39;) . os.getcwd() . &#39;c: test temp2&#39; . os.chdir(&#39;..&#39;) . os.getcwd() . &#39;c: test&#39; . os.chdir(&#39;temp&#39;) . os.getcwd() . &#39;c: test temp&#39; . os.chdir(&#39;.&#39;) . os.getcwd() . &#39;c: test temp&#39; . os.mkdir(&#39;dir0&#39;) . os.mkdir(&#39;dir1&#39;) . os.mkdir(&#39;dir2&#39;) . os.getcwd() . &#39;c: test temp&#39; . os.listdir() . [&#39;dir0&#39;, &#39;dir1&#39;, &#39;dir2&#39;, &#39;file1.txt&#39;, &#39;file2.txt&#39;, &#39;file3.txt&#39;, &#39;file4.txt&#39;] . os.rename(&#39;dir0&#39;,&#39;dir100&#39;) . os.listdir() . [&#39;dir1&#39;, &#39;dir100&#39;, &#39;dir2&#39;, &#39;file1.txt&#39;, &#39;file2.txt&#39;, &#39;file3.txt&#39;, &#39;file4.txt&#39;] . os.rmdir(&#39;dir100&#39;) . os.listdir() . [&#39;dir1&#39;, &#39;dir2&#39;, &#39;file1.txt&#39;, &#39;file2.txt&#39;, &#39;file3.txt&#39;, &#39;file4.txt&#39;] . import sys . # 파이썬에서 사용가능한 모듈들을 불러준 것 . # sys.path . os.chdir(&#39;C: Users ehfus Downloads python Introduction&#39;) . os.chdir(&#39;c: test temp&#39;) . os.getcwd() . &#39;c: test temp&#39; . . f=open(&#39;file1.txt&#39;,&#39;w&#39;)#파일 작성 . f.closed . False . f.write(&#39;fucking&#39;) . 7 . f.close() . f.closed . True . with open(&#39;file2.txt&#39;,&#39;w&#39;) as f: f.write(&#39;sibal n&#39;) f.write(&#39;jotgatne n&#39;) f.write(&#39;just joke n&#39;) . f.closed . True . fid=open(&#39;file2.txt&#39;,&#39;r&#39;) . fid.read() . &#39;sibal njotgatne njust joke n&#39; . fid.close() . fid.closed . True . fid=open(&#39;file2.txt&#39;,&#39;r&#39;) . fid.readline() . &#39;sibal n&#39; . fid.readline() . &#39;jotgatne n&#39; . fid.readline() . &#39;just joke n&#39; . fid.readline() . &#39;&#39; . 한 줄씩 불러옴 . fid.close() . fid=open(&#39;file2.txt&#39;,&#39;r&#39;) . data=[] . data.append(fid.readline()) . data.append(fid.readline()) . data.append(fid.readline()) . data . [&#39;sibal n&#39;, &#39;jotgatne n&#39;, &#39;just joke n&#39;] . 자동화 . fid=open(&#39;file2.txt&#39;,&#39;r&#39;) . for line in fid: line . data=[&#39;string1&#39;,&#39;string2&#39;,&#39;string3&#39;] . import json . f=open(&#39;file3.txt&#39;,&#39;w&#39;) . json.dump(data,f) . f.close() . f=open(&#39;file3.txt&#39;,&#39;r&#39;) . x=json.load(f) . x . [&#39;string1&#39;, &#39;string2&#39;, &#39;string3&#39;] . f.close() . import pickle . f=open(&#39;file4.txt&#39;,&#39;wb&#39;) # 바이너리로 쓰겠다 . 용량을 작게 할 수 있다는 장점이 있음 . pickle.dump(data,f) . f.close() . f=open(&#39;file4.txt&#39;,&#39;rb&#39;) # 바이너리 불러옴 . x= pickle.load(f) . x . [&#39;string1&#39;, &#39;string2&#39;, &#39;string3&#39;] . f.close() .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/23/intro.html",
            "relUrl": "/2021/12/23/intro.html",
            "date": " • Dec 23, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "2021/12/22/WED",
            "content": "&#51088;&#47308;&#54805; . 정수(int) | . 1 . 1 . 소수(float) | . 1.2 . 1.2 . 복소수(complex) | . 1.2+2j . (1.2+2j) . 문자형(str) &gt; 따옴표 하나 혹은 두개 가능 | . &#39;a&#39;,&quot;hello&quot; . (&#39;a&#39;, &#39;hello&#39;) . 참, 거짓형(bool) | . True . True . . 자료의 형태를 알고 싶을 때 | . type(True) . bool . . 자료형 변환 | . int() . 0 . str() . &#39;&#39; . bool() . False . int(1) . 1 . int(1.3) . 1 . int(1.8) . 1 . int(&#39;1&#39;) # str -&gt; int . 1 . float(&#39;3.14&#39;) # sre -&gt; float . 3.14 . 그런데 &#39;3.14&#39;이 str형태를 int로 변환할 순 없음 . float(&#39;-inf&#39;) . -inf . complex(1) . (1+0j) . complex(3+5j) . (3+5j) . complex(3,5.5) . (3+5.5j) . complex(&#39;1+3j&#39;) . (1+3j) . str(1) . &#39;1&#39; . str(2+5j) . &#39;(2+5j)&#39; . str(&quot;asdasdas&quot;) . &#39;asdasdas&#39; . bool(1) . True . bool(0) . False . bool(23123) . True . 0이 아닌 다른 수는 모두 True . bool(float(&#39;inf&#39;)) . True . float(&#39;inf&#39;),bool(&#39;-inf&#39;),complex(&#39;inf&#39;) . (inf, True, (inf+0j)) . bool(-0.8) . True . bool(&#39;&#39;) . False . bool(&#39;aasdss&#39;) . True . &#50672;&#49328; . 1+1,3-2,5*2,5/2 . (2, 1, 10, 2.5) . 5//2 . 2 . 5%2 . 1 . abs(-232) . 232 . divmod(5,3) . (1, 2) . pow(5,4),5**4 . (625, 625) . 2+1*5 . 7 . &#39;asdasd&#39;+&#39;asdfeq&#39; . &#39;asdasdasdfeq&#39; . &#39;asdasd&#39;+str(235456) . &#39;asdasd235456&#39; . # &#39;asdasd&#39;+2 . True+True . 2 . &#48708;&#44368; &#50672;&#49328; =&gt; &#44208;&#44284;&#45716; BOOL&#54805;&#53468;&#47196; &#52636;&#47141;&#46120; . 1&lt;0 . False . 2==3 . False . 틀린 지 물어보기 . 1!=3 # 틀렸으니 맞다고 나올 것 . True . 3 is 4 . &lt;&gt;:1: SyntaxWarning: &#34;is&#34; with a literal. Did you mean &#34;==&#34;? &lt;&gt;:1: SyntaxWarning: &#34;is&#34; with a literal. Did you mean &#34;==&#34;? C: Users ehfus AppData Local Temp/ipykernel_4876/1052624616.py:1: SyntaxWarning: &#34;is&#34; with a literal. Did you mean &#34;==&#34;? 3 is 4 . False . 그런데 is나 is not은 원래 자료형 비교할 때 사용함 . type(&#39;123&#39;) is not type(True) . True . True and False . False . True and False and True . False . 즉 거짓이 하나라도 있으면 거짓 처리 . True or False . True . True or False or False . True . 즉 참이 하나라도 있으면 참 처리 . not True . False . 참과 거짓을 반대로 바꿔주는 기능 . 100 and 1 # 둘다 참 -&gt; 참 처리 . 1 . 0 and 100 # 하나 거짓 -&gt; 거짓 처리 . 0 . 1 and 100 # 둘다 참 -&gt; 100 출력 # 100 and 1 일 땐 1 출력 . 100 . 100 or 1 # 둘다 참 -&gt; 100 출력 . 100 . 1 and 0 and 100 . 0 . 1 and 10 and 100 . 100 . 1 and 10 and 2 . 2 . 1 and 2 or 100 . 2 . 1 or 3 and 100 . 1 . 1 or 3 or 100 . 1 . 10 or 1 . 10 . Bitwise . 2 #십진법 . 2 . bin(2) # 이진법 . &#39;0b10&#39; . bin(3) . &#39;0b11&#39; . bin(12) . &#39;0b1100&#39; . bin(6) . &#39;0b110&#39; . ??? &amp; . 10&amp;6 . 2 . bin(10) . &#39;0b1010&#39; . bin(6) . &#39;0b110&#39; . bin(10&amp;6) . &#39;0b10&#39; . bin(10|6) . &#39;0b1110&#39; . bin(10^6) . &#39;0b1100&#39; . 10^6 . 12 . bin(6&lt;&lt;2) . &#39;0b11000&#39; . bin(6&gt;&gt;2) . &#39;0b1&#39; . 6&gt;&gt;2 . 1 . &#48320;&#49688; . a=1 a . 1 . print(a) . 1 . b=3.225 . type(b) . float . b=546548 . b # b의 정의가 업데이트 . 546548 . d=True . print(d) . True . b=a . b # 다른 변수로 해당 변수를 업데이트 할 수 있음 . 1 . a=5 . a . 5 . b . 1 . a가 바뀌어도 a로 업데이트 된 b는 그 전 a의 자료인 1로 그대로 유지 중 . length=2 width=3 area=length*width . x=1 . y=2*x . y . 2 . a=3 . bin(a) . &#39;0b11&#39; . a.bit_length() . 2 . b=10 . bin(b) . &#39;0b1010&#39; . b.bit_length() . 4 . c=1+2j . c.conjugate() . (1-2j) . c.real # c 안의 실수 . 1.0 . c.imag # c 안의 허수 . 0 . a=1 . a+=1 # a에 있는 값을 1만큼 올려서 저장 . a . 2 . a-=10 . a . -8 . name=&#39;tom&#39; . name.capitalize() # 맨 앞을 대문자 처리 . &#39;Tom&#39; . name.count(&#39;2&#39;) #name이라는 변수에 2 몇개?, 대문자 소문자도 구별해서 카운트함 . 0 . name.split(&#39;o&#39;) # o 없애고 나눠줌 # 리스트 형태로 저장됨 . [&#39;t&#39;, &#39;m&#39;] . &#39;asdasd&#39;.capitalize() . &#39;Asdasd&#39; . a=&#39;i &#39;m student&#39; . a . &#34;i&#39;m student&#34; . 즉 백 슬러시 다음에 심볼 적으면 심볼로 인식하게 됨 . a=&#39;ASDASD&#39; . a*3 . &#39;ASDASDASDASDASDASD&#39; . input을 유저한테 받아올 때 . input(&#39;enter: &#39;) . &#39;3&#39; . a=input(&#39;enter: &#39;) . a # str으로 저장됨 . &#39;3&#39; . age=int(input(&#39;enter your age: &#39;)) . age # int로 저장됨 . 23 . 변수 지우기 . del age . a=1 b=3 a==b . False . a.__eq__(b) # a==b랑 동일 . False . a,b=10,134 . a와 b 교환 . a,b=b,a . . str=1 . str(1.3) . TypeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11492/930539355.py in &lt;module&gt; -&gt; 1 str(1.3) TypeError: &#39;int&#39; object is not callable . 즉 파이썬과 지원되는 함수와 동일한 변수명 사용하면 안 됨 . Container . list. tuple. set. frozenset. dictionary. . list &#49688;&#51221; &#44032;&#45733; . asd=[10,25,&#39;123&#39;,True] # 방법 1 . asdasd=list([10,25,&#39;123&#39;,True]) # 방법 2 . tuple &#49688;&#51221; &#48520;&#44032;&#45733; . qwe=(12,22.1,&#39;qwe&#39;) . qwe . (12, 22.1, &#39;qwe&#39;) . qweqwe=tuple([1,2,3,&#39;asdasd&#39;,True]) . qweqwe . (1, 2, 3, &#39;asdasd&#39;, True) . 자료 불러오기 . asd[0] . 10 . qwe[0] . 12 . list와 tuple은 sequence자료형 . vip_names = [&#39;c&#39;,&#39;d&#39;,&#39;a&#39;] . vip_names[0]=&#39;랴차&#39; . vip_names . [&#39;랴차&#39;, &#39;d&#39;, &#39;a&#39;] . list는 자료 수정이 가능하나 . tuple은 자료 수정 불가능하다 . my_list1=[12,123,123,123,42,14] . slicing . my_list1[0:2] #0,1번 원소 추출 . [12, 123] . my_list1[:] # 모든 자료 . [12, 123, 123, 123, 42, 14] . my_list1[::2] # 모든 자료형태에서 2단위로 추출 . [12, 123, 42] . my_list1[:3:2] # 0,1,2원소를 2단위로 추출 . [12, 123] . my_list1[::2] . [12, 123, 42] . my_list1[-1] . 14 . my_list1[-5:-1] # -1값은 해당 X . [123, 123, 123, 42] . my_list1[-5] . 123 . my_list1[-1::-1] # 뒤에서부터 가져올 땐 단위도 - 붙여줘야 함 . [14, 42, 123, 123, 123, 12] . my_list1[-1:2:-1] # 두번째 인덱스 전까지 뒤로 추출 . [14, 42, 123] . my_list1[-1:1:-1] # 뒤에서부터 가져오기 뒤로 . [14, 42, 123, 123] . my_list1[-4:5:1] # 뒤에서부터 가져오기 . [123, 123, 42] . ::1,::-1 즉 플러스면 앞으로 가며 읽어주고 마이너스면 뒤로 가면서 읽어줌 . 리스트 중첩 가능 . my_list2 = [[1,2,3,4,5],[1232]] . my_list4 = [[1,2,3,4,5], [1,2,3,4], &quot;ㅁㄴㅇㅁㄴㅇ&quot;] # 이렇게 복잡할 땐 한줄 내려서 입력해도 가능하다 . my_list4[0][3] . 4 . my_list4[1][::2] . [1, 3] . my_list5 = [ [10,20,[100,200,300]], [40,50,60] ] . my_list5[0][2][2] # 리스트 중첩 후 원소 불러오기 . 300 . a=[1,2] b=[123,2323] . a+b . [1, 2, 123, 2323] . 리스트의 덧셈은 그냥 자료룰 연결함 . a=[[1,2],[1,2,3]] . b=[[1,2,&#39;s&#39;],[1,2,3]] . a+b . [[1, 2], [1, 2, 3], [1, 2, &#39;s&#39;], [1, 2, 3]] . 리스트에서 연산은 더해주는 것이기 때문에 -는 지원 . 곱셈은 지원 가능 . a*2 . [[1, 2], [1, 2, 3], [1, 2], [1, 2, 3]] . old_a=[1,2,3] . new_a=old_a . old_a[0]=2 . new_a[0] . 2 . 즉 new_a=old_a 같은 메모리를 공유함으로써 new_a 와 old_a 모두 동시 수정됨 . 대책은? . new_a=old_a.copy() . new_a[0]=&#39;1&#39; . new_a . [&#39;1&#39;, 2, 3] . old_a . [2, 2, 3] . 이렇게 안 바뀜을 알 수 있다 . extend . a=[1,2,3] b=[2,3,4] . a.extend(b) . a . [1, 2, 3, 2, 3, 4] . extend와 똑같은 기능들 . a=a+b . a . [1, 2, 3, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4] . a+=b . a . [1, 2, 3, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4, 2, 3, 4] . asd=[&#39;asds&#39;,&#39;sdasd&#39;,&#39;sd&#39;] . 이 자료에 원소 추가하기 . asd.append(&#39;e&#39;) . asd . [&#39;asds&#39;, &#39;sdasd&#39;, &#39;sd&#39;, &#39;e&#39;] . asd.remove(&#39;e&#39;) . asd . [&#39;asds&#39;, &#39;sdasd&#39;, &#39;sd&#39;] . 인덱스로 원소 지우기 -&gt; pop사용 . asd.pop(1) . &#39;sd&#39; . asd . [&#39;asds&#39;] . 초기화 . asd.clear() . asd . [] . asd.insert(0,&#39;sds&#39;) . asd . [&#39;sds&#39;] . insert 함수 사용할 때 5자리에 넣고 싶어도 마지막 자리에 순서대로 추가 됨 . asd.index(&#39;sds&#39;) # 자리 번호 알기 . 0 . asd.count(&#39;sds&#39;) # 몇번 들어가 있는지 . 1 . a=[&#39;a&#39;,&#39;c&#39;,&#39;f&#39;,&#39;b&#39;] . a.sort() . a # 숫자와, bool도 정렬가능 . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;f&#39;] . a=[2,&#39;False&#39;] . a.sort() # 이렇게 자료형이 섞여있으면 불가능 . TypeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11492/873731035.py in &lt;module&gt; -&gt; 1 a.sort() # 이렇게 자료형이 섞여있으면 불가능 TypeError: &#39;&lt;&#39; not supported between instances of &#39;str&#39; and &#39;int&#39; . asf=[True,123333,0,134] . asf.sort() . asf # 자료형이 안 섞여있으면 가능 . [0, True, 134, 123333] . qwe=[1,2,3] . qwe.reverse() . qwe . [3, 2, 1] . qwe[-1::-1] # reverse와 동일 . [1, 2, 3] . data=[[&#39;s&#39;,23], [&#39;asd&#39;,2344]] . . my_set1={1,2,3} . my_set2={False,5,54} . my_set3={False,5,5} . my_set3 . {False, 5} . 즉 중복은 하나로 처리함 . set은 인덱스를 지원하지 않음 . alist=[2,3,4,1324] . my_set32412=set(alist) . my_set32412 . {2, 3, 4, 1324} . b=set() . b . set() . my_set32412.add(2525) . my_set32412 . {2, 3, 4, 1324, 2525} . my_set32412.update([1]) . my_set32412 . {1, 2, 3, 4, 1324, 2525} . my_set32412.discard(1324) . my_set32412 . {1, 2, 3, 4, 2525} . my_set32412.remove(2525) . my_set32412 . {1, 2, 3, 4} . 즉 discard와 remove는 동일하나 remove는 이미 없는 값을 또 삭제하려 할 때 error메세지를 보여줌 . a={1,2,3,5} b={6,5,55,4} . a or b . {1, 2, 3, 5} . b or a . {4, 5, 6, 55} . a|b . {1, 2, 3, 4, 5, 6, 55} . a.union(b) . {1, 2, 3, 4, 5, 6, 55} . b.union(a) . {1, 2, 3, 4, 5, 6, 55} . a&amp;b # 교집합 . {5} . a.intersection(b) . {5} . b.intersection(a) . {5} . a-b . {1, 2, 3} . a.difference(b) . {1, 2, 3} . b.difference(a) . {4, 6, 55} . a^b # 겹치는 거 빼고 출력 . {1, 2, 3, 4, 6, 55} . a.symmetric_difference(b) ## 겹치는 거 빼고 출력 . {1, 2, 3, 4, 6, 55} . b.symmetric_difference(a) # 겹치는 거 빼고 출력 . {1, 2, 3, 4, 6, 55} . a={1,2,3,4,5} b={1} . b.issubset(a) #b에 있는 값이 a에 있니 . True . a.issubset(b) # a에 있는 값이 b에 있니 . False . a.issuperset(b) #b에 있는 값이 a에 있니 . True . b.issuperset(a)# a에 있는 값이 b에 있니 . False . . a=frozenset([1,2,3,4,5]) . b=frozenset([4,5,6,7,8]) . a|b . frozenset({1, 2, 3, 4, 5, 6, 7, 8}) . a&amp;b . frozenset({4, 5}) . a.add(100) # 추가 불가 . AttributeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11492/4216742371.py in &lt;module&gt; -&gt; 1 a.add(100) # 추가 불가 AttributeError: &#39;frozenset&#39; object has no attribute &#39;add&#39; . c=set([1,2,3,4]) . a&amp;c . frozenset({1, 2, 3, 4}) . asq=[&#39;qw&#39;,&#39;qwa&#39;,&#39;qwsd&#39;] . door1_list = [&#39;qw&#39;] . door2_list = [&#39;qwa&#39;] . door1_list in asq . False . 왜 false? . door1_list[0] in asq . True . all=set(asq) . all . {&#39;qw&#39;, &#39;qwa&#39;, &#39;qwsd&#39;} . d1=set(door1_list) . d2=set(door2_list) . d1.issubset(all) . True . d2.issubset(all) . True . d_combine=d1 |d2 . d_combine . {&#39;qw&#39;, &#39;qwa&#39;} . d_combine.issubset(all) . True . all-d_combine . {&#39;qwsd&#39;} . door_list = [&#39;zxc&#39;,&#39;zxzx&#39;] . door_list2 = [&#39;zxcs&#39;,&#39;zsxzx&#39;] . d=set(door_list) . d2=set(door_list2) . combined=d1|d2 . combined.issubset(all) . False . all . {&#39;qw&#39;, &#39;qwa&#39;, &#39;qwsd&#39;} . dic =&gt; key,value로 이루어져있다 . my_dict={&#39;a&#39;:&#39;qewqwe&#39;,&#39;b&#39;:&#39;qewe&#39;,&#39;c&#39;:&#39;qwqwe&#39;} . my_dict[&#39;c&#39;] . &#39;qwqwe&#39; . 즉 따라서 순서는 중요하지 않음 . number={&#39;1&#39;:&#39;12312123123&#39;,&#39;asas&#39;:&#39;12313&#39;,&#39;asdad&#39;:&#39;12323&#39;} . number[&#39;asas&#39;] . &#39;12313&#39; . number.get(&#39;asas&#39;) . &#39;12313&#39; . number[&#39;asas&#39;]=&#39;fucking&#39; # 자료 업데이트 . number.update({&#39;1&#39;:&#39;asdasdddd&#39;}) # 자료 업데이트 . number[&#39;1&#39;] . &#39;asdasdddd&#39; . &#39;1&#39; in number # key가 들어가있는지 안 들어가 있는지 . True . number.pop(&#39;1&#39;) # 삭제 . &#39;asdasdddd&#39; . number . {&#39;asas&#39;: &#39;fucking&#39;, &#39;asdad&#39;: &#39;12323&#39;} . number.clear() . number . {} . . alist=[1,2,3,4,5] atuple=(1,2,3,4,5) aset={1,2,3,4,5} . len(alist) # 컨테이너의 값 개수를 알 수 있음 . 5 . len =&gt; comtainer에 사용 . max(aset) . 5 . min(alist) . 1 . 6 in atuple # 값 들어가있는지 체크하기 . False . flag= 6 in atuple . flag2= 555 not in atuple . flag2 . True . . list unpacking . a=[&#39;a&#39;,23,&#39;asf&#39;] . name=a[0] . age=a[1] . lan=a[2] . 이걸 한 번에 = list unpacking . name,age,lan=a . 리스트 a에서 처음 원소만 자료로 받고 나머지는 그에 헤당한 자료형으로 남겨놓고 싶을 때 . name, *remain=a . 응용하면 . *rest,name=a . name . &#39;asf&#39; . 더 응용하면 . first,second,*rest=a . . a=range(0,21,2) # 20까지임 . a . range(0, 21, 2) . 20 in a . True . a.index(20) . 10 . a[10] . 20 . a . range(0, 21, 2) . a[:5] . range(0, 10, 2) . a[-1] . 20 . list(range(10,51,10)) . [10, 20, 30, 40, 50] . . for i in range(5) : print(i) . 0 1 2 3 4 . for i in range(2,11,2) : print(i) . 2 4 6 8 10 . for i in range(10,2,-2) : print(i) . 10 8 6 4 . for i in range(10,1,-2) : print(i) . 10 8 6 4 2 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/22/intro.html",
            "relUrl": "/2021/12/22/intro.html",
            "date": " • Dec 22, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://rhkrehtjd.github.io/INTROpython/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://rhkrehtjd.github.io/INTROpython/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}
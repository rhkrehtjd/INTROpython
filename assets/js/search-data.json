{
  
    
        "post0": {
            "title": "2021/12/31/FRI",
            "content": "boxplot . import matplotlib.pyplot as plt import numpy as np y1=[75,75,76,76,77,77,79,79,79,98] y2=[76,76,77,77,78,78,80,80,80,81] plt.boxplot([y1,y2]) # plt.boxplot(y1)하면 단독 사용 가능 . {&#39;whiskers&#39;: [&lt;matplotlib.lines.Line2D at 0x163081e57f0&gt;, &lt;matplotlib.lines.Line2D at 0x163081e5ac0&gt;, &lt;matplotlib.lines.Line2D at 0x163082050d0&gt;, &lt;matplotlib.lines.Line2D at 0x16308205460&gt;], &#39;caps&#39;: [&lt;matplotlib.lines.Line2D at 0x163081e5e50&gt;, &lt;matplotlib.lines.Line2D at 0x163081f8220&gt;, &lt;matplotlib.lines.Line2D at 0x163082057f0&gt;, &lt;matplotlib.lines.Line2D at 0x16308205b80&gt;], &#39;boxes&#39;: [&lt;matplotlib.lines.Line2D at 0x163081e53a0&gt;, &lt;matplotlib.lines.Line2D at 0x163081f8d00&gt;], &#39;medians&#39;: [&lt;matplotlib.lines.Line2D at 0x163081f85b0&gt;, &lt;matplotlib.lines.Line2D at 0x16308205f10&gt;], &#39;fliers&#39;: [&lt;matplotlib.lines.Line2D at 0x163081f8940&gt;, &lt;matplotlib.lines.Line2D at 0x1630820f2e0&gt;], &#39;means&#39;: []} . np.mean(y1), np.mean(y2) . (79.1, 78.3) . 주황선은 평균이 아니고 그냥 중앙값임을 알 수 있다 | . plotly . import pandas as pd A=pd.DataFrame({&#39;class&#39;:[&#39;A&#39;]*len(y1), &#39;score&#39;:y1}) B=pd.DataFrame({&#39;class&#39;:[&#39;B&#39;]*len(y2), &#39;score&#39;:y2}) df=pd.concat([A,B],ignore_index=True) . import plotly.express as px px.box(df, x=&#39;class&#39;,y=&#39;score&#39;) # 접근성 up . histogram . plt.hist(np.random.normal(loc=0,scale=10, size=10000)) # loc=평균, scale=표준편차, size=개수 . (array([ 8., 43., 352., 1248., 2571., 2879., 1912., 786., 172., 29.]), array([-39.91620121, -32.36184952, -24.80749782, -17.25314613, -9.69879444, -2.14444274, 5.40990895, 12.96426064, 20.51861234, 28.07296403, 35.62731572]), &lt;BarContainer object of 10 artists&gt;) . np.random.seed(43052) y1=np.random.normal(loc=0,scale=1,size=10000) y2=np.random.normal(loc=2,scale=1,size=10000) . (np.mean(y2)-np.mean(y1)).round(3) #소수 셋째자리에서 반올림 . 2.01 . plt.boxplot([y1,y2]) . {&#39;whiskers&#39;: [&lt;matplotlib.lines.Line2D at 0x1631da59b80&gt;, &lt;matplotlib.lines.Line2D at 0x1631da59f10&gt;, &lt;matplotlib.lines.Line2D at 0x1631da424f0&gt;, &lt;matplotlib.lines.Line2D at 0x1631da42880&gt;], &#39;caps&#39;: [&lt;matplotlib.lines.Line2D at 0x1631da4c2e0&gt;, &lt;matplotlib.lines.Line2D at 0x1631da4c670&gt;, &lt;matplotlib.lines.Line2D at 0x1631da42c10&gt;, &lt;matplotlib.lines.Line2D at 0x1631da42fa0&gt;], &#39;boxes&#39;: [&lt;matplotlib.lines.Line2D at 0x1631da59850&gt;, &lt;matplotlib.lines.Line2D at 0x1631da42160&gt;], &#39;medians&#39;: [&lt;matplotlib.lines.Line2D at 0x1631da4ca00&gt;, &lt;matplotlib.lines.Line2D at 0x1631da39370&gt;], &#39;fliers&#39;: [&lt;matplotlib.lines.Line2D at 0x1631da4cd90&gt;, &lt;matplotlib.lines.Line2D at 0x1631da39730&gt;], &#39;means&#39;: []} . - 정규분포인것은 어떻게 아는가? $ to$ 히스토그램을 그려보아서 종 모양이 나오는지 살펴보자. . plt.hist(y1,bins=50) . (array([ 1., 1., 3., 0., 1., 4., 5., 12., 14., 26., 32., 52., 67., 89., 144., 171., 238., 282., 325., 378., 489., 492., 561., 635., 652., 636., 626., 606., 573., 539., 475., 444., 350., 250., 232., 172., 137., 80., 58., 47., 30., 23., 17., 12., 9., 4., 4., 0., 1., 1.]), array([-4.12186916, -3.96068404, -3.79949892, -3.6383138 , -3.47712868, -3.31594356, -3.15475844, -2.99357332, -2.8323882 , -2.67120308, -2.51001796, -2.34883284, -2.18764772, -2.0264626 , -1.86527748, -1.70409236, -1.54290724, -1.38172212, -1.220537 , -1.05935188, -0.89816676, -0.73698164, -0.57579652, -0.4146114 , -0.25342628, -0.09224116, 0.06894396, 0.23012908, 0.3913142 , 0.55249932, 0.71368444, 0.87486956, 1.03605468, 1.1972398 , 1.35842492, 1.51961004, 1.68079516, 1.84198028, 2.0031654 , 2.16435052, 2.32553564, 2.48672076, 2.64790588, 2.809091 , 2.97027612, 3.13146124, 3.29264636, 3.45383148, 3.6150166 , 3.77620172, 3.93738684]), &lt;BarContainer object of 50 artists&gt;) . plt.hist(y2,bins=50) . (array([ 1., 0., 3., 2., 4., 5., 5., 10., 16., 25., 33., 56., 74., 116., 119., 152., 244., 272., 351., 362., 438., 509., 531., 621., 624., 690., 636., 571., 564., 514., 462., 402., 356., 297., 233., 184., 144., 113., 80., 55., 38., 34., 21., 18., 4., 3., 2., 4., 1., 1.]), array([-2.0752867 , -1.9164866 , -1.7576865 , -1.5988864 , -1.4400863 , -1.2812862 , -1.1224861 , -0.963686 , -0.8048859 , -0.6460858 , -0.4872857 , -0.3284856 , -0.1696855 , -0.0108854 , 0.1479147 , 0.3067148 , 0.4655149 , 0.624315 , 0.7831151 , 0.9419152 , 1.1007153 , 1.2595154 , 1.4183155 , 1.5771156 , 1.7359157 , 1.8947158 , 2.0535159 , 2.212316 , 2.37111611, 2.52991621, 2.68871631, 2.84751641, 3.00631651, 3.16511661, 3.32391671, 3.48271681, 3.64151691, 3.80031701, 3.95911711, 4.11791721, 4.27671731, 4.43551741, 4.59431751, 4.75311761, 4.91191771, 5.07071781, 5.22951791, 5.38831801, 5.54711811, 5.70591821, 5.86471831]), &lt;BarContainer object of 50 artists&gt;) . plt.hist([y1,y2],bins=50) . (array([[ 1., 2., 2., 1., 5., 10., 16., 25., 47., 55., 110., 160., 218., 289., 388., 433., 604., 643., 728., 786., 797., 766., 749., 685., 597., 547., 366., 315., 221., 160., 94., 69., 38., 25., 24., 11., 6., 5., 0., 1., 1., 0., 0., 0., 0., 0., 0., 0., 0., 0.], [ 0., 0., 0., 0., 0., 0., 0., 0., 0., 0., 1., 0., 4., 3., 7., 7., 14., 27., 41., 75., 109., 151., 188., 317., 377., 459., 550., 630., 737., 783., 848., 783., 702., 680., 585., 480., 404., 321., 223., 175., 113., 76., 49., 38., 24., 8., 3., 5., 2., 1.]]), array([-4.12186916, -3.92213741, -3.72240567, -3.52267392, -3.32294217, -3.12321042, -2.92347867, -2.72374692, -2.52401517, -2.32428342, -2.12455167, -1.92481992, -1.72508817, -1.52535642, -1.32562467, -1.12589292, -0.92616117, -0.72642942, -0.52669767, -0.32696592, -0.12723417, 0.07249757, 0.27222932, 0.47196107, 0.67169282, 0.87142457, 1.07115632, 1.27088807, 1.47061982, 1.67035157, 1.87008332, 2.06981507, 2.26954682, 2.46927857, 2.66901032, 2.86874207, 3.06847382, 3.26820557, 3.46793732, 3.66766906, 3.86740081, 4.06713256, 4.26686431, 4.46659606, 4.66632781, 4.86605956, 5.06579131, 5.26552306, 5.46525481, 5.66498656, 5.86471831]), &lt;a list of 2 BarContainer objects&gt;) . seaborn . A=pd.DataFrame({&#39;class&#39;:[&#39;A&#39;]*len(y1),&#39;score&#39;:y1}) B=pd.DataFrame({&#39;class&#39;:[&#39;B&#39;]*len(y2),&#39;score&#39;:y2}) df=pd.concat([A,B],ignore_index=True) . import seaborn as sns sns.histplot(df,x=&#39;score&#39;,hue=&#39;class&#39;) . &lt;AxesSubplot:xlabel=&#39;score&#39;, ylabel=&#39;Count&#39;&gt; . plotnine . from plotnine import * . fill 대신에 color로 가능,투명도는 alpha . ggplot(df)+geom_histogram(aes(x=&#39;score&#39;,color=&#39;class&#39;),position=&#39;jitter&#39;,alpha=0.7) # position의 option에는 stack, identity, dodge, fill, jitter들이 있음 # position유무의 차이는 아직 잘 모르겠음 # 다만 없으면 그래프가 많이 독립적으로 그려지지 않는 것 같음 . C: Users ehfus Anaconda3 envs dv2021 lib site-packages plotnine stats stat_bin.py:95: PlotnineWarning: &#39;stat_bin()&#39; using &#39;bins = 65&#39;. Pick better value with &#39;binwidth&#39;. . &lt;ggplot: (95329268354)&gt; . plotly . import plotly.figure_factory as ff . hist_data=[y1,y2] group_labels=[&#39;A&#39;,&#39;B&#39;] ff.create_distplot(hist_data, group_labels, bin_size=.1, show_rug=False) .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/31/intro2.html",
            "relUrl": "/2021/12/31/intro2.html",
            "date": " • Dec 31, 2021"
        }
        
    
  
    
        ,"post1": {
            "title": "2021/12/30/THU",
            "content": "import pandas as pd . df=pd.read_csv(&#39;WEOApr2020all.csv&#39;) df.head(3) . WEO Country Code ISO WEO Subject Code Country Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 0 512 | AFG | NGDP_RPCH | Afghanistan | Gross domestic product, constant prices | Annual percentages of constant price GDP are y... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 5.683 | 2.697 | 0.988 | 2.164 | 2.889 | 2.664 | 3.037 | -3.007 | 4.495 | 2018.0 | . 1 512 | AFG | PPPGDP | Afghanistan | Gross domestic product, current prices | These data form the basis for the country weig... | Purchasing power parity; international dollars | Billions | Source: National Statistics Office Latest actu... | NaN | ... | 60.181 | 62.948 | 64.231 | 66.301 | 69.501 | 73.091 | 76.624 | 74.792 | 79.678 | 2018.0 | . 2 512 | AFG | NGDPRPPPPCPCH | Afghanistan | Gross domestic product per capita, constant pr... | GDP is expressed in constant international dol... | Purchasing power parity; percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 2.236 | -0.521 | -1.941 | -0.547 | 0.358 | 1.268 | 1.654 | -4.291 | 3.063 | 2018.0 | . 3 rows × 52 columns . df.describe() . WEO Country Code Estimates Start After . count 1552.000000 | 1466.000000 | . mean 553.670103 | 2018.291951 | . std 261.437803 | 1.075652 | . min 111.000000 | 2009.000000 | . 25% 314.000000 | 2018.000000 | . 50% 571.000000 | 2018.000000 | . 75% 734.000000 | 2019.000000 | . max 968.000000 | 2020.000000 | . df.columns . Index([&#39;WEO Country Code&#39;, &#39;ISO&#39;, &#39;WEO Subject Code&#39;, &#39;Country&#39;, &#39;Subject Descriptor&#39;, &#39;Subject Notes&#39;, &#39;Units&#39;, &#39;Scale&#39;, &#39;Country/Series-specific Notes&#39;, &#39;1980&#39;, &#39;1981&#39;, &#39;1982&#39;, &#39;1983&#39;, &#39;1984&#39;, &#39;1985&#39;, &#39;1986&#39;, &#39;1987&#39;, &#39;1988&#39;, &#39;1989&#39;, &#39;1990&#39;, &#39;1991&#39;, &#39;1992&#39;, &#39;1993&#39;, &#39;1994&#39;, &#39;1995&#39;, &#39;1996&#39;, &#39;1997&#39;, &#39;1998&#39;, &#39;1999&#39;, &#39;2000&#39;, &#39;2001&#39;, &#39;2002&#39;, &#39;2003&#39;, &#39;2004&#39;, &#39;2005&#39;, &#39;2006&#39;, &#39;2007&#39;, &#39;2008&#39;, &#39;2009&#39;, &#39;2010&#39;, &#39;2011&#39;, &#39;2012&#39;, &#39;2013&#39;, &#39;2014&#39;, &#39;2015&#39;, &#39;2016&#39;, &#39;2017&#39;, &#39;2018&#39;, &#39;2019&#39;, &#39;2020&#39;, &#39;2021&#39;, &#39;Estimates Start After&#39;], dtype=&#39;object&#39;) . type(df) . pandas.core.frame.DataFrame . df[&#39;Country&#39;].nunique() # 194개 나라의 data가 들어있음을 알 수 있다 . 194 . df.iloc[:,3] . 0 Afghanistan 1 Afghanistan 2 Afghanistan 3 Afghanistan 4 Afghanistan ... 1547 Zimbabwe 1548 Zimbabwe 1549 Zimbabwe 1550 Zimbabwe 1551 Zimbabwe Name: Country, Length: 1552, dtype: object . df.Country . 0 Afghanistan 1 Afghanistan 2 Afghanistan 3 Afghanistan 4 Afghanistan ... 1547 Zimbabwe 1548 Zimbabwe 1549 Zimbabwe 1550 Zimbabwe 1551 Zimbabwe Name: Country, Length: 1552, dtype: object . df[[&#39;Country&#39;]] . Country . 0 Afghanistan | . 1 Afghanistan | . 2 Afghanistan | . 3 Afghanistan | . 4 Afghanistan | . ... ... | . 1547 Zimbabwe | . 1548 Zimbabwe | . 1549 Zimbabwe | . 1550 Zimbabwe | . 1551 Zimbabwe | . 1552 rows × 1 columns . df[[&#39;Subject Descriptor&#39;]].head(7) . Subject Descriptor . 0 Gross domestic product, constant prices | . 1 Gross domestic product, current prices | . 2 Gross domestic product per capita, constant pr... | . 3 Inflation, average consumer prices | . 4 Inflation, end of period consumer prices | . 5 Unemployment rate | . 6 General government net lending/borrowing | . df[[&#39;Subject Descriptor&#39;,&#39;2020&#39;]] . Subject Descriptor 2020 . 0 Gross domestic product, constant prices | -3.007 | . 1 Gross domestic product, current prices | 74.792 | . 2 Gross domestic product per capita, constant pr... | -4.291 | . 3 Inflation, average consumer prices | 4.711 | . 4 Inflation, end of period consumer prices | 4.5 | . ... ... | ... | . 1547 Inflation, average consumer prices | 319.036 | . 1548 Inflation, end of period consumer prices | 154.297 | . 1549 Unemployment rate | NaN | . 1550 General government net lending/borrowing | -4.931 | . 1551 Current account balance | -1.914 | . 1552 rows × 2 columns . df[[&#39;Subject Descriptor&#39;,&#39;2020&#39;,&#39;Country&#39;]] . Subject Descriptor 2020 Country . 0 Gross domestic product, constant prices | -3.007 | Afghanistan | . 1 Gross domestic product, current prices | 74.792 | Afghanistan | . 2 Gross domestic product per capita, constant pr... | -4.291 | Afghanistan | . 3 Inflation, average consumer prices | 4.711 | Afghanistan | . 4 Inflation, end of period consumer prices | 4.5 | Afghanistan | . ... ... | ... | ... | . 1547 Inflation, average consumer prices | 319.036 | Zimbabwe | . 1548 Inflation, end of period consumer prices | 154.297 | Zimbabwe | . 1549 Unemployment rate | NaN | Zimbabwe | . 1550 General government net lending/borrowing | -4.931 | Zimbabwe | . 1551 Current account balance | -1.914 | Zimbabwe | . 1552 rows × 3 columns . Inflation . idx_inf=df[&#39;Subject Descriptor&#39;].str.contains(&#39;Inflation, end of&#39;) print(idx_inf) . 0 False 1 False 2 False 3 False 4 True ... 1547 False 1548 True 1549 False 1550 False 1551 False Name: Subject Descriptor, Length: 1552, dtype: bool . df.loc[idx_inf] . WEO Country Code ISO WEO Subject Code Country Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 4 512 | AFG | PCPIEPCH | Afghanistan | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.241 | 1.487 | 1.131 | 4.588 | 3.041 | 0.755 | 2.773 | 4.5 | 5 | 2018.0 | . 12 914 | ALB | PCPIEPCH | Albania | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 1.776 | 0.719 | 1.937 | 2.176 | 1.798 | 1.799 | 1.15 | 2.6 | 2.9 | 2019.0 | . 20 612 | DZA | PCPIEPCH | Algeria | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | 14.143 | ... | 1.148 | 5.253 | 4.362 | 6.957 | 4.933 | 2.702 | 2.434 | 3.3 | 4 | 2019.0 | . 28 614 | AGO | PCPIEPCH | Angola | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.687 | 7.498 | 12.091 | 41.125 | 23.667 | 18.604 | 16.893 | 20.979 | 23.981 | 2019.0 | . 36 311 | ATG | PCPIEPCH | Antigua and Barbuda | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: Central Bank Latest actual data: 2018 ... | 17.71 | ... | 1.059 | 1.327 | 0.9 | -1.121 | 2.356 | 1.741 | 1.574 | 1.348 | 2.008 | 2018.0 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 1516 299 | VEN | PCPIEPCH | Venezuela | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: Central Bank Latest actual data: 2019 ... | NaN | ... | 56.193 | 68.54 | 180.87 | 274.354 | 862.629 | 130,060.24 | 9,585.49 | 15,000.00 | 15,000.00 | 2019.0 | . 1524 582 | VNM | PCPIEPCH | Vietnam | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 6.036 | 1.839 | 0.597 | 4.737 | 2.597 | 2.983 | 5.237 | 2 | 4.3 | 2018.0 | . 1532 474 | YEM | PCPIEPCH | Yemen | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office. Central Ba... | NaN | ... | 8.14 | 10.005 | 34 | 11.9 | 47 | 14.3 | 6.2 | 46 | 5 | 2017.0 | . 1540 754 | ZMB | PCPIEPCH | Zambia | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.14 | 7.862 | 21.112 | 7.469 | 6.085 | 7.9 | 11.7 | 12.7 | 11.4 | 2019.0 | . 1548 698 | ZWE | PCPIEPCH | Zimbabwe | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 0.331 | -0.796 | -2.473 | -0.898 | 3.43 | 42.074 | 521.15 | 154.297 | 3 | 2019.0 | . 194 rows × 52 columns . df_inf=df[idx_inf] df_inf.head(3) . WEO Country Code ISO WEO Subject Code Country Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 4 512 | AFG | PCPIEPCH | Afghanistan | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.241 | 1.487 | 1.131 | 4.588 | 3.041 | 0.755 | 2.773 | 4.5 | 5 | 2018.0 | . 12 914 | ALB | PCPIEPCH | Albania | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 1.776 | 0.719 | 1.937 | 2.176 | 1.798 | 1.799 | 1.15 | 2.6 | 2.9 | 2019.0 | . 20 612 | DZA | PCPIEPCH | Algeria | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | 14.143 | ... | 1.148 | 5.253 | 4.362 | 6.957 | 4.933 | 2.702 | 2.434 | 3.3 | 4 | 2019.0 | . 3 rows × 52 columns . df_inf_2021=df_inf[[&#39;Country&#39;,&#39;2021&#39;]] . df_inf_2021.reset_index(drop=True,inplace=True) . df_inf_2021 . Country 2021 . 0 Afghanistan | 5 | . 1 Albania | 2.9 | . 2 Algeria | 4 | . 3 Angola | 23.981 | . 4 Antigua and Barbuda | 2.008 | . ... ... | ... | . 189 Venezuela | 15,000.00 | . 190 Vietnam | 4.3 | . 191 Yemen | 5 | . 192 Zambia | 11.4 | . 193 Zimbabwe | 3 | . 194 rows × 2 columns . df_inf_2021.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 194 entries, 0 to 193 Data columns (total 2 columns): # Column Non-Null Count Dtype -- -- 0 Country 194 non-null object 1 2021 190 non-null object dtypes: object(2) memory usage: 3.2+ KB . 2021 null data가 4개임을 알 수 있다 | . df_inf_2021=df_inf_2021.loc[df_inf_2021[&#39;2021&#39;].notnull()] . df_inf_2021 . Country 2021 . 0 Afghanistan | 5 | . 1 Albania | 2.9 | . 2 Algeria | 4 | . 3 Angola | 23.981 | . 4 Antigua and Barbuda | 2.008 | . ... ... | ... | . 189 Venezuela | 15,000.00 | . 190 Vietnam | 4.3 | . 191 Yemen | 5 | . 192 Zambia | 11.4 | . 193 Zimbabwe | 3 | . 190 rows × 2 columns . null data가 빠졌음 | . df_inf_2021.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 190 entries, 0 to 193 Data columns (total 2 columns): # Column Non-Null Count Dtype -- -- 0 Country 190 non-null object 1 2021 190 non-null object dtypes: object(2) memory usage: 4.5+ KB . data에 큰 숫자마다 comma가 들어가 있음 $ to$ 없애주자 . df_inf_2021=df_inf_2021.replace(&#39;,&#39;,&#39;&#39;,regex=True) df_inf_2021 . Country 2021 . 0 Afghanistan | 5 | . 1 Albania | 2.9 | . 2 Algeria | 4 | . 3 Angola | 23.981 | . 4 Antigua and Barbuda | 2.008 | . ... ... | ... | . 189 Venezuela | 15000.00 | . 190 Vietnam | 4.3 | . 191 Yemen | 5 | . 192 Zambia | 11.4 | . 193 Zimbabwe | 3 | . 190 rows × 2 columns . 이제 numeric data로 바꿔보자 | . df_inf_2021[&#39;2021&#39;]=pd.to_numeric(df_inf_2021[&#39;2021&#39;]) . 확인해보자 | . df_inf_2021.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 190 entries, 0 to 193 Data columns (total 2 columns): # Column Non-Null Count Dtype -- -- 0 Country 190 non-null object 1 2021 190 non-null float64 dtypes: float64(1), object(1) memory usage: 4.5+ KB . float64로 잘 바뀌었음 | . df_inf_2021.sort_values(&#39;2021&#39;).plot.bar(x=&#39;Country&#39;) . &lt;AxesSubplot:xlabel=&#39;Country&#39;&gt; . 무용지물의 그래프가 나왔다 | . df_inf_2021.sort_values(&#39;2021&#39;).iloc[0:20,:].plot.bar(x=&#39;Country&#39;) . &lt;AxesSubplot:xlabel=&#39;Country&#39;&gt; . &#49892;&#50629;&#47456; . df_ur=df[df[&#39;Subject Descriptor&#39;].str.contains(&#39;Unemployment&#39;)] df_ur . WEO Country Code ISO WEO Subject Code Country Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 5 512 | AFG | LUR | Afghanistan | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 13 914 | ALB | LUR | Albania | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: National Statistics Office Latest actu... | 5.028 | ... | 15.9 | 17.5 | 17.1 | 15.2 | 13.7 | 12.3 | 12 | 11.8 | 11.5 | 2019.0 | . 21 612 | DZA | LUR | Algeria | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: National Statistics Office Latest actu... | 15.789 | ... | 9.829 | 10.6 | 11.214 | 10.498 | 11.709 | 11.731 | 11.383 | 15.091 | 13.909 | 2019.0 | . 29 614 | AGO | LUR | Angola | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 37 311 | ATG | LUR | Antigua and Barbuda | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 1517 299 | VEN | LUR | Venezuela | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.47 | 6.7 | 7.4 | 20.863 | 27.886 | 35.543 | NaN | NaN | NaN | 2011.0 | . 1525 582 | VNM | LUR | Vietnam | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: Other Latest actual data: 2019 Employm... | NaN | ... | 2.75 | 2.1 | 2.33 | 2.33 | 2.21 | 2.21 | 2.21 | NaN | NaN | 2019.0 | . 1533 474 | YEM | LUR | Yemen | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 1541 754 | ZMB | LUR | Zambia | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 1549 698 | ZWE | LUR | Zimbabwe | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 194 rows × 52 columns . df_ur=df_ur[[&#39;Country&#39;,&#39;2021&#39;]] . df_ur.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Int64Index: 194 entries, 5 to 1549 Data columns (total 2 columns): # Column Non-Null Count Dtype -- -- 0 Country 194 non-null object 1 2021 100 non-null object dtypes: object(2) memory usage: 4.5+ KB . 94개의 null data 발견 | . df_ur=df_ur.loc[df_ur[&#39;2021&#39;].notnull()] . df_ur.reset_index(drop=True,inplace=True) df_ur . Country 2021 . 0 Albania | 11.5 | . 1 Algeria | 13.909 | . 2 Argentina | 10.084 | . 3 Armenia | 18.389 | . 4 Aruba | 7.458 | . ... ... | ... | . 95 Turkey | 15.567 | . 96 Ukraine | 9.318 | . 97 United Kingdom | 4.375 | . 98 United States | 9.135 | . 99 Uruguay | 8.098 | . 100 rows × 2 columns . null data가 잘 빠졌음 | . 이제 numeric으로 변형해주자 | . df_ur[&#39;2021&#39;]=pd.to_numeric(df_ur[&#39;2021&#39;]) . df_ur.info() . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; RangeIndex: 100 entries, 0 to 99 Data columns (total 2 columns): # Column Non-Null Count Dtype -- -- 0 Country 100 non-null object 1 2021 100 non-null float64 dtypes: float64(1), object(1) memory usage: 1.7+ KB . df_ur.plot.bar(x=&#39;Country&#39;) . &lt;AxesSubplot:xlabel=&#39;Country&#39;&gt; . df_ur.sort_values(&#39;2021&#39;,ascending=False).plot.bar(x=&#39;Country&#39;, title=&#39;Unemployment Rate&#39;,figsize=(15,5)) . &lt;AxesSubplot:title={&#39;center&#39;:&#39;Unemployment Rate&#39;}, xlabel=&#39;Country&#39;&gt; . 관심있는 나라만 따로 표시해보자 | . df_ur_np=df_ur.sort_values(&#39;2021&#39;,ascending=False).to_numpy() . . import matplotlib.pyplot as plt import numpy as np . plt.rcParams[&#39;figure.figsize&#39;]=(20,3) plt.xticks(rotation=&#39;vertical&#39;) plt.bar(df_ur_np[:,0],df_ur_np[:,1]) plt.title(&#39;2021 Unemployment Rate - IMF World Economics Outlook Database, April 2020&#39;) idx=np.where(df_ur_np==&#39;Korea&#39;) plt.bar(df_ur_np[idx[0],0],df_ur_np[idx[0],1],label=&#39;Korea&#39;) idx=np.where(df_ur_np==&#39;United States&#39;) plt.bar(df_ur_np[idx[0],0],df_ur_np[idx[0],1],label=&#39;United States&#39;) idx=np.where(df_ur_np==&#39;China&#39;) plt.bar(df_ur_np[idx[0],0],df_ur_np[idx[0],1],label=&#39;China&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x22b114aca90&gt; . TIP . df.head(3) . WEO Country Code ISO WEO Subject Code Country Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 0 512 | AFG | NGDP_RPCH | Afghanistan | Gross domestic product, constant prices | Annual percentages of constant price GDP are y... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 5.683 | 2.697 | 0.988 | 2.164 | 2.889 | 2.664 | 3.037 | -3.007 | 4.495 | 2018.0 | . 1 512 | AFG | PPPGDP | Afghanistan | Gross domestic product, current prices | These data form the basis for the country weig... | Purchasing power parity; international dollars | Billions | Source: National Statistics Office Latest actu... | NaN | ... | 60.181 | 62.948 | 64.231 | 66.301 | 69.501 | 73.091 | 76.624 | 74.792 | 79.678 | 2018.0 | . 2 512 | AFG | NGDPRPPPPCPCH | Afghanistan | Gross domestic product per capita, constant pr... | GDP is expressed in constant international dol... | Purchasing power parity; percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 2.236 | -0.521 | -1.941 | -0.547 | 0.358 | 1.268 | 1.654 | -4.291 | 3.063 | 2018.0 | . 3 rows × 52 columns . len(df.columns) . 52 . idx = list(range(0,52)) . idx[3]=0 idx[0]=3 print(idx) . [3, 1, 2, 0, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51] . df.iloc[:,idx] . Country ISO WEO Subject Code WEO Country Code Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 0 Afghanistan | AFG | NGDP_RPCH | 512 | Gross domestic product, constant prices | Annual percentages of constant price GDP are y... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 5.683 | 2.697 | 0.988 | 2.164 | 2.889 | 2.664 | 3.037 | -3.007 | 4.495 | 2018.0 | . 1 Afghanistan | AFG | PPPGDP | 512 | Gross domestic product, current prices | These data form the basis for the country weig... | Purchasing power parity; international dollars | Billions | Source: National Statistics Office Latest actu... | NaN | ... | 60.181 | 62.948 | 64.231 | 66.301 | 69.501 | 73.091 | 76.624 | 74.792 | 79.678 | 2018.0 | . 2 Afghanistan | AFG | NGDPRPPPPCPCH | 512 | Gross domestic product per capita, constant pr... | GDP is expressed in constant international dol... | Purchasing power parity; percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 2.236 | -0.521 | -1.941 | -0.547 | 0.358 | 1.268 | 1.654 | -4.291 | 3.063 | 2018.0 | . 3 Afghanistan | AFG | PCPIPCH | 512 | Inflation, average consumer prices | Annual percentages of average consumer prices ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.386 | 4.674 | -0.662 | 4.384 | 4.976 | 0.626 | 2.302 | 4.711 | 4.451 | 2018.0 | . 4 Afghanistan | AFG | PCPIEPCH | 512 | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.241 | 1.487 | 1.131 | 4.588 | 3.041 | 0.755 | 2.773 | 4.5 | 5 | 2018.0 | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 1547 Zimbabwe | ZWE | PCPIPCH | 698 | Inflation, average consumer prices | Annual percentages of average consumer prices ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 1.632 | -0.213 | -2.41 | -1.558 | 0.907 | 10.607 | 255.292 | 319.036 | 3.7 | 2019.0 | . 1548 Zimbabwe | ZWE | PCPIEPCH | 698 | Inflation, end of period consumer prices | Annual percentages of end of period consumer ... | Percent change | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 0.331 | -0.796 | -2.473 | -0.898 | 3.43 | 42.074 | 521.15 | 154.297 | 3 | 2019.0 | . 1549 Zimbabwe | ZWE | LUR | 698 | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 1550 Zimbabwe | ZWE | GGXCNL_NGDP | 698 | General government net lending/borrowing | Net lending (+)/ borrowing (?) is calculated a... | Percent of GDP | NaN | Source: Ministry of Finance or Treasury Latest... | NaN | ... | -0.621 | -0.421 | -1.418 | -6.242 | -8.113 | -4.499 | -2.575 | -4.931 | -1.518 | 2018.0 | . 1551 Zimbabwe | ZWE | BCA_NGDPD | 698 | Current account balance | Current account is all transactions other than... | Percent of GDP | NaN | Source: Reserve Bank of Zimbabwe and Ministry ... | NaN | ... | -13.23 | -11.563 | -7.617 | -3.58 | -1.299 | -5.896 | 1.133 | -1.914 | -1.894 | 2018.0 | . 1552 rows × 52 columns . 이렇게 원하는 순서로 열을 배열해보았음 | . . Grouping . df_ur[&#39;Criteria&#39;]=0 . df_ur.loc[ df_ur[&#39;2021&#39;] &lt; 5 , &#39;Criteria&#39; ]=&#39;Low&#39; df_ur.loc[ (df_ur[&#39;2021&#39;] &gt;= 5) &amp; (df_ur[&#39;2021&#39;] &lt; 10) , &#39;Criteria&#39; ]=&#39;Medium&#39; df_ur.loc[ df_ur[&#39;2021&#39;] &gt;=10 , &#39;Criteria&#39; ]=&#39;High&#39; . df_ur.groupby([&#39;Criteria&#39;]).mean() . 2021 . Criteria . High 14.767680 | . Low 3.547000 | . Medium 7.100353 | . df_ur.groupby([&#39;Criteria&#39;]).mean().sort_values(&#39;2021&#39;) . 2021 . Criteria . Low 3.547000 | . Medium 7.100353 | . High 14.767680 | . df_ur.groupby([&#39;Criteria&#39;]).count() . Country 2021 . Criteria . High 25 | 25 | . Low 24 | 24 | . Medium 51 | 51 | . . Data를 적당히 소분해 불러와보자 . df_new=pd.DataFrame(columns=df.columns) df_new . WEO Country Code ISO WEO Subject Code Country Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 0 rows × 52 columns . for df_chunk in pd.read_csv(&#39;WEOApr2020all.csv&#39;,chunksize=5): temp=df_chunk.loc[df_chunk[&#39;Subject Descriptor&#39;]==&#39;Unemployment rate&#39;] df_new = pd.concat([df_new,temp]) . df_new . WEO Country Code ISO WEO Subject Code Country Subject Descriptor Subject Notes Units Scale Country/Series-specific Notes 1980 ... 2013 2014 2015 2016 2017 2018 2019 2020 2021 Estimates Start After . 5 512 | AFG | LUR | Afghanistan | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 13 914 | ALB | LUR | Albania | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: National Statistics Office Latest actu... | 5.028 | ... | 15.9 | 17.5 | 17.1 | 15.2 | 13.7 | 12.3 | 12.0 | 11.8 | 11.5 | 2019 | . 21 612 | DZA | LUR | Algeria | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: National Statistics Office Latest actu... | 15.789 | ... | 9.829 | 10.6 | 11.214 | 10.498 | 11.709 | 11.731 | 11.383 | 15.091 | 13.909 | 2019 | . 29 614 | AGO | LUR | Angola | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 37 311 | ATG | LUR | Antigua and Barbuda | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . ... ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | ... | . 1517 299 | VEN | LUR | Venezuela | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: National Statistics Office Latest actu... | NaN | ... | 7.47 | 6.7 | 7.4 | 20.863 | 27.886 | 35.543 | NaN | NaN | NaN | 2011 | . 1525 582 | VNM | LUR | Vietnam | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | Source: Other Latest actual data: 2019 Employm... | NaN | ... | 2.75 | 2.1 | 2.33 | 2.33 | 2.21 | 2.21 | 2.21 | NaN | NaN | 2019 | . 1533 474 | YEM | LUR | Yemen | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 1541 754 | ZMB | LUR | Zambia | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 1549 698 | ZWE | LUR | Zimbabwe | Unemployment rate | Unemployment rate can be defined by either the... | Percent of total labor force | NaN | NaN | NaN | ... | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | NaN | . 194 rows × 52 columns . . &#50620;&#44404; &#51064;&#49885; . import cv2 . img=cv2.imread(&#39;spurs_pic.jpg&#39;) plt.imshow(img) # BGR로 인식하기 때문에 RGB로 바꿔야 함 . &lt;matplotlib.image.AxesImage at 0x22b1e176ca0&gt; . rgb=cv2.cvtColor(img, cv2.COLOR_BGR2RGB) plt.imshow(rgb) . &lt;matplotlib.image.AxesImage at 0x22b1e1f3490&gt; . gray=cv2.cvtColor(rgb, cv2.COLOR_RGB2GRAY) plt.imshow(gray,cmap=&#39;gray&#39;) . &lt;matplotlib.image.AxesImage at 0x22b1e393df0&gt; . classifier=cv2.CascadeClassifier(&#39;. haarcascades haarcascade_frontalface_default.xml&#39;) . 분류할 데이터가 정해졌음 . rects = classifier.detectMultiScale(gray,scaleFactor=1.2,minNeighbors=5) . print(&#39;Face found:{} &#39;.format(len(rects))) . Face found:11 . for x,y,w,h in rects: cv2.rectangle(rgb,(x,y),(x+w,y+h),(0,255,0),2) plt.imshow(rgb) . &lt;matplotlib.image.AxesImage at 0x22b1e2e58e0&gt; . #plt.imshow(rgb) . bgr=cv2.cvtColor(rgb,cv2.COLOR_RGB2BGR) cv2.imwrite(&#39;spurs_pic_faces.jpg&#39;,bgr) # 저장했음 . True .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/30/intro.html",
            "relUrl": "/2021/12/30/intro.html",
            "date": " • Dec 30, 2021"
        }
        
    
  
    
        ,"post2": {
            "title": "2021/12/29/WED",
            "content": "import matplotlib.pyplot as plt import matplotlib.cm as cm import numpy as np . height=4 width=5 depth=3 . m=np.zeros((height,width,depth)) . plt.imshow(m) plt.grid() . 이미지의 시작은 좌측 상단임 . m[:,:,0]=255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m=np.zeros((height,width,depth)) m[:,:,1]=255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m=np.zeros((height,width,depth)) m[:,:,2]=255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m=np.ones((height,width,depth))*255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m=np.zeros((height,width,depth))*0 plt.imshow(m) plt.grid() . m=np.zeros((height,width,depth)) m[0,0,:]=255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . 첫번재 픽셀만 하얗게 만듦 . m=np.zeros((height,width,depth)) m[0,0,0]=0 m[0,0,1]=255 m[0,0,2]=0 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m=np.zeros((height,width,depth)) m[0,0,0]=0 m[0,0,1]=0 m[0,0,2]=255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m=np.zeros((height,width,depth)) m[0,0,0]=255 m[0,0,1]=0 m[0,0,2]=0 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m=np.zeros((height,width,depth)) m[:,:,:]=0 plt.imshow(m) plt.grid() . m=np.zeros((height,width,depth)) m[:,0,1]=255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m[:,-2,2]=255 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . m[2,:,0]=255 m[2,:,1]=255 m[2,:,2]=0 plt.imshow(m) plt.grid() . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . 이미지를 세로로 두배 늘려보자 . m_vt=np.vstack([m,m]) plt.imshow(m_vt) . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . &lt;matplotlib.image.AxesImage at 0x142b59fb310&gt; . m_hz=np.hstack([m,m]) plt.imshow(m_hz) . Clipping input data to the valid range for imshow with RGB data ([0..1] for floats or [0..255] for integers). . &lt;matplotlib.image.AxesImage at 0x142b389cbb0&gt; . 어둡게 해보자 . m_hz=(m_hz/255)*0.5 plt.imshow(m_hz) . &lt;matplotlib.image.AxesImage at 0x142b3c07940&gt; . 체크보드 만들기 . m=np.zeros((5,5,3)) plt.imshow(m) . &lt;matplotlib.image.AxesImage at 0x142b38af790&gt; . m[:,:,:]=1 plt.imshow(m) . &lt;matplotlib.image.AxesImage at 0x142b5915490&gt; . m[:,:,:]=0 plt.imshow(m) . &lt;matplotlib.image.AxesImage at 0x142b5a553a0&gt; . m[0::2,0::2,:]=1 plt.imshow(m) . &lt;matplotlib.image.AxesImage at 0x142b5aaf2e0&gt; . m[1::2,1::2,:]=1 plt.imshow(m) . &lt;matplotlib.image.AxesImage at 0x142b5b10040&gt; . 논리 연산을 사용해서 체크 무늬 만들어보자 . n=m.copy() idx=np.where(n==1) n[idx]=0.5 plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b5b76610&gt; . idx=np.where(n&lt;0.1) n[idx]=1 plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b5bc3f40&gt; . n=m.copy() plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b5c88160&gt; . 컬러 뒤집기 . idx1=np.where(n==1) idx2=np.where(n==0) n[idx1]=0 n[idx2]=1 plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b617d5b0&gt; . a=np.where(n==1) n[a[0],a[1],0]=0 n[a[0],a[1],2]=0 plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b6345460&gt; . flag_r=(n[:,:,0]==0) flag_g=(n[:,:,1]==0) flag_b=(n[:,:,2]==0) flag_blk= flag_r&amp;flag_g&amp;flag_b idx_blk=np.where(flag_blk==True) n[idx_blk[0],idx_blk[1],0]=1 plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b6a56880&gt; . n=m.copy() plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b700f1c0&gt; . np_sum=np.sum(n,axis=2) idx_blk=np.where(np_sum==0) n[idx_blk[0],idx_blk[1],0]=1 plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b5d23a90&gt; . np.fill_diagonal(n[:,:,0],0) np.fill_diagonal(n[:,:,1],1) np.fill_diagonal(n[:,:,2],0) plt.imshow(n) . &lt;matplotlib.image.AxesImage at 0x142b5db2370&gt; . m=np.linspace(0,1,10) m=m[:,np.newaxis] m=np.repeat(m,10,axis=1) plt.imshow(m,cmap=&#39;gray&#39;) . &lt;matplotlib.image.AxesImage at 0x142b6225490&gt; . m_tr=np.transpose(m) plt.imshow(m_tr,cmap=&#39;gray&#39;) . &lt;matplotlib.image.AxesImage at 0x142b68cdfd0&gt; . m_tr=np.transpose(m) plt.imshow(m_tr,cmap=&#39;jet&#39;) . &lt;matplotlib.image.AxesImage at 0x142b6a62c70&gt; . . LaTex 이용해보자 . $ begin{align} begin{cases} f(x) = frac{1}{10}x^2 &amp; text{ for } x in [0,1.5) f(x) = sum_{n=1,3,5..}^{N}{ frac{4}{ pi n} text{sin}( frac{2 pi n(x-1.5)}{T})}&amp; text{for} in[1.5,3] end{cases} end{align} $ . . x1=np.arange(0,1.5,0.01) y1=1/10*x1**2 . . x2=np.arange(1.5,3+0.01,0.01) n= 50 t=1 y2=np.zeros(x2.shape) for n in range(n): if n%2==1: series = 4/(np.pi*n)*np.sin((2*np.pi*n*(x2-1.5))/t) y2=y2+series . plt.plot(x1,y1) plt.plot(x2,y2) plt.xlabel(&#39;x&#39;) plt.xlabel(&#39;y&#39;) plt.title(&#39;Piecewise Functions&#39;) . Text(0.5, 1.0, &#39;Piecewise Functions&#39;) . . 세계 온도 변화 시각화 . import scipy import scipy.interpolate as interp import gzip import pickle as pkl . file=gzip.GzipFile(&#39;GlobalTemperatureData.pkl.gz&#39;,&#39;rb&#39;) df=pkl.load(file) file.close . &lt;bound method GzipFile.close of &lt;gzip _io.BufferedReader name=&#39;GlobalTemperatureData.pkl.gz&#39; 0x142be630940&gt;&gt; . df.keys() . dict_keys([&#39;YR1881&#39;, &#39;YR1882&#39;, &#39;YR1883&#39;, &#39;YR1884&#39;, &#39;YR1885&#39;, &#39;YR1886&#39;, &#39;YR1887&#39;, &#39;YR1888&#39;, &#39;YR1889&#39;, &#39;YR1890&#39;, &#39;YR1891&#39;, &#39;YR1892&#39;, &#39;YR1893&#39;, &#39;YR1894&#39;, &#39;YR1895&#39;, &#39;YR1896&#39;, &#39;YR1897&#39;, &#39;YR1898&#39;, &#39;YR1899&#39;, &#39;YR1900&#39;, &#39;YR1901&#39;, &#39;YR1902&#39;, &#39;YR1903&#39;, &#39;YR1904&#39;, &#39;YR1905&#39;, &#39;YR1906&#39;, &#39;YR1907&#39;, &#39;YR1908&#39;, &#39;YR1909&#39;, &#39;YR1910&#39;, &#39;YR1911&#39;, &#39;YR1912&#39;, &#39;YR1913&#39;, &#39;YR1914&#39;, &#39;YR1915&#39;, &#39;YR1916&#39;, &#39;YR1917&#39;, &#39;YR1918&#39;, &#39;YR1919&#39;, &#39;YR1920&#39;, &#39;YR1921&#39;, &#39;YR1922&#39;, &#39;YR1923&#39;, &#39;YR1924&#39;, &#39;YR1925&#39;, &#39;YR1926&#39;, &#39;YR1927&#39;, &#39;YR1928&#39;, &#39;YR1929&#39;, &#39;YR1930&#39;, &#39;YR1931&#39;, &#39;YR1932&#39;, &#39;YR1933&#39;, &#39;YR1934&#39;, &#39;YR1935&#39;, &#39;YR1936&#39;, &#39;YR1937&#39;, &#39;YR1938&#39;, &#39;YR1939&#39;, &#39;YR1940&#39;, &#39;YR1941&#39;, &#39;YR1942&#39;, &#39;YR1943&#39;, &#39;YR1944&#39;, &#39;YR1945&#39;, &#39;YR1946&#39;, &#39;YR1947&#39;, &#39;YR1948&#39;, &#39;YR1949&#39;, &#39;YR1950&#39;, &#39;YR1951&#39;, &#39;YR1952&#39;, &#39;YR1953&#39;, &#39;YR1954&#39;, &#39;YR1955&#39;, &#39;YR1956&#39;, &#39;YR1957&#39;, &#39;YR1958&#39;, &#39;YR1959&#39;, &#39;YR1960&#39;, &#39;YR1961&#39;, &#39;YR1962&#39;, &#39;YR1963&#39;, &#39;YR1964&#39;, &#39;YR1965&#39;, &#39;YR1966&#39;, &#39;YR1967&#39;, &#39;YR1968&#39;, &#39;YR1969&#39;, &#39;YR1970&#39;, &#39;YR1971&#39;, &#39;YR1972&#39;, &#39;YR1973&#39;, &#39;YR1974&#39;, &#39;YR1975&#39;, &#39;YR1976&#39;, &#39;YR1977&#39;, &#39;YR1978&#39;, &#39;YR1979&#39;, &#39;YR1980&#39;, &#39;YR1981&#39;, &#39;YR1982&#39;, &#39;YR1983&#39;, &#39;YR1984&#39;, &#39;YR1985&#39;, &#39;YR1986&#39;, &#39;YR1987&#39;, &#39;YR1988&#39;, &#39;YR1989&#39;, &#39;YR1990&#39;, &#39;YR1991&#39;, &#39;YR1992&#39;, &#39;YR1993&#39;, &#39;YR1994&#39;, &#39;YR1995&#39;, &#39;YR1996&#39;, &#39;YR1997&#39;, &#39;YR1998&#39;, &#39;YR1999&#39;, &#39;YR2000&#39;, &#39;YR2001&#39;, &#39;YR2002&#39;, &#39;YR2003&#39;, &#39;YR2004&#39;, &#39;YR2005&#39;, &#39;YR2006&#39;, &#39;YR2007&#39;, &#39;YR2008&#39;, &#39;YR2009&#39;, &#39;YR2010&#39;, &#39;YR2011&#39;, &#39;YR2012&#39;, &#39;YR2013&#39;, &#39;YR2014&#39;, &#39;YR2015&#39;, &#39;YR2016&#39;, &#39;YR2017&#39;, &#39;YR2018&#39;, &#39;YR2019&#39;]) . 연도별로 세계온도가 들어가있음 . yr=list(df.keys()) . iyr=10 df_yr=df[yr[iyr]] . df_yr.keys() . Index([&#39;i&#39;, &#39;j&#39;, &#39;lon&#39;, &#39;lat&#39;, &#39;Temperature(i,j)&#39;], dtype=&#39;object&#39;) . df_yr . i j lon lat Temperature(i,j) . 0 1 | 1 | -179 | -89 | 9999.0 | . 1 2 | 1 | -177 | -89 | 9999.0 | . 2 3 | 1 | -175 | -89 | 9999.0 | . 3 4 | 1 | -173 | -89 | 9999.0 | . 4 5 | 1 | -171 | -89 | 9999.0 | . ... ... | ... | ... | ... | ... | . 16195 176 | 90 | 171 | 89 | 9999.0 | . 16196 177 | 90 | 173 | 89 | 9999.0 | . 16197 178 | 90 | 175 | 89 | 9999.0 | . 16198 179 | 90 | 177 | 89 | 9999.0 | . 16199 180 | 90 | 179 | 89 | 9999.0 | . 16200 rows × 5 columns . 위도, 경도, 온도만 발췌하여 numpy_array로 변형해보자 . data=df_yr[[&#39;lon&#39;,&#39;lat&#39;,&#39;Temperature(i,j)&#39;]].to_numpy() . data[np.where(data&gt;9999)]=np.nan . 9999를 nan으로 바꾼 이유는 자동으로 plot이 안 되게 하기 위해서 . x=np.linspace(-180,180,100) y=np.linspace(-90,90,100) grid_x,grid_y=np.meshgrid(x,y) . data_interp=interp.griddata(data[:,[0,1]],data[:,2],(grid_x,grid_y),method=&#39;linear&#39;) . . hfig,hax=plt.subplots() im=plt.imread(&#39;world_map.png&#39;) plt.imshow(im) . &lt;matplotlib.image.AxesImage at 0x142c9a2e340&gt; . 좌표축의 중심을 왼쪽 아래로 . 그런데 지도까지 뒤집혀버림 . hfig,hax=plt.subplots() im=plt.imread(&#39;world_map.png&#39;) plt.imshow(im,origin=&#39;lower&#39;) . &lt;matplotlib.image.AxesImage at 0x142c9a903a0&gt; . 다시 지도만 뒤집어줌 . hfig,hax=plt.subplots() im=plt.imread(&#39;world_map.png&#39;) plt.imshow(np.flipud(im),origin=&#39;lower&#39;) . &lt;matplotlib.image.AxesImage at 0x142c9fd75b0&gt; . size 조정 . hfig,hax=plt.subplots() im=plt.imread(&#39;world_map.png&#39;) plt.imshow(np.flipud(im),origin=&#39;lower&#39;,extent=(0,800,0,400)) . &lt;matplotlib.image.AxesImage at 0x142ca05a2b0&gt; . hfig,hax=plt.subplots() im=plt.imread(&#39;world_map.png&#39;) plt.imshow(np.flipud(im),origin=&#39;lower&#39;,extent=(-180,180,-90,90)) plt.pcolormesh(grid_x,grid_y,data_interp,cmap=&#39;coolwarm&#39;,alpha=0.6) plt.xlim(-180,180) plt.ylim(-90,90) plt.title(&#39;global temperature change from ty1880 to&#39;+str(yr[iyr])) plt.xlabel(&#39;Altitude&#39;) plt.xlabel(&#39;Latitude&#39;) plt.colorbar(fraction=0.022,pad=0.05) plt.clim(-4,4) . C: Users ehfus AppData Local Temp/ipykernel_14492/3478053917.py:4: MatplotlibDeprecationWarning: shading=&#39;flat&#39; when X and Y have the same dimensions as C is deprecated since 3.3. Either specify the corners of the quadrilaterals with X and Y, or pass shading=&#39;auto&#39;, &#39;nearest&#39; or &#39;gouraud&#39;, or set rcParams[&#39;pcolor.shading&#39;]. This will become an error two minor releases later. plt.pcolormesh(grid_x,grid_y,data_interp,cmap=&#39;coolwarm&#39;,alpha=0.6) .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/29/intro.html",
            "relUrl": "/2021/12/29/intro.html",
            "date": " • Dec 29, 2021"
        }
        
    
  
    
        ,"post3": {
            "title": "2021/12/27/MON",
            "content": "import numpy as np x_list=[1,2,3] x_tuple=1,2,3 x_set={1,2,3} x_dict={&#39;a&#39; : 1,&#39;b&#39; : 2,&#39;c&#39; : 3} x_array=np.array([1,2,3]) x_range=range(1,4,1) . for i in x_dict: print(i) . a b c . key만 나왔음, 후에 부가 설명하겠음 | . i=1 print(i) . 1 . i=2 print(i) . 2 . i=3 print(i) . 3 . 이걸 계속? . for i in [1,2,3]: print(i) . 1 2 3 . i . 3 . import time for i in [1,2,3]: print(&#39;i=&#39; + str(i)) time.sleep(1) . i=1 i=2 i=3 . 이때 i는 마지막 값인 3으로 저장될 것 | . . 1부터 100까지 = range(1,100,1) . range(101)은 0부터 100까지임 . 또는 np.linspace(1,100,100)으로도 사용가능 . . iterable object이 str일 땐? . for i in &#39;12345&#39;: print(i) . 1 2 3 4 5 . i . &#39;5&#39; . for i in &#39;python&#39;: print(i) . p y t h o n . for i in {1,2,3,4,5}: print(i) . 1 2 3 4 5 . d={&#39;P1&#39;:11,&#39;P3&#39;:31,&#39;P2&#39;:13} . d.items() . dict_items([(&#39;P1&#39;, 11), (&#39;P3&#39;, 31), (&#39;P2&#39;, 13)]) . d.keys() . dict_keys([&#39;P1&#39;, &#39;P3&#39;, &#39;P2&#39;]) . d.values() . dict_values([11, 31, 13]) . for i in d.items(): print(i) . (&#39;P1&#39;, 11) (&#39;P3&#39;, 31) (&#39;P2&#39;, 13) . i . (&#39;P2&#39;, 13) . for i in d.keys(): print(i) . P1 P3 P2 . for i in d.values(): print(i) . 11 31 13 . . for i in np.array([1,2,3]): print(i) . 1 2 3 . i . 3 . . &#48152;&#48373;&#47928; &#51473;&#52393; . for i in range(1,4,1): for j in [1,2]: print(&#39;i*j={}*{}={}&#39;.format(i,j,i*j)) . i*j=1*1=1 i*j=1*2=2 i*j=2*1=2 i*j=2*2=4 i*j=3*1=3 i*j=3*2=6 . . 반복문은 iterable일 때 사용가능 . 그렇다면 iterable?? . x_list=[1,2,3] . x_iter=iter(x_list) . next(x_iter) # 하나하나 차례로 나올 것, 그리고 마지막엔 오류 . &#39;c&#39; . x_str=&#39;abc&#39; x_iter=iter(x_str) . next(x_iter) # 하나하나 차례로 나올 것, 그리고 마지막엔 오류 . &#39;a&#39; . 값을 하나씩 불러온다는 것만 알아두자 . . for i in range(3): print(&#39;여긴 적용 O&#39;) print(&#39;--&#39;) print(&#39;여긴 적용 X&#39;) . 여긴 적용 O 여긴 적용 O 여긴 적용 O -- 여긴 적용 X . . m=np.array([1,2,3]) n=[&#39;sd&#39;,&#39;asd&#39;,&#39;asdd&#39;] q={&#39;a&#39;:11,&#39;d&#39;:22,&#39;c&#39;:123} . for i,v in enumerate(m): print(i) print(v) print(&#39; &#39;) ## i,v는 아무이름이나 가능 . 0 1 1 2 2 3 . for i,v in enumerate(q.items()): print(i) print(v) print(&#39; &#39;) ## i,v는 아무이름이나 가능 . 0 (&#39;a&#39;, 11) 1 (&#39;d&#39;, 22) 2 (&#39;c&#39;, 123) . 반복문이 몇번 돌아갔는지? | . 인덱스를 1부터 시작하게 해서 count할 수 있음 | . for i,v in enumerate(m,start=1): print(i) print(v) print(&#39; &#39;) ## i,v는 아무이름이나 가능 . 1 1 2 2 3 3 . . for i in zip(m,n): print(i) . (1, &#39;sd&#39;) (2, &#39;asd&#39;) (3, &#39;asdd&#39;) . 두 개의 container자료를 불러온 것 . list로 불러올 수 있음 . for i in zip(m,n): print(list(i)) . [1, &#39;sd&#39;] [2, &#39;asd&#39;] [3, &#39;asdd&#39;] . for i in zip(m,n,q.items()): print(list(i)) . [1, &#39;sd&#39;, (&#39;a&#39;, 11)] [2, &#39;asd&#39;, (&#39;d&#39;, 22)] [3, &#39;asdd&#39;, (&#39;c&#39;, 123)] . . 반복문 활용 예시 . s=&#39;♡Best Company♡ Tel: 123-123123&#39; for i in range(5): print(s) print(&#39; &#39;) . ♡Best Company♡ Tel: 123-123123 ♡Best Company♡ Tel: 123-123123 ♡Best Company♡ Tel: 123-123123 ♡Best Company♡ Tel: 123-123123 ♡Best Company♡ Tel: 123-123123 . a=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;] for i in a: print(&#39;Name : &#39; + i) print(&#39;오잉?&#39;) print(&#39;&#39;) . Name : a 오잉? Name : b 오잉? Name : c 오잉? . x=np.array([1,2,3,4,5]) for i in x: print(i**2) time.sleep(0.5) . 1 4 9 16 25 . x=np.array([1,2,3,4,5]) for i,x in enumerate(x): print(i) print(x) print(&#39;&#39;) . 0 1 1 2 2 3 3 4 4 5 . x=np.array([1,2,3,4,5]) y=np.zeros(x.shape) for i,x in enumerate(x): y[i]=x**2 print(y) . [1. 0. 0. 0. 0.] [1. 4. 0. 0. 0.] [1. 4. 9. 0. 0.] [ 1. 4. 9. 16. 0.] [ 1. 4. 9. 16. 25.] . . a=np.array([1,2,3,]) y=a**2 . y . array([1, 4, 9], dtype=int32) . 이렇게 해결할 수 있는 걸 굳이 반복문 사용할 필요는 없음 | . . 피보나치 수열 :앞에 숫자를 계속 더해주는$ dots$ . a=np.array([0,1]) for i in range(3): a=np.append(a,a[-1]+a[-2]) print(a) . [0 1 1] [0 1 1 2] [0 1 1 2 3] . . a,b=0,1 for i in range(10): print(a) a,b=b,a+b . 0 1 1 2 3 5 8 13 21 34 . 피보나치 수열을 이렇게 표현할 수도 있음 | . . ***&#51312;&#44148;&#47928; . x=input(&#39;Type any number: &#39;) if x.isdigit(): y=int(x)+1 print(&#39;Result is {}&#39;.format(y)) else : print(&#39;정수 쳐 넣어&#39;) . 정수 쳐 넣어 . 첫번째 줄에서 입력되는 것이 숫자인지 문자인지? $ to$ isdigit을 이용!! | . x=input(&#39;Type any number: &#39;) while x.isdigit() != True : x=input(&#39;Try again: &#39;) y=int(x)+1 print(&#39;Result is {}&#39;.format(y)) . Result is 6 . while문 =&gt; 무한 반복 . x=int(input(&#39;몇살이니? : &#39;)) if x&gt;=18 : print(&#39;면허 딸 수 있겠다&#39;) elif x&gt;=15 &amp; x&lt;18 : print(&#39;승인은 가능하겠다&#39;) else : print(&#39;나이가 어려서 안 돼&#39;) . 면허 딸 수 있겠다 . x=int(input(&#39;몇살이니? : &#39;)) if x&gt;=18 : print(&#39;면허 딸 수 있겠다&#39;) elif x&gt;=15 &amp; x&lt;18 : print(&#39;승인은 가능하겠다&#39;) else : print(&#39;나이가 어려서 안 돼&#39;) . 승인은 가능하겠다 . x=int(input(&#39;몇살이니? : &#39;)) if x&gt;=18 : print(&#39;면허 딸 수 있겠다&#39;) elif x&gt;=15 and x&lt;18 : print(&#39;승인은 가능하겠다&#39;) else : print(&#39;나이가 어려서 안 돼&#39;) . 나이가 어려서 안 돼 . &#44536;&#47088;&#45936; and &#45824;&#49888;&#50640; &amp; &#49324;&#50857;&#54616;&#47732; &#50504; &#46120; . 알아보기 . . a=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;] check=input(&#39;please name: &#39;) if check in a : print(&#39;어서와&#39; +&quot; &quot; + check+&#39;야&#39;) else : print(&#39;넌 명단에 없네&#39;) . 넌 명단에 없네 . . While . vip=[&#39;a&#39;,&#39;b&#39;,&#39;c&#39;,&#39;d&#39;] a=[1,2] a_=[] . bool(a) . True . bool(a_) . False . while은 참일때만 실행하니까 vip리스트에 하나도 없으면, 즉 FALSE이면 실행 멈출 것 . while vip: print(vip.pop(0)) print(&#39;remaining guest #: {}&#39;.format(len(vip))) . a remaining guest #: 3 b remaining guest #: 2 c remaining guest #: 1 d remaining guest #: 0 . . pop(인덱스), 즉 해당 인덱스값 삭제 . pop =&gt; 튕겨버림 =&gt; 버려버림 . . balance=10000 # 가지고 있는 돈 interest=0.05 # 이자율 yr=0 # 시작 연도 # 통장에 10000원 넣어놓고 몇년이 지나야 20000원이 될까? . while balance &lt; 20000: balance=balance*(1+interest) yr+=1 print(&#39;# of Year : {}&#39;.format(yr)) print(&#39;Current values= {}&#39;.format(balance)) . # of Year : 1 Current values= 10500.0 # of Year : 2 Current values= 11025.0 # of Year : 3 Current values= 11576.25 # of Year : 4 Current values= 12155.0625 # of Year : 5 Current values= 12762.815625000001 # of Year : 6 Current values= 13400.956406250001 # of Year : 7 Current values= 14071.004226562502 # of Year : 8 Current values= 14774.554437890627 # of Year : 9 Current values= 15513.28215978516 # of Year : 10 Current values= 16288.946267774418 # of Year : 11 Current values= 17103.393581163138 # of Year : 12 Current values= 17958.563260221297 # of Year : 13 Current values= 18856.491423232364 # of Year : 14 Current values= 19799.315994393983 # of Year : 15 Current values= 20789.281794113682 . . 즉 15년까지 while이 진행됐다는 건 15년째 20000을 넘었기 때문에 다음 16이 진행 안 된 것 , . 따라서 15년때 20000을 넘은 것을 알 수 있음 . . for i in range(5): print(i) if i ==3 : break . 0 1 2 3 . balance=10000 # 가지고 있는 돈 interest=0.05 # 이자율 yr=0 # 시작 연도 for i in range(10000): balance=balance*(1+interest) yr+=1 print(&#39;# of Year : {}&#39;.format(yr)) print(&#39;Current values= {}&#39;.format(balance)) if balance &gt;20000 : break . # of Year : 1 Current values= 10500.0 # of Year : 2 Current values= 11025.0 # of Year : 3 Current values= 11576.25 # of Year : 4 Current values= 12155.0625 # of Year : 5 Current values= 12762.815625000001 # of Year : 6 Current values= 13400.956406250001 # of Year : 7 Current values= 14071.004226562502 # of Year : 8 Current values= 14774.554437890627 # of Year : 9 Current values= 15513.28215978516 # of Year : 10 Current values= 16288.946267774418 # of Year : 11 Current values= 17103.393581163138 # of Year : 12 Current values= 17958.563260221297 # of Year : 13 Current values= 18856.491423232364 # of Year : 14 Current values= 19799.315994393983 # of Year : 15 Current values= 20789.281794113682 . 즉 15는 20000을 넘어서 break된 것을 알 수 있음 . . for i in range(5): continue print(i) . 왜 아무것도 출력 $X$ ? . 반복문은 다섯번 반복됐으나 그럴 때마다 continue를 만나서 다시 위로 올라가서 반복했기 때문 | . for i in range(5): if i==2 : continue print(i) . 0 1 3 4 . 2와 같을 땐 밑에 줄 신경 안쓰고 그냥 바로 위로 쭉 올라감 . . temp=[18,19,20,-10,-20,-30] . for t in temp: print(&#39;T={}&#39;.format(t)) . T=18 T=19 T=20 T=-10 T=-20 T=-30 . 이때 -값은 오류라고 생각하고 print하고 싶지 않을 땐? . for t in temp: if t&lt;0 : continue print(&#39;T={}&#39;.format(t)) . T=18 T=19 T=20 . . for x in range(5): pass x=1 . x . 1 . if True: pass x=1 . x . 1 . def myfun(): pass a=23 . a . 23 . 그냥 일단 패스시켜놓고 나중에 완성 시키고 싶을 때 . . 예외처리? . age=int(input(&#39;몇살이니?: &#39;)) print(&#39;Age={}&#39;.format(age)) . Age=555 . 만약 여기서 숫자가 아닌 문자를 넣으면 value error가 발생할 것 . while True: try: age=int(input(&#39;몇살이니?: &#39;)) print(&#39;Age={}&#39;.format(age)) break except ValueError: print(&#39;숫자를 입력해주세요&#39;) . 숫자를 입력해주세요 . 숫자를 입력해주세요 . 숫자를 입력해주세요 . 숫자를 입력해주세요 . Age=555 . 숫자를 입력할 때까지 while문이 실행될 것 . a=np.array([10,20,30,40,50]) num_max=np.NINF # 음의 무한대를 의미함 for i in a: num_curr = i if num_max &lt; num_curr: num_max=num_curr . num_max . 50 . . a=np.array([1,2,3,4,5,6]) for i in a: if i%2==0: print(&#39;{}는 짝수&#39;.format(i)) else : print(&#39;{}는 홀수&#39;.format(i)) . 1는 홀수 2는 짝수 3는 홀수 4는 짝수 5는 홀수 6는 짝수 . . User Interface Example/ UI . db={&#39;a&#39;:&#39;a1&#39;,&#39;b&#39;:&#39;b1&#39;,&#39;c&#39;:&#39;c1&#39;} password_attemps=3 while password_attemps &gt; 0 : user_id = input(&#39;ID: &#39;) user_ps = input(&#39;PW: &#39;) if user_id in db.keys() and user_ps in db.values() : print(&#39; nLog in Successful!&#39;) break else: password_attemps-=1 print(&#39; nTry againㅠㅠ&#39;) print(&#39;{} 번 더 시도 가능하십니다&#39;.format(password_attemps)) . Try againㅠㅠ 2 번 더 시도 가능하십니다 . Try againㅠㅠ 1 번 더 시도 가능하십니다 . Try againㅠㅠ 0 번 더 시도 가능하십니다 . import getpass 기능을 이용해서 password입력 할 때 해당 PW를 안 보이게 해줄 수 있음 . . my_str=&#39;python&#39; my_str2=[] for letter in my_str: my_str2.append(letter) . my_str . &#39;python&#39; . my_str2 . [&#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;] . $ to$ 이걸 한 줄로 가능하게 하는 것이 List Comprehension . my_str3=[letter for letter in my_str] my_str3 . [&#39;p&#39;, &#39;y&#39;, &#39;t&#39;, &#39;h&#39;, &#39;o&#39;, &#39;n&#39;] . list comprehension + 조건 . num=[a for a in range(20) if a%2==0] . num . [0, 2, 4, 6, 8, 10, 12, 14, 16, 18] . num=[a for a in range(20) if a%2!=0] . num . [1, 3, 5, 7, 9, 11, 13, 15, 17, 19] . num=[a for a in range(50) if a%5==0 and a%2==0] . num . [0, 10, 20, 30, 40] . 또는 . num=[a for a in range(50) if a%5==0 if a%2==0] . num . [0, 10, 20, 30, 40] . . aaa=[&#39;짝수&#39;if i%2==0 else &#39;홀수&#39; for i in range(10)] . aaa . [&#39;짝수&#39;, &#39;홀수&#39;, &#39;짝수&#39;, &#39;홀수&#39;, &#39;짝수&#39;, &#39;홀수&#39;, &#39;짝수&#39;, &#39;홀수&#39;, &#39;짝수&#39;, &#39;홀수&#39;] . . dict comprehension . a={i:i**2 for i in range(6)} a . {0: 0, 1: 1, 2: 4, 3: 9, 4: 16, 5: 25} . . import sys,os . print(os.getcwd()) . C: Users ehfus Downloads python Introduction . os.mkdir(&#39;my_dir&#39;) # 현재 있는 위치에서 my_dir을 하나 만듦 . os.chdir(&#39;. my_dir&#39;) . 파일 100개 만들어보자 . for i in range(100): f=open(&#39;NewFile&#39;+str(i),&#39;w&#39;) # 파일을 쓸 거니까 &#39;w&#39; f.close() . 100개의 파일에 뭘 쓰진 않았음. 이제 파일의 이름을 바꿔보자 . 반복문을 통해 100개의 파일 이름을 바꾸기 전에 100개 파일의 이름을 일단 받아오자 . flist=os.listdir(&#39;.&#39;) . flist . [&#39;NewFile0&#39;, &#39;NewFile1&#39;, &#39;NewFile10&#39;, &#39;NewFile11&#39;, &#39;NewFile12&#39;, &#39;NewFile13&#39;, &#39;NewFile14&#39;, &#39;NewFile15&#39;, &#39;NewFile16&#39;, &#39;NewFile17&#39;, &#39;NewFile18&#39;, &#39;NewFile19&#39;, &#39;NewFile2&#39;, &#39;NewFile20&#39;, &#39;NewFile21&#39;, &#39;NewFile22&#39;, &#39;NewFile23&#39;, &#39;NewFile24&#39;, &#39;NewFile25&#39;, &#39;NewFile26&#39;, &#39;NewFile27&#39;, &#39;NewFile28&#39;, &#39;NewFile29&#39;, &#39;NewFile3&#39;, &#39;NewFile30&#39;, &#39;NewFile31&#39;, &#39;NewFile32&#39;, &#39;NewFile33&#39;, &#39;NewFile34&#39;, &#39;NewFile35&#39;, &#39;NewFile36&#39;, &#39;NewFile37&#39;, &#39;NewFile38&#39;, &#39;NewFile39&#39;, &#39;NewFile4&#39;, &#39;NewFile40&#39;, &#39;NewFile41&#39;, &#39;NewFile42&#39;, &#39;NewFile43&#39;, &#39;NewFile44&#39;, &#39;NewFile45&#39;, &#39;NewFile46&#39;, &#39;NewFile47&#39;, &#39;NewFile48&#39;, &#39;NewFile49&#39;, &#39;NewFile5&#39;, &#39;NewFile50&#39;, &#39;NewFile51&#39;, &#39;NewFile52&#39;, &#39;NewFile53&#39;, &#39;NewFile54&#39;, &#39;NewFile55&#39;, &#39;NewFile56&#39;, &#39;NewFile57&#39;, &#39;NewFile58&#39;, &#39;NewFile59&#39;, &#39;NewFile6&#39;, &#39;NewFile60&#39;, &#39;NewFile61&#39;, &#39;NewFile62&#39;, &#39;NewFile63&#39;, &#39;NewFile64&#39;, &#39;NewFile65&#39;, &#39;NewFile66&#39;, &#39;NewFile67&#39;, &#39;NewFile68&#39;, &#39;NewFile69&#39;, &#39;NewFile7&#39;, &#39;NewFile70&#39;, &#39;NewFile71&#39;, &#39;NewFile72&#39;, &#39;NewFile73&#39;, &#39;NewFile74&#39;, &#39;NewFile75&#39;, &#39;NewFile76&#39;, &#39;NewFile77&#39;, &#39;NewFile78&#39;, &#39;NewFile79&#39;, &#39;NewFile8&#39;, &#39;NewFile80&#39;, &#39;NewFile81&#39;, &#39;NewFile82&#39;, &#39;NewFile83&#39;, &#39;NewFile84&#39;, &#39;NewFile85&#39;, &#39;NewFile86&#39;, &#39;NewFile87&#39;, &#39;NewFile88&#39;, &#39;NewFile89&#39;, &#39;NewFile9&#39;, &#39;NewFile90&#39;, &#39;NewFile91&#39;, &#39;NewFile92&#39;, &#39;NewFile93&#39;, &#39;NewFile94&#39;, &#39;NewFile95&#39;, &#39;NewFile96&#39;, &#39;NewFile97&#39;, &#39;NewFile98&#39;, &#39;NewFile99&#39;] . for fid in flist: f_name=fid[0:7] f_num=fid[7::] if int(f_num)&lt;50: os.replace(fid,&#39;2019_&#39;+fid) else: os.replace(fid,&#39;2020_&#39;+fid) . 2019년도 파일 2020년도 파일을 두개의 디렉토리에 각각 넣어보자 . os.mkdir(&#39;2019_data&#39;) os.mkdir(&#39;2020_data&#39;) . flist=os.listdir(&#39;.&#39;) . flist . [&#39;2019_data&#39;, &#39;2019_NewFile0&#39;, &#39;2019_NewFile1&#39;, &#39;2019_NewFile10&#39;, &#39;2019_NewFile11&#39;, &#39;2019_NewFile12&#39;, &#39;2019_NewFile13&#39;, &#39;2019_NewFile14&#39;, &#39;2019_NewFile15&#39;, &#39;2019_NewFile16&#39;, &#39;2019_NewFile17&#39;, &#39;2019_NewFile18&#39;, &#39;2019_NewFile19&#39;, &#39;2019_NewFile2&#39;, &#39;2019_NewFile20&#39;, &#39;2019_NewFile21&#39;, &#39;2019_NewFile22&#39;, &#39;2019_NewFile23&#39;, &#39;2019_NewFile24&#39;, &#39;2019_NewFile25&#39;, &#39;2019_NewFile26&#39;, &#39;2019_NewFile27&#39;, &#39;2019_NewFile28&#39;, &#39;2019_NewFile29&#39;, &#39;2019_NewFile3&#39;, &#39;2019_NewFile30&#39;, &#39;2019_NewFile31&#39;, &#39;2019_NewFile32&#39;, &#39;2019_NewFile33&#39;, &#39;2019_NewFile34&#39;, &#39;2019_NewFile35&#39;, &#39;2019_NewFile36&#39;, &#39;2019_NewFile37&#39;, &#39;2019_NewFile38&#39;, &#39;2019_NewFile39&#39;, &#39;2019_NewFile4&#39;, &#39;2019_NewFile40&#39;, &#39;2019_NewFile41&#39;, &#39;2019_NewFile42&#39;, &#39;2019_NewFile43&#39;, &#39;2019_NewFile44&#39;, &#39;2019_NewFile45&#39;, &#39;2019_NewFile46&#39;, &#39;2019_NewFile47&#39;, &#39;2019_NewFile48&#39;, &#39;2019_NewFile49&#39;, &#39;2019_NewFile5&#39;, &#39;2019_NewFile6&#39;, &#39;2019_NewFile7&#39;, &#39;2019_NewFile8&#39;, &#39;2019_NewFile9&#39;, &#39;2020_data&#39;, &#39;2020_NewFile50&#39;, &#39;2020_NewFile51&#39;, &#39;2020_NewFile52&#39;, &#39;2020_NewFile53&#39;, &#39;2020_NewFile54&#39;, &#39;2020_NewFile55&#39;, &#39;2020_NewFile56&#39;, &#39;2020_NewFile57&#39;, &#39;2020_NewFile58&#39;, &#39;2020_NewFile59&#39;, &#39;2020_NewFile60&#39;, &#39;2020_NewFile61&#39;, &#39;2020_NewFile62&#39;, &#39;2020_NewFile63&#39;, &#39;2020_NewFile64&#39;, &#39;2020_NewFile65&#39;, &#39;2020_NewFile66&#39;, &#39;2020_NewFile67&#39;, &#39;2020_NewFile68&#39;, &#39;2020_NewFile69&#39;, &#39;2020_NewFile70&#39;, &#39;2020_NewFile71&#39;, &#39;2020_NewFile72&#39;, &#39;2020_NewFile73&#39;, &#39;2020_NewFile74&#39;, &#39;2020_NewFile75&#39;, &#39;2020_NewFile76&#39;, &#39;2020_NewFile77&#39;, &#39;2020_NewFile78&#39;, &#39;2020_NewFile79&#39;, &#39;2020_NewFile80&#39;, &#39;2020_NewFile81&#39;, &#39;2020_NewFile82&#39;, &#39;2020_NewFile83&#39;, &#39;2020_NewFile84&#39;, &#39;2020_NewFile85&#39;, &#39;2020_NewFile86&#39;, &#39;2020_NewFile87&#39;, &#39;2020_NewFile88&#39;, &#39;2020_NewFile89&#39;, &#39;2020_NewFile90&#39;, &#39;2020_NewFile91&#39;, &#39;2020_NewFile92&#39;, &#39;2020_NewFile93&#39;, &#39;2020_NewFile94&#39;, &#39;2020_NewFile95&#39;, &#39;2020_NewFile96&#39;, &#39;2020_NewFile97&#39;, &#39;2020_NewFile98&#39;, &#39;2020_NewFile99&#39;] . from itertools import compress . idx = list(map(lambda x:&#39;File&#39; in x, flist)) flist2 = list(compress(flist,idx)) . flist2 . [&#39;2019_NewFile0&#39;, &#39;2019_NewFile1&#39;, &#39;2019_NewFile10&#39;, &#39;2019_NewFile11&#39;, &#39;2019_NewFile12&#39;, &#39;2019_NewFile13&#39;, &#39;2019_NewFile14&#39;, &#39;2019_NewFile15&#39;, &#39;2019_NewFile16&#39;, &#39;2019_NewFile17&#39;, &#39;2019_NewFile18&#39;, &#39;2019_NewFile19&#39;, &#39;2019_NewFile2&#39;, &#39;2019_NewFile20&#39;, &#39;2019_NewFile21&#39;, &#39;2019_NewFile22&#39;, &#39;2019_NewFile23&#39;, &#39;2019_NewFile24&#39;, &#39;2019_NewFile25&#39;, &#39;2019_NewFile26&#39;, &#39;2019_NewFile27&#39;, &#39;2019_NewFile28&#39;, &#39;2019_NewFile29&#39;, &#39;2019_NewFile3&#39;, &#39;2019_NewFile30&#39;, &#39;2019_NewFile31&#39;, &#39;2019_NewFile32&#39;, &#39;2019_NewFile33&#39;, &#39;2019_NewFile34&#39;, &#39;2019_NewFile35&#39;, &#39;2019_NewFile36&#39;, &#39;2019_NewFile37&#39;, &#39;2019_NewFile38&#39;, &#39;2019_NewFile39&#39;, &#39;2019_NewFile4&#39;, &#39;2019_NewFile40&#39;, &#39;2019_NewFile41&#39;, &#39;2019_NewFile42&#39;, &#39;2019_NewFile43&#39;, &#39;2019_NewFile44&#39;, &#39;2019_NewFile45&#39;, &#39;2019_NewFile46&#39;, &#39;2019_NewFile47&#39;, &#39;2019_NewFile48&#39;, &#39;2019_NewFile49&#39;, &#39;2019_NewFile5&#39;, &#39;2019_NewFile6&#39;, &#39;2019_NewFile7&#39;, &#39;2019_NewFile8&#39;, &#39;2019_NewFile9&#39;, &#39;2020_NewFile50&#39;, &#39;2020_NewFile51&#39;, &#39;2020_NewFile52&#39;, &#39;2020_NewFile53&#39;, &#39;2020_NewFile54&#39;, &#39;2020_NewFile55&#39;, &#39;2020_NewFile56&#39;, &#39;2020_NewFile57&#39;, &#39;2020_NewFile58&#39;, &#39;2020_NewFile59&#39;, &#39;2020_NewFile60&#39;, &#39;2020_NewFile61&#39;, &#39;2020_NewFile62&#39;, &#39;2020_NewFile63&#39;, &#39;2020_NewFile64&#39;, &#39;2020_NewFile65&#39;, &#39;2020_NewFile66&#39;, &#39;2020_NewFile67&#39;, &#39;2020_NewFile68&#39;, &#39;2020_NewFile69&#39;, &#39;2020_NewFile70&#39;, &#39;2020_NewFile71&#39;, &#39;2020_NewFile72&#39;, &#39;2020_NewFile73&#39;, &#39;2020_NewFile74&#39;, &#39;2020_NewFile75&#39;, &#39;2020_NewFile76&#39;, &#39;2020_NewFile77&#39;, &#39;2020_NewFile78&#39;, &#39;2020_NewFile79&#39;, &#39;2020_NewFile80&#39;, &#39;2020_NewFile81&#39;, &#39;2020_NewFile82&#39;, &#39;2020_NewFile83&#39;, &#39;2020_NewFile84&#39;, &#39;2020_NewFile85&#39;, &#39;2020_NewFile86&#39;, &#39;2020_NewFile87&#39;, &#39;2020_NewFile88&#39;, &#39;2020_NewFile89&#39;, &#39;2020_NewFile90&#39;, &#39;2020_NewFile91&#39;, &#39;2020_NewFile92&#39;, &#39;2020_NewFile93&#39;, &#39;2020_NewFile94&#39;, &#39;2020_NewFile95&#39;, &#39;2020_NewFile96&#39;, &#39;2020_NewFile97&#39;, &#39;2020_NewFile98&#39;, &#39;2020_NewFile99&#39;] . dir이름은 없고 파일이름만 뽑아온 것 . 두번째 방법 . flist3=list(filter(lambda x: &#39;File&#39; in x, flist)) . flist3 . [&#39;2019_NewFile0&#39;, &#39;2019_NewFile1&#39;, &#39;2019_NewFile10&#39;, &#39;2019_NewFile11&#39;, &#39;2019_NewFile12&#39;, &#39;2019_NewFile13&#39;, &#39;2019_NewFile14&#39;, &#39;2019_NewFile15&#39;, &#39;2019_NewFile16&#39;, &#39;2019_NewFile17&#39;, &#39;2019_NewFile18&#39;, &#39;2019_NewFile19&#39;, &#39;2019_NewFile2&#39;, &#39;2019_NewFile20&#39;, &#39;2019_NewFile21&#39;, &#39;2019_NewFile22&#39;, &#39;2019_NewFile23&#39;, &#39;2019_NewFile24&#39;, &#39;2019_NewFile25&#39;, &#39;2019_NewFile26&#39;, &#39;2019_NewFile27&#39;, &#39;2019_NewFile28&#39;, &#39;2019_NewFile29&#39;, &#39;2019_NewFile3&#39;, &#39;2019_NewFile30&#39;, &#39;2019_NewFile31&#39;, &#39;2019_NewFile32&#39;, &#39;2019_NewFile33&#39;, &#39;2019_NewFile34&#39;, &#39;2019_NewFile35&#39;, &#39;2019_NewFile36&#39;, &#39;2019_NewFile37&#39;, &#39;2019_NewFile38&#39;, &#39;2019_NewFile39&#39;, &#39;2019_NewFile4&#39;, &#39;2019_NewFile40&#39;, &#39;2019_NewFile41&#39;, &#39;2019_NewFile42&#39;, &#39;2019_NewFile43&#39;, &#39;2019_NewFile44&#39;, &#39;2019_NewFile45&#39;, &#39;2019_NewFile46&#39;, &#39;2019_NewFile47&#39;, &#39;2019_NewFile48&#39;, &#39;2019_NewFile49&#39;, &#39;2019_NewFile5&#39;, &#39;2019_NewFile6&#39;, &#39;2019_NewFile7&#39;, &#39;2019_NewFile8&#39;, &#39;2019_NewFile9&#39;, &#39;2020_NewFile50&#39;, &#39;2020_NewFile51&#39;, &#39;2020_NewFile52&#39;, &#39;2020_NewFile53&#39;, &#39;2020_NewFile54&#39;, &#39;2020_NewFile55&#39;, &#39;2020_NewFile56&#39;, &#39;2020_NewFile57&#39;, &#39;2020_NewFile58&#39;, &#39;2020_NewFile59&#39;, &#39;2020_NewFile60&#39;, &#39;2020_NewFile61&#39;, &#39;2020_NewFile62&#39;, &#39;2020_NewFile63&#39;, &#39;2020_NewFile64&#39;, &#39;2020_NewFile65&#39;, &#39;2020_NewFile66&#39;, &#39;2020_NewFile67&#39;, &#39;2020_NewFile68&#39;, &#39;2020_NewFile69&#39;, &#39;2020_NewFile70&#39;, &#39;2020_NewFile71&#39;, &#39;2020_NewFile72&#39;, &#39;2020_NewFile73&#39;, &#39;2020_NewFile74&#39;, &#39;2020_NewFile75&#39;, &#39;2020_NewFile76&#39;, &#39;2020_NewFile77&#39;, &#39;2020_NewFile78&#39;, &#39;2020_NewFile79&#39;, &#39;2020_NewFile80&#39;, &#39;2020_NewFile81&#39;, &#39;2020_NewFile82&#39;, &#39;2020_NewFile83&#39;, &#39;2020_NewFile84&#39;, &#39;2020_NewFile85&#39;, &#39;2020_NewFile86&#39;, &#39;2020_NewFile87&#39;, &#39;2020_NewFile88&#39;, &#39;2020_NewFile89&#39;, &#39;2020_NewFile90&#39;, &#39;2020_NewFile91&#39;, &#39;2020_NewFile92&#39;, &#39;2020_NewFile93&#39;, &#39;2020_NewFile94&#39;, &#39;2020_NewFile95&#39;, &#39;2020_NewFile96&#39;, &#39;2020_NewFile97&#39;, &#39;2020_NewFile98&#39;, &#39;2020_NewFile99&#39;] . 세번째 방법 . file4=[x for x in flist if &#39;File&#39; in x] . 네번째 방법 . import glob glob.glob(&#39;2020_NewFile??&#39;) . [&#39;2020_NewFile50&#39;, &#39;2020_NewFile51&#39;, &#39;2020_NewFile52&#39;, &#39;2020_NewFile53&#39;, &#39;2020_NewFile54&#39;, &#39;2020_NewFile55&#39;, &#39;2020_NewFile56&#39;, &#39;2020_NewFile57&#39;, &#39;2020_NewFile58&#39;, &#39;2020_NewFile59&#39;, &#39;2020_NewFile60&#39;, &#39;2020_NewFile61&#39;, &#39;2020_NewFile62&#39;, &#39;2020_NewFile63&#39;, &#39;2020_NewFile64&#39;, &#39;2020_NewFile65&#39;, &#39;2020_NewFile66&#39;, &#39;2020_NewFile67&#39;, &#39;2020_NewFile68&#39;, &#39;2020_NewFile69&#39;, &#39;2020_NewFile70&#39;, &#39;2020_NewFile71&#39;, &#39;2020_NewFile72&#39;, &#39;2020_NewFile73&#39;, &#39;2020_NewFile74&#39;, &#39;2020_NewFile75&#39;, &#39;2020_NewFile76&#39;, &#39;2020_NewFile77&#39;, &#39;2020_NewFile78&#39;, &#39;2020_NewFile79&#39;, &#39;2020_NewFile80&#39;, &#39;2020_NewFile81&#39;, &#39;2020_NewFile82&#39;, &#39;2020_NewFile83&#39;, &#39;2020_NewFile84&#39;, &#39;2020_NewFile85&#39;, &#39;2020_NewFile86&#39;, &#39;2020_NewFile87&#39;, &#39;2020_NewFile88&#39;, &#39;2020_NewFile89&#39;, &#39;2020_NewFile90&#39;, &#39;2020_NewFile91&#39;, &#39;2020_NewFile92&#39;, &#39;2020_NewFile93&#39;, &#39;2020_NewFile94&#39;, &#39;2020_NewFile95&#39;, &#39;2020_NewFile96&#39;, &#39;2020_NewFile97&#39;, &#39;2020_NewFile98&#39;, &#39;2020_NewFile99&#39;] . 이런식으로 . file5=glob.glob(&#39;*File*&#39;) . . 이제 파일들을 각 년도 dir에 넣어보자 . import shutil . for f_curr in file5: f_name = f_curr[0:12] f_num = f_curr[12::] if int(f_num) &lt; 50: shutil.move(f_curr,&#39;. 2019_data&#39;) else: shutil.move(f_curr,&#39;. 2020_data&#39;) . dir에 파일들이 각각 들어갔음 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/27/intro.html",
            "relUrl": "/2021/12/27/intro.html",
            "date": " • Dec 27, 2021"
        }
        
    
  
    
        ,"post4": {
            "title": "2021/12/26/SUN",
            "content": "import numpy as np import pandas as pd !pip install openpyxl from openpyxl import load_workbook . Requirement already satisfied: openpyxl in c: users ehfus anaconda3 envs dv2021 lib site-packages (3.0.9) Requirement already satisfied: et-xmlfile in c: users ehfus anaconda3 envs dv2021 lib site-packages (from openpyxl) (1.1.0) . data = {&#39;Name&#39; : [&#39;S1&#39;,&#39;S2&#39;,&#39;S3&#39;], &#39;Age&#39; : [25,28,22], &#39;Score&#39; : np.array([95,80,75])} print(data) . {&#39;Name&#39;: [&#39;S1&#39;, &#39;S2&#39;, &#39;S3&#39;], &#39;Age&#39;: [25, 28, 22], &#39;Score&#39;: array([95, 80, 75])} . data[&#39;Name&#39;] . [&#39;S1&#39;, &#39;S2&#39;, &#39;S3&#39;] . df=pd.DataFrame(data) . df . Name Age Score . 0 S1 | 25 | 95 | . 1 S2 | 28 | 80 | . 2 S3 | 22 | 75 | . df=pd.DataFrame(data,index=[&#39;row1&#39;,&#39;row2&#39;,&#39;row3&#39;]) df . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . 리스트도 df로 변경 가능 . data2=[[&#39;S1&#39;,25,95],[&#39;S2&#39;,28,80],[&#39;S3&#39;,22,75]] . df2=pd.DataFrame(data2,index=[&#39;row1&#39;,&#39;row2&#39;,&#39;row3&#39;],columns=[&#39;Name&#39;,&#39;Age&#39;,&#39;Score&#39;]) . df2 . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . . Subset Observation . df . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . df[[&#39;Name&#39;]] . Name . row1 S1 | . row2 S2 | . row3 S3 | . df[&#39;Name&#39;] . row1 S1 row2 S2 row3 S3 Name: Name, dtype: object . df[[&#39;Name&#39;,&#39;Score&#39;]] # 이렇게 list안에 넣어줘야 함 . Name Score . row1 S1 | 95 | . row2 S2 | 80 | . row3 S3 | 75 | . # 이렇게 행은 추출할 수 없음 . 그렇다면? . df.loc[[&#39;row1&#39;]] . Name Age Score . row1 S1 | 25 | 95 | . df.loc[&#39;row1&#39;] . Name S1 Age 25 Score 95 Name: row1, dtype: object . df.loc[[&#39;row1&#39;,&#39;row2&#39;]] . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . df.loc[&#39;row1&#39;,&#39;Name&#39;] . &#39;S1&#39; . df[&#39;Name&#39;] #df.loc[&#39;Name&#39;] 이건 안 됨 . row1 S1 row2 S2 row3 S3 Name: Name, dtype: object . 이렇게 사용 . df.loc[:,&#39;Name&#39;] . row1 S1 row2 S2 row3 S3 Name: Name, dtype: object . df.loc[:,[&#39;Score&#39;,&#39;Name&#39;]] . Score Name . row1 95 | S1 | . row2 80 | S2 | . row3 75 | S3 | . df.loc[:,&#39;Name&#39;:&#39;Age&#39;] # : 사용할 땐 중괄호 X . Name Age . row1 S1 | 25 | . row2 S2 | 28 | . row3 S3 | 22 | . df.iloc[0,0] . &#39;S1&#39; . df.iloc[2,0] . &#39;S3&#39; . df.iloc[:,[0,2]] . Name Score . row1 S1 | 95 | . row2 S2 | 80 | . row3 S3 | 75 | . df.iloc[::2,[0,2]] . Name Score . row1 S1 | 95 | . row3 S3 | 75 | . df.iloc[-1,:] . Name S3 Age 22 Score 75 Name: row3, dtype: object . df.iloc[-1::-1,:] . Name Age Score . row3 S3 | 22 | 75 | . row2 S2 | 28 | 80 | . row1 S1 | 25 | 95 | . 마지막부터 data가 뒤집혀서 불리어짐 . df.head(2) . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . df.tail(1) . Name Age Score . row3 S3 | 22 | 75 | . default는 5갠가 여섯개임 - 괄호안에 원하는 숫자 삽입가능 . df.info() # 열,행갯수, 칼럼 이름. data type 등등 . &lt;class &#39;pandas.core.frame.DataFrame&#39;&gt; Index: 3 entries, row1 to row3 Data columns (total 3 columns): # Column Non-Null Count Dtype -- -- 0 Name 3 non-null object 1 Age 3 non-null int64 2 Score 3 non-null int32 dtypes: int32(1), int64(1), object(1) memory usage: 192.0+ bytes . df.describe() # 통계적 수치들을 알 수 있음 . Age Score . count 3.0 | 3.000000 | . mean 25.0 | 83.333333 | . std 3.0 | 10.408330 | . min 22.0 | 75.000000 | . 25% 23.5 | 77.500000 | . 50% 25.0 | 80.000000 | . 75% 26.5 | 87.500000 | . max 28.0 | 95.000000 | . df2=df.copy() . df2 . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . df2.loc[&#39;row2&#39;,&#39;Score&#39;]=np.NaN . df2 . Name Age Score . row1 S1 | 25 | 95.0 | . row2 S2 | 28 | NaN | . row3 S3 | 22 | 75.0 | . df2.nunique() . Name 3 Age 3 Score 2 dtype: int64 . Score에 NaN들어가 있어서 Score는 nunique가 2개임 . df2[&#39;Score&#39;].nunique() . 2 . df2[&#39;Score&#39;].value_counts() ## 각 값들의 갯수를 알 수 있음 . 95.0 1 75.0 1 Name: Score, dtype: int64 . df3=df2.copy() df3.loc[&#39;row3&#39;,&#39;Score&#39;]=df2.loc[&#39;row1&#39;,&#39;Score&#39;] . df3[&#39;Score&#39;].value_counts() . 95.0 2 Name: Score, dtype: int64 . 그냥 몇개 들어있는지도 알 수 있음 . df3[&#39;Score&#39;].count() . 2 . df3[&#39;Age&#39;].count() . 3 . df[&#39;Score&#39;].sum() . 250 . df.max() . Name S3 Age 28 Score 95 dtype: object . df[&#39;Score&#39;].std() . 10.408329997330664 . df.describe() . Age Score . count 3.0 | 3.000000 | . mean 25.0 | 83.333333 | . std 3.0 | 10.408330 | . min 22.0 | 75.000000 | . 25% 23.5 | 77.500000 | . 50% 25.0 | 80.000000 | . 75% 26.5 | 87.500000 | . max 28.0 | 95.000000 | . 동일 . . df4=df.copy() . df4 . Name Age Score . row1 S1 | 25 | 95 | . row2 S2 | 28 | 80 | . row3 S3 | 22 | 75 | . df4=df4.iloc[:,[0,2,1]] . df4 . Name Score Age . row1 S1 | 95 | 25 | . row2 S2 | 80 | 28 | . row3 S3 | 75 | 22 | . df4의 열을 변경해줬음 . data={ &#39;class&#39; : [&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;A&#39;,&#39;B&#39;,&#39;C&#39;,&#39;C&#39;], &#39;name&#39; : [&#39;S1&#39;,&#39;S2&#39;,&#39;S3&#39;,&#39;S4&#39;,&#39;S5&#39;,&#39;S6&#39;,&#39;S7&#39;], &#39;age&#39; : [20,19,21,22,24,25,26], &#39;score&#39; : [90,95,75,80,70,85,90]} . df=pd.DataFrame(data) df . class name age score . 0 A | S1 | 20 | 90 | . 1 B | S2 | 19 | 95 | . 2 C | S3 | 21 | 75 | . 3 A | S4 | 22 | 80 | . 4 B | S5 | 24 | 70 | . 5 C | S6 | 25 | 85 | . 6 C | S7 | 26 | 90 | . df[&#39;score&#39;]&gt;=80 . 0 True 1 True 2 False 3 True 4 False 5 True 6 True Name: score, dtype: bool . df.loc[df[&#39;score&#39;]&gt;=80] . class name age score . 0 A | S1 | 20 | 90 | . 1 B | S2 | 19 | 95 | . 3 A | S4 | 22 | 80 | . 5 C | S6 | 25 | 85 | . 6 C | S7 | 26 | 90 | . df.loc[df[&#39;score&#39;]&gt;=80,[&#39;name&#39;,&#39;age&#39;]] . name age . 0 S1 | 20 | . 1 S2 | 19 | . 3 S4 | 22 | . 5 S6 | 25 | . 6 S7 | 26 | . df[df[&#39;score&#39;]&gt;=80] . class name age score . 0 A | S1 | 20 | 90 | . 1 B | S2 | 19 | 95 | . 3 A | S4 | 22 | 80 | . 5 C | S6 | 25 | 85 | . 6 C | S7 | 26 | 90 | . df[&#39;result&#39;]=&#39;NONE&#39; . df . class name age score result . 0 A | S1 | 20 | 90 | NONE | . 1 B | S2 | 19 | 95 | NONE | . 2 C | S3 | 21 | 75 | NONE | . 3 A | S4 | 22 | 80 | NONE | . 4 B | S5 | 24 | 70 | NONE | . 5 C | S6 | 25 | 85 | NONE | . 6 C | S7 | 26 | 90 | NONE | . df.loc[df[&#39;score&#39;]&gt;=80,&#39;result&#39;]=&#39;PASS&#39; . df.loc[df[&#39;score&#39;]&lt;80,&#39;result&#39;]=&#39;FAIL&#39; . df . class name age score result . 0 A | S1 | 20 | 90 | PASS | . 1 B | S2 | 19 | 95 | PASS | . 2 C | S3 | 21 | 75 | FAIL | . 3 A | S4 | 22 | 80 | PASS | . 4 B | S5 | 24 | 70 | FAIL | . 5 C | S6 | 25 | 85 | PASS | . 6 C | S7 | 26 | 90 | PASS | . idx = df[&#39;result&#39;] == &#39;PASS&#39; . df.loc[idx] . class name age score result . 0 A | S1 | 20 | 90 | PASS | . 1 B | S2 | 19 | 95 | PASS | . 3 A | S4 | 22 | 80 | PASS | . 5 C | S6 | 25 | 85 | PASS | . 6 C | S7 | 26 | 90 | PASS | . df_sorted=df.loc[idx].sort_values(&#39;score&#39;,ascending=False) . df_sorted . class name age score result . 1 B | S2 | 19 | 95 | PASS | . 0 A | S1 | 20 | 90 | PASS | . 6 C | S7 | 26 | 90 | PASS | . 5 C | S6 | 25 | 85 | PASS | . 3 A | S4 | 22 | 80 | PASS | . excel 파일 만들고 불러오기 . df_sorted.to_excel(&#39;data_sorted.xlsx&#39;,index=False) . df_import=pd.read_excel(&#39;data_sorted.xlsx&#39;) . df_import . class name age score result . 0 B | S2 | 19 | 95 | PASS | . 1 A | S1 | 20 | 90 | PASS | . 2 C | S7 | 26 | 90 | PASS | . 3 C | S6 | 25 | 85 | PASS | . 4 A | S4 | 22 | 80 | PASS | . grouping . df.groupby(by=&#39;class&#39;).mean() . age score . class . A 21.0 | 85.000000 | . B 21.5 | 82.500000 | . C 24.0 | 83.333333 | . df.groupby(by=&#39;class&#39;).std() . age score . class . A 1.414214 | 7.071068 | . B 3.535534 | 17.677670 | . C 2.645751 | 7.637626 | . plotting . df.plot.bar(&#39;name&#39;,&#39;score&#39;) . &lt;AxesSubplot:xlabel=&#39;name&#39;&gt; . null&#52376;&#47532;&#54644;&#48372;&#51088; . df.loc[[0,2],&#39;score&#39;]=np.NaN . df . class name age score result . 0 A | S1 | 20 | NaN | PASS | . 1 B | S2 | 19 | 95.0 | PASS | . 2 C | S3 | 21 | NaN | FAIL | . 3 A | S4 | 22 | 80.0 | PASS | . 4 B | S5 | 24 | 70.0 | FAIL | . 5 C | S6 | 25 | 85.0 | PASS | . 6 C | S7 | 26 | 90.0 | PASS | . NaN이 들어간 곳을 알려줌 . df.isnull() . class name age score result . 0 False | False | False | True | False | . 1 False | False | False | False | False | . 2 False | False | False | True | False | . 3 False | False | False | False | False | . 4 False | False | False | False | False | . 5 False | False | False | False | False | . 6 False | False | False | False | False | . df.dropna()#데이터 없는 행은 다 날림 . class name age score result . 1 B | S2 | 19 | 95.0 | PASS | . 3 A | S4 | 22 | 80.0 | PASS | . 4 B | S5 | 24 | 70.0 | FAIL | . 5 C | S6 | 25 | 85.0 | PASS | . 6 C | S7 | 26 | 90.0 | PASS | . value=0 df.fillna(value) ## NaN값만 value로 채워줌 . class name age score result . 0 A | S1 | 20 | 0.0 | PASS | . 1 B | S2 | 19 | 95.0 | PASS | . 2 C | S3 | 21 | 0.0 | FAIL | . 3 A | S4 | 22 | 80.0 | PASS | . 4 B | S5 | 24 | 70.0 | FAIL | . 5 C | S6 | 25 | 85.0 | PASS | . 6 C | S7 | 26 | 90.0 | PASS | . df.replace(np.nan,value) . class name age score result . 0 A | S1 | 20 | 0.0 | PASS | . 1 B | S2 | 19 | 95.0 | PASS | . 2 C | S3 | 21 | 0.0 | FAIL | . 3 A | S4 | 22 | 80.0 | PASS | . 4 B | S5 | 24 | 70.0 | FAIL | . 5 C | S6 | 25 | 85.0 | PASS | . 6 C | S7 | 26 | 90.0 | PASS | . df.interpolate() . class name age score result . 0 A | S1 | 20 | NaN | PASS | . 1 B | S2 | 19 | 95.0 | PASS | . 2 C | S3 | 21 | 87.5 | FAIL | . 3 A | S4 | 22 | 80.0 | PASS | . 4 B | S5 | 24 | 70.0 | FAIL | . 5 C | S6 | 25 | 85.0 | PASS | . 6 C | S7 | 26 | 90.0 | PASS | . 이렇게 위 아래 값의 평균으로 채워주기도 하는데 위아래 둘다 있는 경우에만 사용가능하다 . def add_one(x): return x+1 . add_one(1001) . 1002 . df[&#39;age&#39;]=df[&#39;age&#39;].apply(add_one) . df . class name age score result . 0 A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | . 이렇게 df의 age를 변경해줄 수 있음 . df[&#39;score&#39;].apply(np.square) . 0 NaN 1 9025.0 2 NaN 3 6400.0 4 4900.0 5 7225.0 6 8100.0 Name: score, dtype: float64 . 이런 np.square도 사용가능 . . df.filter(regex=&#39;[rn]&#39;) # nr이 들어간 columns 추출 . name score result . 0 S1 | NaN | PASS | . 1 S2 | 95.0 | PASS | . 2 S3 | NaN | FAIL | . 3 S4 | 80.0 | PASS | . 4 S5 | 70.0 | FAIL | . 5 S6 | 85.0 | PASS | . 6 S7 | 90.0 | PASS | . df_vertical=pd.concat([df,df]) df_vertical . class name age score result . 0 A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | . 0 A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | . df_horizontal=pd.concat([df,df],axis=1) df_horizontal . class name age score result class name age score result . 0 A | S1 | 21 | NaN | PASS | A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | C | S7 | 27 | 90.0 | PASS | . . df.to_csv(&#39;data_text.txt&#39;,sep=&#39; t&#39;,index=False) # txt파일로 변환할 때 어떻게 구분해서 타이핑해넣을 것인가 # =sep로 !,여기선 지금 탭으로 구분지었음 . pd.read_csv(&#39;data_text.txt&#39;,delimiter=&#39; t&#39;) . class name age score result . 0 A | S1 | 21 | NaN | PASS | . 1 B | S2 | 20 | 95.0 | PASS | . 2 C | S3 | 22 | NaN | FAIL | . 3 A | S4 | 23 | 80.0 | PASS | . 4 B | S5 | 25 | 70.0 | FAIL | . 5 C | S6 | 26 | 85.0 | PASS | . 6 C | S7 | 27 | 90.0 | PASS | . delimiter로 txt파일이 어떻게 이루어져 있나 알려줘야함 . . from sympy import symbols . x=symbols(&#39;x&#39;) . type(x) . sympy.core.symbol.Symbol . 2*x . $ displaystyle 2 x$ 즉 x자체가 symbol로 들어갔음 . expr=2*x . expr.subs(x,3) . $ displaystyle 6$ 미분해보자 . f=x**3 . from sympy import diff . df1=diff(f,x) . df1 . $ displaystyle 3 x^{2}$ df2=diff(df1,x) . df2 . $ displaystyle 6 x$ . from sympy import sin . f=sin(x) . df1=diff(f,x) . df1 . $ displaystyle cos{ left(x right)}$ . from sympy import integrate . integrate(f,(x,0,2*3.14)) . $ displaystyle 5.07308662478501 cdot 10^{-6}$ 0에 가깝게 나옴 . integrate(f,(x,0,3.14)) . $ displaystyle 1.99999873172754$ . from sympy import limit . limit(sin(x)/x,x,0) . $ displaystyle 1$ . !pip install scipy . Requirement already satisfied: scipy in c: users ehfus anaconda3 envs dv2021 lib site-packages (1.7.1) Requirement already satisfied: numpy&lt;1.23.0,&gt;=1.16.5 in c: users ehfus anaconda3 envs dv2021 lib site-packages (from scipy) (1.21.4) . import matplotlib.pyplot as plt from scipy import interpolate . x=np.array([1,2,3,4,5]) y=np.array([1,0.8,0.4,0.3,0.2]) . plt.plot(x,y,&#39;*&#39;) . [&lt;matplotlib.lines.Line2D at 0x27a654355e0&gt;] . f_lin=interpolate.interp1d(x,y) . x_new = np.arange(1,5,0.1) . y_new = f_lin(x_new) . fig,ax=plt.subplots() ax.plot(x,y,&#39;o&#39;,label=&#39;Data&#39;) ax.plot(x_new,y_new,label=&#39;linear&#39;) ax.legend() . &lt;matplotlib.legend.Legend at 0x27a655d0a60&gt; . 선형 보간됨을 알 수 있다. . . tck=interpolate.splrep(x,y,s=0) y_spl=interpolate.splev(x_new,tck,der=0) fig,ax=plt.subplots() ax.plot(x,y,&#39;o&#39;,label=&#39;Data&#39;) ax.plot(x_new,y_new,label=&#39;linear&#39;) ax.plot(x_new,y_spl,label=&#39;spline&#39;) ax.legend() . &lt;matplotlib.legend.Legend at 0x27a7588db50&gt; . 원형 보간 추가 . . open cv . import cv2 as cv . im=cv.imread(&#39;KakaoTalk_20211210_090822964.png&#39;) . im.shape . (1080, 1920, 3) . type(im) . numpy.ndarray . BGR &#54540;&#46991; . plt.figure() plt.imshow(im) plt.title(&#39;Original&#39;) . Text(0.5, 1.0, &#39;Original&#39;) . BGR로 들어오기 때문에 RGB로 바꿔 줄 필요가 있음 . rgb=cv.cvtColor(im,cv.COLOR_BGR2RGB) plt.figure() plt.imshow(rgb) plt.title(&#39;RGB&#39;) . Text(0.5, 1.0, &#39;RGB&#39;) . GRAY=cv.cvtColor(im,cv.COLOR_BGR2GRAY) plt.figure() plt.imshow(GRAY,cmap=&#39;gray&#39;) plt.title(&#39;GRAY&#39;) . Text(0.5, 1.0, &#39;GRAY&#39;) . cmap=gray 처리 꼭 해줘야 함 | . blur=cv.blur(im,(100,100)) blur=cv.cvtColor(blur,cv.COLOR_BGR2RGB) plt.subplot(121) # 가로줄 한개, 세로줄 두개, 첫번째에 놓겠다 plt.imshow(rgb) plt.title(&#39;RGB&#39;) plt.subplot(122) # 가로줄 한개, 세로줄 두개, 두번째에 놓겠다 plt.imshow(blur) plt.title(&#39;blur&#39;) . Text(0.5, 1.0, &#39;blur&#39;) . . . edges=cv.Canny(GRAY,0,100) plt.subplot(121) # 가로줄 한개, 세로줄 두개, 첫번째에 놓겠다 plt.imshow(GRAY,cmap=&#39;gray&#39;) plt.title(&#39;GRAY&#39;) plt.subplot(122) # 가로줄 한개, 세로줄 두개, 두번째에 놓겠다 plt.imshow(edges) plt.title(&#39;edge detection&#39;) . Text(0.5, 1.0, &#39;edge detection&#39;) . 머신러닝과 연관하여 비디오 영상의 움직이는 사물을 찾거나 번호판 또는 숫자 인식 여러 분야에서 활용이 가능하다 . .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/26/intro.html",
            "relUrl": "/2021/12/26/intro.html",
            "date": " • Dec 26, 2021"
        }
        
    
  
    
        ,"post5": {
            "title": "2021/12/25/SAT",
            "content": "import numpy as np . a=np.array([100.,101.,102.,103.]) . a.shape # 1차원 4개 요소 . (4,) . a.ndim . 1 . a[0] . 100.0 . a[1] . 101.0 . a[-1] . 103.0 . a[[1,3]] . array([101., 103.]) . a[-3:-1] . array([101., 102.]) . a[1:4:1] . array([101., 102., 103.]) . a[1:4] . array([101., 102., 103.]) . a[1:4:2] . array([101., 103.]) . a[:] . array([100., 101., 102., 103.]) . a[::2] . array([100., 102.]) . a[::-2] . array([103., 101.]) . a2=np.array([[11,12],[23 ,34]]) . a2.shape . (2, 2) . a2.ndim . 2 . a2[0][1] # 겉차원 -&gt; 속차원 . 12 . a2[0,1] . 12 . a2[:] . array([[11, 12], [23, 34]]) . a2[:,:] . array([[11, 12], [23, 34]]) . a2[0,:] . array([11, 12]) . a2[1,:] . array([23, 34]) . b=a2[:,0] . b . array([11, 23]) . b.shape . (2,) . b.ndim . 1 . b_=b[:,np.newaxis] . b_ . array([[11], [23]]) . b_.shape . (2, 1) . b.ndim . 1 . 또는 . b.shape=(1,2) . b . array([[11, 23]]) . a3=np.array([[[ 1,2],[3,4 ],[5,6 ],[7,8 ],[9,10]]]) . a3 . array([[[ 1, 2], [ 3, 4], [ 5, 6], [ 7, 8], [ 9, 10]]]) . a3.shape # 큰 덩어리 1개, 작은 덩어리 5개, 그 안에 요소 2개씩 . (1, 5, 2) . a3.ndim #3차원 . 3 . a3[0,1,1] . 4 . # 큰 덩어리는 하나임 # a3[1] . x=np.array([12,34,14]) . idx=np.where(x==34) . idx # 0번째 아니고 1번째 있다 . (array([1], dtype=int64),) . x[idx] . array([34]) . idx=(x==14) . idx . array([False, False, True]) . x[idx] . array([14]) . x[np.where(x==12)] . array([12]) . x[np.nonzero(x==34)] . array([34]) . image processing시, 논리연산을 통한 idexing 중요 . 대충 적용해보자 . image=np.array([[255,0,255], [255,0,255], [255,0,255]]) . image.shape # 2차원, 큰덩어리 세개, 그 안에 요소 3개 . (3, 3) . idx=np.where(image==255) . image[idx]=0 . image . array([[0, 0, 0], [0, 0, 0], [0, 0, 0]]) . 이런식으로 논리연산을 통한 indexing으로 다 검정색을 만들어버림 . . a=np.array([[10,20],[30,40]]) b=np.array([[1,2],[3,4]]) . a * b . array([[ 10, 40], [ 90, 160]]) . a @ b #행렬 연산 . array([[ 70, 100], [150, 220]]) . a.dot(b) #행렬 연산 . array([[ 70, 100], [150, 220]]) . a=np.zeros((3,3)) . b=np.ones((3,3)) . c=np.trace(a) . $x@a=y$ 에서 a행렬 구해보기 . x=np.array([[1,-3],[2,4]]) y=np.array([[1],[3]]) . x_inverse=np.linalg.inv(x) . a=x_inverse@y . a . array([[1.3], [0.1]]) . 혹은 . a=np.linalg.solve(x,y) . a . array([[1.3], [0.1]]) . 이렇게도 해결 가능하다 . 그 외에도 고유벡터, 고유값, 특이값 분해도 np에서 함수사용할 수 있다 . a=np.zeros((5,5)) np.fill_diagonal(a,12) . a#대각원소만 12로 변경 . array([[12., 0., 0., 0., 0.], [ 0., 12., 0., 0., 0.], [ 0., 0., 12., 0., 0.], [ 0., 0., 0., 12., 0.], [ 0., 0., 0., 0., 12.]]) . a=np.array([[1,2,3],[3,4,4],[5,43,6]]) . b=np.array([[1],[2],[3]]) . b=b.repeat(3,axis=1) . b . array([[1, 1, 1], [2, 2, 2], [3, 3, 3]]) . 이제 원소대 원소 곱해주면 된다 | . c=a*b . c . array([[ 1, 2, 3], [ 6, 8, 8], [ 15, 129, 18]]) . broadcasting :size알아서 처리해주는 기능 . a . array([[ 1, 2, 3], [ 3, 4, 4], [ 5, 43, 6]]) . b=np.array([[1],[2],[3]]) . a*b . array([[ 1, 2, 3], [ 6, 8, 8], [ 15, 129, 18]]) . 또는 . def f(x,y): return x*y . b=np.fromfunction(f,(5,4),dtype=int) . b #이건 그냥 임의의 행렬만 만들어준 것 . array([[ 0, 0, 0, 0], [ 0, 1, 2, 3], [ 0, 2, 4, 6], [ 0, 3, 6, 9], [ 0, 4, 8, 12]]) . . a=np.array([10,20,30,40,50]) b=np.array([30,50]) . np.setdiff1d(a,b) . array([10, 20, 40]) . . a=np.random.randint(100) . a# 0부터99까지에서 하나 random으로 get . 2 . . import matplotlib.pyplot as plt %matplotlib inline . y=np.array([10,20,30]) . plt.plot(y) . [&lt;matplotlib.lines.Line2D at 0x1d56dcc9f40&gt;] . x=np.array([123,413,555]) . plt.plot(x,y,&#39;r--.&#39;) #data가 들어간 곳에 dot으로 표시 . [&lt;matplotlib.lines.Line2D at 0x1d56dfbc370&gt;] . plt.plot(x,y,&#39;b-o&#39;,label=&#39;fuck&#39;) plt.ylabel(&#39;sd&#39;) plt.xlabel(&#39;SD&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x1d56f28e1c0&gt; . hf=plt.figure() # 도화지 ha = hf.add_axes([0,0,1,1]) ha.plot(x,y) . [&lt;matplotlib.lines.Line2D at 0x1d56f3b10d0&gt;] . aa,bb=plt.subplots() hong,=bb.plot(x,y) # 이렇게 aa,bb는 임의로 지명 가능 . 위에 있는 그래프를 update해보자 . a_new=np.array([200,331,335]) b_new=np.array([10,50,10]) hong.set_data(a_new,b_new) aa . 그런데 주의해야 할 점에 애초에 aa라는 도화지에 정해진 축이 있기 때문에 그 축에서 너무 멀어지는 값들을 넣어주면 aa라는 도화지에 보이지 않을 수 있음 . PLUS=1.5 a_new=np.array([200,331,335]) b_new=np.array([10,50,10]) hong.set_data(a_new,PLUS*b_new) aa . 그래프가 올라간 것을 확인할 수 있음 . a=np.linspace(0,2,100) y1=0.5*a y2=0.5*a**2 y3=0.5*a**3 plt.plot(a,y1,label=&#39;1D&#39;) plt.plot(a,y2,label=&#39;2D&#39;) plt.plot(a,y3,label=&#39;3D&#39;) plt.legend() plt.xlabel(&#39;X&#39;) plt.ylabel(&#39;Y&#39;) plt.title(&#39;GRAPH&#39;) . Text(0.5, 1.0, &#39;GRAPH&#39;) . fig,ax=plt.subplots() ax1,=ax.plot(a,y1) # 여기서 ax1 후에 comma입력해주는 이유가 속성을 나중에 다 받아오기 위해서 ax2,=ax.plot(a,y2) ax3,=ax.plot(a,y3) ax.set_xlabel(&#39;X&#39;) # plt가 아닐 땐 set을 입력해줘야 함 ax.set_ylabel(&#39;Y&#39;) ax1.set_label(&#39;1&#39;) ax2.set_label(&#39;2&#39;) ax3.set_label(&#39;3&#39;) ax.legend() . &lt;matplotlib.legend.Legend at 0x1d570be0d90&gt; . ax1.set_color(&#39;k&#39;) ax2.set_color(&#39;b&#39;) ax3.set_color(&#39;r&#39;) ax.grid() ax.legend() fig . decay sin . t=np.linspace(0,100,1000) tau= 60 y=np.sin(t)*np.exp(-t/tau) plt.plot(t,y,label=&#39;Decay Oscillating Response&#39;) plt.ylabel(&#39;y[m]&#39;) plt.xlabel(&#39;t[s]&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x1d571e860d0&gt; . t가 커질수록 진폭이 천천히 줄어들게 됨 . Euler eq . t=np.linspace(0,1,100) f= 1 # 주파수 y_euler=np.exp(1j*2*np.pi**f*t) y_cos = np.real(y_euler) y_sin=np.imag(y_euler) fig,ax=plt.subplots() ax.plot(t,y_cos,&#39;-r&#39;,label=&#39;cos&#39;) ax.plot(t,y_sin,&#39;--b&#39;,label=&#39;sin&#39;) ax.grid() ax.legend() . &lt;matplotlib.legend.Legend at 0x1d5720b8640&gt; . fig,ax=plt.subplots(2,) ax[0].plot(t,y_cos,&#39;-r&#39;,label=&#39;cos&#39;) ax[1].plot(t,y_sin,&#39;--b&#39;,label=&#39;sin&#39;) ax[0].grid() ax[0].legend() ax[1].grid() ax[1].legend() . &lt;matplotlib.legend.Legend at 0x1d572190dc0&gt; . Histogram . data=np.random.randn(500000) plt.hist(data,100,density=True) # 100개의 막대로 나누겠다, 확률밀도함수로 그리겠다 x=np.linspace(-4,4,100) sigma=1 mean=0 nd=(1/(sigma*np.sqrt(2*np.pi)))*np.exp(-0.5*((x-mean)/sigma)**2) plt.plot(x,nd,&#39;r&#39;,label=&#39;Std Normal Dist&#39;) plt.ylabel(&#39;PSD&#39;) plt.xlabel(&#39;X&#39;) plt.legend() . &lt;matplotlib.legend.Legend at 0x1d572746820&gt; . 3D plot . x=np.linspace(0,2*np.pi,10) y=np.linspace(0,2*np.pi,10) grid_x,grid_y=np.meshgrid(x,y) # 1차원 array를 통해 2차원 grid를 만들어줌 z=np.sin(grid_x)*np.sin(grid_y) fig=plt.figure() ax=fig.gca(projection=&#39;3d&#39;) # Get Current Axis=gca ax.plot_surface(grid_x,grid_y,z,cmap=&#39;jet&#39;) ax.set_xlabel(&#39;x&#39;) ax.set_ylabel(&#39;y&#39;) ax.set_zlabel(&#39;z&#39;) . C: Users ehfus AppData Local Temp/ipykernel_7852/1177705184.py:6: MatplotlibDeprecationWarning: Calling gca() with keyword arguments was deprecated in Matplotlib 3.4. Starting two minor releases later, gca() will take no keyword arguments. The gca() function should only be used to get the current axes, or if no axes exist, create new axes with default keyword arguments. To create a new axes with non-default arguments, use plt.axes() or plt.subplot(). ax=fig.gca(projection=&#39;3d&#39;) # Get Current Axis=gca . Text(0.5, 0, &#39;z&#39;) . Animation . # x=np.array([1,2,3,4,5]) # y=np.array([1,1,1,1,1]) # ax1, = ax.plot(x,y) # ax.set_ybound([0,11]) # for i in range(0,11,1): # ax1.set_ydata(i*y) # plt.pause(0.3) # # 원래는 animation기능으로 움직여야 함 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/25/intro.html",
            "relUrl": "/2021/12/25/intro.html",
            "date": " • Dec 25, 2021"
        }
        
    
  
    
        ,"post6": {
            "title": "2022/12/24/FRI",
            "content": "import numpy as np . np.linspace(0,4,5) . array([0., 1., 2., 3., 4.]) . np.arange(10) # 0부터 10개의 숫자 . array([0, 1, 2, 3, 4, 5, 6, 7, 8, 9]) . a=np.array([10,20,3]) . a.shape # array의 shape을 알려줌 # 1차원 행렬에 방 세개 . (3,) . a.ndim #1차원 . 1 . a.dtype #array에 들어간 숫자들이 어떤 형식으로? . dtype(&#39;int32&#39;) . a.itemsize # 4byte 32=4*8 . 4 . a.size #몇개 들어가 있니 . 3 . type(a) #몇차원이고 될 수 있음, nd=ndimension . numpy.ndarray . np.array도 sequence 타입 =&gt; index,slicing가능 | . a[2] . 3 . a[2]=30.8 . a . array([10, 20, 30]) . 소수점 날라가고 30으로 저장됨 . a.dtype . dtype(&#39;int32&#39;) . a=a.astype(&#39;float64&#39;) . a[2]=30.865 . a . array([10. , 20. , 30.865]) . a.dtype . dtype(&#39;float64&#39;) . 소수점도 가능한 자료형으로 변경해줬음 | . b=np.array([10.,20.,30.]) . b.dtype . dtype(&#39;float64&#39;) . 애초에 이렇게 dot을 지정해주고 들어가면 float으로 활용가능 . c=np.array([10.2,20.3,50.58],&#39;int32&#39;) . c . array([10, 20, 50]) . 이렇게 &#39;int32&#39;로 지정해줄 수 있음 . x=np.array([7,9,11]) y=x/2 . y . array([3.5, 4.5, 5.5]) . x.dtype . dtype(&#39;int32&#39;) . y.dtype . dtype(&#39;float64&#39;) . x가 정수로 시작했어도 y는 divide를 사용하고 있기에 알아서 np에서 float64로 지정함 . int32 $vs$ int64 . x=np.array([0]) . x[0]=2147483647 . x . array([2147483647]) . x[0]=x[0]+1 . C: Users ehfus AppData Local Temp/ipykernel_11512/4237261130.py:1: RuntimeWarning: overflow encountered in long_scalars x[0]=x[0]+1 . 2147483647은 int32에서 수용할 수 있는 최대의 숫자임, 따라서 여기서 1만 더해주더라도 수용하지 못하게 됨 . x=np.array([0],&#39;int64&#39;) . x[0]=2147483647 . x[0]+1 . 2147483648 . dtype을 int64로 바꿨기 때문에 int32에서 최대였던 것보다 더 수용할 수 있게 됨 . a=np.array([10,&#39;abc&#39;,20]) # 꼭 list형태로 줘야 함 . a.dtype #섞여있음 . dtype(&#39;&lt;U11&#39;) . a*2 . UFuncTypeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11512/434652760.py in &lt;module&gt; -&gt; 1 a*2 UFuncTypeError: ufunc &#39;multiply&#39; did not contain a loop with signature matching types (dtype(&#39;&lt;U11&#39;), dtype(&#39;int32&#39;)) -&gt; None . 섞여있으면 이런 연산은 불가 . a=np.array([[10,20,30],[40,50,60]]) . a # 2차원 . array([[10, 20, 30], [40, 50, 60]]) . a.shape # 2x3행렬로 해석해도 될듯 . (2, 3) . a.itemsize . 4 . a.size . 6 . a=np.array([[10,20,30],[40,50,60],[5,6,8]]) . a . array([[10, 20, 30], [40, 50, 60], [ 5, 6, 8]]) . a.size . 9 . a=np.array([[10,20,30], [40,50,60], [55,54,88] ,[112,123,41]]) . a . array([[ 10, 20, 30], [ 40, 50, 60], [ 55, 54, 88], [112, 123, 41]]) . a.ndim . 2 . a.shape . (4, 3) . a=np.array([10+10j,10+60j]) . a . array([10.+10.j, 10.+60.j]) . a=np.array([10,20],&#39;complex&#39;) . a . array([10.+0.j, 20.+0.j]) . . a=np.array([10,20]) . b=np.matrix([10,20]) . a.ndim . 1 . b.ndim . 2 . b=np.matrix([[[10]]]) . ValueError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11512/2972594669.py in &lt;module&gt; -&gt; 1 b=np.matrix([[[10]]]) ~ Anaconda3 envs dv2021 lib site-packages numpy matrixlib defmatrix.py in __new__(subtype, data, dtype, copy) 147 shape = arr.shape 148 if (ndim &gt; 2): --&gt; 149 raise ValueError(&#34;matrix must be 2-dimensional&#34;) 150 elif ndim == 0: 151 shape = (1, 1) ValueError: matrix must be 2-dimensional . 2차원을 넘어간 3차원이기에 불가능 . a=np.array([10,20,30]) . a=np.insert(a,2,5) # a라는 np.array의 2번째 인덱스에 5를 넣어라 . a . array([ 5, 10, 5, 5, 20, 30]) . a=np.delete(a,5) . a # 다섯번째 인덱스 삭제 . array([ 5, 10, 5, 5, 20]) . a=np.array([1,2,3]) . a=np.arange(3) . a # 0부터 시작해서 숫자 3개를 채워줌 . array([0, 1, 2]) . a=np.zeros((2,3)) . a . array([[0., 0., 0.], [0., 0., 0.]]) . a=np.ones((2,3)) . a . array([[1., 1., 1.], [1., 1., 1.]]) . a=np.linspace(0,5,4) #0부터 5까지 4개로 . a . array([0. , 1.66666667, 3.33333333, 5. ]) . a=np.linspace(0,5,6) #0부터 5까지 6개로 . a . array([0., 1., 2., 3., 4., 5.]) . a=np.logspace(0,5,4) # log scale로! . a . array([1.00000000e+00, 4.64158883e+01, 2.15443469e+03, 1.00000000e+05]) . . a=np.array([10,20,30]) b=np.array([1,2,3]) . a+b . array([11, 22, 33]) . a-b . array([ 9, 18, 27]) . b-a . array([ -9, -18, -27]) . a*b . array([10, 40, 90]) . a/b . array([10., 10., 10.]) . c=a**2 . c . array([100, 400, 900], dtype=int32) . idx=a&lt;20 . idx . array([ True, True, True]) . type(idx) . numpy.ndarray . a=a+1 . a . array([2, 3, 4]) . a+=1 . a . array([3, 4, 5]) . a*=2 . a . array([ 6, 8, 10]) . a=a*2 . a . array([12, 16, 20]) . a=np.array([10,50,9]) # int b=np.array([50.,5.,8.]) #float . a+=b . UFuncTypeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_11512/953131135.py in &lt;module&gt; -&gt; 1 a+=b UFuncTypeError: Cannot cast ufunc &#39;add&#39; output from dtype(&#39;float64&#39;) to dtype(&#39;int32&#39;) with casting rule &#39;same_kind&#39; . a에b를 더해서 a를 업데이트 하는 건 자료형이 달라서 안 된다고 함 . 되게 하려면 자료형을 맞춰주면 됨 . c=a+b # 이건 됨 . c . array([60., 55., 17.]) . . a=np.array([10,50,9]) b=np.array([50,5,8]) . np.add(a,b) . array([60, 55, 17]) . np.subtract(a,b) . array([-40, 45, 1]) . np.divide(a,b) . array([ 0.2 , 10. , 1.125]) . np.multiply(a,b) . array([500, 250, 72]) . np.divmod(a,b) # 몫과 나머지 . (array([ 0, 10, 1], dtype=int32), array([10, 0, 1], dtype=int32)) . np.exp(b) . array([5.18470553e+21, 1.48413159e+02, 2.98095799e+03]) . np.sqrt(a) . array([3.16227766, 7.07106781, 3. ]) . . a=np.array([10,20,3]) . np.mean(a) . 11.0 . a.mean() . 11.0 . np.average(a) . 11.0 . np.average(a,weights=[1,1,1]) . 11.0 . np.average(a,weights=[1,1,0]) . 15.0 . np.average(a,weights=[0,1,1]) . 11.5 . np.median(a) . 10.0 . np.cumsum(a) # 앞에 있는 숫자들을 더해주는 것 . array([10, 30, 33], dtype=int32) . np.cov(a) . array(73.) . np.std(a) . 6.97614984548545 . np.var(a) . 48.666666666666664 . x=np.array([10,20,30]) . x.sum() . 60 . x=np.array([10.,40.,20.,5.,15.]) . x.min() . 10.0 . x.max() . 50.0 . x.argmin() # index 0에 최솟값이 존재함 . 0 . x_min,x_min_idx=x.min(),x.argmin() . # 최솟값과 최댓값의 차이 x.ptp() . 40.0 . y=np.sort(x) . y . array([ 5., 10., 15., 20., 40.]) . idx = np.argsort(x) . idx . array([3, 0, 4, 2, 1], dtype=int64) . y . array([ 5., 10., 15., 20., 40.]) . sort된 값들이 원래 어디에 위치해 있었는지 . x[idx] . array([ 5., 10., 15., 20., 40.]) . y=x[idx] . y . array([ 5., 10., 15., 20., 40.]) . a=np.array([20,10,30]) b=np.array([-5,25]) . np.searchsorted(a,b) . array([0, 2], dtype=int64) . b를 a에 넣을 때 어느 자리에 넣어야 sorting이 유지가 되는지? | . d=np.arange(1,7,1) . d . array([1, 2, 3, 4, 5, 6]) . d.shape . (6,) . d.reshape(2,3) . array([[1, 2, 3], [4, 5, 6]]) . d 자체를 바꿔주는 건 아님 | . e=d.reshape(2,3) . f=np.linspace(1,10,10) . f . array([ 1., 2., 3., 4., 5., 6., 7., 8., 9., 10.]) . g=np.linspace(1,10,10).reshape(2,5) . g . array([[ 1., 2., 3., 4., 5.], [ 6., 7., 8., 9., 10.]]) . a=np.array([[1,2],[3,4]])#2차원 . a . array([[1, 2], [3, 4]]) . np.repeat(a,2) . array([1, 1, 2, 2, 3, 3, 4, 4]) . np.repeat(a,2,axis=0) . array([[1, 2], [1, 2], [3, 4], [3, 4]]) . np.repeat(a,2,axis=1) . array([[1, 1, 2, 2], [3, 3, 4, 4]]) . np.repeat(a,[1,2],axis=0) . array([[1, 2], [3, 4], [3, 4]]) . np.repeat(a,[3,1],axis=0) . array([[1, 2], [1, 2], [1, 2], [3, 4]]) . np.repeat(a,[1,2],axis=1) . array([[1, 2, 2], [3, 4, 4]]) . np.repeat(a,[3,1],axis=1) . array([[1, 1, 1, 2], [3, 3, 3, 4]]) . a=np.array([[1],[2],[3]]) b=np.array([[4],[5],[6]]) . a.shape . (3, 1) . b.shape . (3, 1) . np.concatenate((a,b),axis=0) # array 두개 연결 . array([[1], [2], [3], [4], [5], [6]]) . np.concatenate((a,b),axis=1) . array([[1, 4], [2, 5], [3, 6]]) . (a,b)이렇게 tuple 형태로 입력해줘야 함 | . a=np.array([10,20,30]) b=np.array([40,50,60]) . np.vstack((a,b)) . array([[10, 20, 30], [40, 50, 60]]) . np.hstack((a,b)) . array([10, 20, 30, 40, 50, 60]) . a=np.array([[10,20,30],[40,50,60]]) . a . array([[10, 20, 30], [40, 50, 60]]) . # 오류 발생, 왜? 세로 방향으로 2개로 나눌 수가 없어서 . a=np.hsplit(a,3) . a . [array([[10], [40]]), array([[20], [50]]), array([[30], [60]])] . a.shape . AttributeError Traceback (most recent call last) ~ AppData Local Temp/ipykernel_2492/1739083353.py in &lt;module&gt; -&gt; 1 a.shape AttributeError: &#39;list&#39; object has no attribute &#39;shape&#39; . 보다시피 list안에 np.array가 들어갔음 . a[0] . array([[10], [40]]) . a=np.array([[10,20,30],[40,50,60]]) . np.vsplit(a,2) . [array([[10, 20, 30]]), array([[40, 50, 60]])] . 이것또한 list로 저장 됨 . 어레이를 조각조각내서 리스트 안에 넣어줬기 때문에 . 그 조각을 살펴보면 np.array 형태이고 . 그 조각들을 list안에 넣어준 것 . a=np.array([[10,20,30],[40,50,60]]) . a . array([[10, 20, 30], [40, 50, 60]]) . a.transpose() . array([[10, 40], [20, 50], [30, 60]]) . 2차원의 array를 1차원의 array로 변경 . a . array([[10, 20, 30], [40, 50, 60]]) . a.ravel() . array([10, 20, 30, 40, 50, 60]) . a.reshape(-1) . array([10, 20, 30, 40, 50, 60]) . a.ravel(order=&#39;C&#39;) . array([10, 20, 30, 40, 50, 60]) . a.ravel(order=&#39;F&#39;) . array([10, 40, 20, 50, 30, 60]) . a.flatten() . array([10, 20, 30, 40, 50, 60]) . a=np.array([[1,2,3]]) # 2차원 형태로 넣어줌 . a_=np.array([1,2,3]) # 1차원 형태로 넣어줌 . &#52264;&#51060;&#51216; . a_[0] . 1 . a[0][0] . 1 . . a.ndim . 2 . a.shape . (1, 3) . 2차원에서 1차원으로 줄이자 . b=a.squeeze() . b . array([1, 2, 3]) . b.ndim . 1 . b.shape . (3,) . a=np.array([[[1,2]],[[3,4]],[[5,6]]]) . a . array([[[1, 2]], [[3, 4]], [[5, 6]]]) . a.shape . (3, 1, 2) . a.ndim . 3 . b=a.squeeze() . b . array([[1, 2], [3, 4], [5, 6]]) . b.shape . (3, 2) . a=np.array([1,2,3]) b=np.array([4,5,6]) . a.shape . (3,) . a_=a[:,np.newaxis] b_=b[:,np.newaxis] # 차원 하나 추가 . a_.shape . (3, 1) . np.concatenate((a_,b_),axis=0) . array([[1], [2], [3], [4], [5], [6]]) . np.concatenate((a_,b_),axis=1) . array([[1, 4], [2, 5], [3, 6]]) . np.vstack((a,b)) . array([[1, 2, 3], [4, 5, 6]]) . np.vstack((a,b)).transpose() . array([[1, 4], [2, 5], [3, 6]]) . np.hstack((a,b)).reshape((2,3)).transpose() . array([[1, 4], [2, 5], [3, 6]]) . shallow copy . deep copy . a=np.array([10,20,30]) . b=a . b . array([10, 20, 30]) . b[0]=909 . b . array([909, 20, 30]) . a . array([909, 20, 30]) . b is a . True . 즉 같은 메모리에 이름만 다르게 저장된 것 . a=np.array([1,2,3,4]) . b=a.view() . b . array([1, 2, 3, 4]) . b is a . False . b[0]=123123 . a . array([123123, 2, 3, 4]) . b . array([123123, 2, 3, 4]) . shallow copy를 했음에도 같이 업데이트 되어버림 . b.shape=(2,2) . b . array([[123123, 2], [ 3, 4]]) . b[0][1]=111 . b . array([[123123, 111], [ 3, 4]]) . a . array([123123, 111, 3, 4]) . 즉 shallow copy란 메모리 상에 data는 같이 공유하지만 array의 shape은 공유 X . 그렇다면 deep copy? . a=np.array([10,20,30,40]) . b=a.copy() . b[0]=8999 . a . array([10, 20, 30, 40]) . b . array([8999, 20, 30, 40]) . a is b . False . b.base is a . False . 즉 b만의 온전한 데이터를 만들 수 있음 . . a=np.array([55,0,12,3,4]) . # 여기선 0, 즉 FALSE값이 들어있기 때문에 FALSE로 나올 것 a.all() . False . a.any() . True . a.nonzero() . (array([0, 2, 3, 4], dtype=int64),) . np.where(a&gt;0) . (array([0, 2, 3, 4], dtype=int64),) . np.where(a==0) . (array([1], dtype=int64),) . np.where(a!=0) . (array([0, 2, 3, 4], dtype=int64),) . data filtering에 유용하게 사용될 것 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/24/intro.html",
            "relUrl": "/2021/12/24/intro.html",
            "date": " • Dec 24, 2021"
        }
        
    
  
    
        ,"post7": {
            "title": "2022/12/23/THU",
            "content": "s=&#39;&#39;&#39;python n n&#39;&#39;&#39; # 이렇게 해도 되고 직접 enter로 다음 줄로 넘겨도 됨 . s . &#39;python n n&#39; . print(s) . python . &#39;&#39;&#39; =&gt; 긴 str배정시에 사용 | . s=&#39;python&#39; . s.capitalize() . &#39;Python&#39; . s.find(&#39;y&#39;) . 1 . s.find(&#39;a&#39;) . -1 . s.index(&#39;t&#39;) . 2 . index 또는 find 사용시 단어가 중복되면 처음 거 기준 출력 | . a=&#39;pyathaon&#39; . a.find(&#39;a&#39;) . 2 . a.index(&#39;a&#39;) . 2 . a.isalpha() . True . s=&#39;asd342&#39; . s.isalnum() . True . a=&#39;python 3&#39; . a.isalnum() . False . s=&#39;123&#39; . # 십진법! s.isdecimal() . True . s=&#39;223311.3&#39; . s.isdecimal() . False . s.isdigit() . False . s.isnumeric() . False . s=&#39;123123123&#39; . s.isdecimal() . True . a=&#39;2034&#39; . a.isdigit() . True . a=&#39;3 u00B3&#39; . a . &#39;3³&#39; . a.isdecimal() . False . a.isdigit() . True . a.isnumeric() . True . a=&#39; u00BC&#39; . a . &#39;¼&#39; . a.isdecimal() . False . a.isdigit() . False . a.isnumeric() . True . a=&#39;Python&#39; . a.islower() . False . a.isupper() . False . 중요 | . a=&#39;PythonP&#39; . a.replace(&#39;P&#39;,&#39;Q&#39;) . &#39;QythonQ&#39; . 중요 | . a=&#39;I like python&#39; . # space 기준으로 나눠서 리스트化 a.split(&#39; &#39;) . [&#39;I&#39;, &#39;like&#39;, &#39;python&#39;] . a=&#39;I,like,python&#39; . a.split(&#39;,&#39;) . [&#39;I&#39;, &#39;like&#39;, &#39;python&#39;] . str에서 다음줄로 내릴 때 . a=&#39;I like python nHe likes python nfucking python&#39; . a . &#39;I like python nHe likes python nfucking python&#39; . print(a) . I like python He likes python fucking python . a.splitlines() . [&#39;I like python&#39;, &#39;He likes python&#39;, &#39;fucking python&#39;] . b=a.splitlines() . b[0] . &#39;I like python&#39; . b[0].upper() . &#39;I LIKE PYTHON&#39; . b[0].count(&#39;L&#39;) . 0 . . s=&#39;python&#39; . a=3 . print(s,a) . python 3 . print(s,str(a)) . python 3 . print(s+str(a)) . python3 . print(s + &#39; &#39; + str(a)) . python 3 . print(s,str(a)) . python 3 . Format . s=&#39;Python {}&#39; . s.format(25) . &#39;Python 25&#39; . s.format(1+5) . &#39;Python 6&#39; . s=&#39;Python {1} + {0}&#39; . s.format(3,&#39;asdas&#39;) . &#39;Python asdas + 3&#39; . s=&#39;Python {0} {1}&#39; . s.format(3,&#39;asd&#39;) . &#39;Python 3 asd&#39; . s=&#39;Python {1} {0}&#39; . s.format(3,&#39;asd&#39;) . &#39;Python asd 3&#39; . s= &#39;My name is {} I am {} years old&#39; . s.format(&#39;asd&#39;,12) . &#39;My name is asd I am 12 years old&#39; . print(&#39;python 3.8&#39;) . python 3.8 . ver=3.8 . print(&#39;python&#39;, ver) . python 3.8 . print(&#39;python&#39; + str(ver)) . python3.8 . print(&#39;python{}&#39;.format(ver)) . python3.8 . s=&#39;python{}&#39;.format(ver) . print(s) . python3.8 . . data=4321.123456 . print(&#39;DATA&#39;+str(data)) . DATA4321.123456 . print(&#39;DATA&#39;, data) . DATA 4321.123456 . print(&#39;DATA &#39;+str(data)) . DATA 4321.123456 . print(&#39;DATA= &#39;+str(data)) . DATA= 4321.123456 . print(&#39;DATA={}&#39;.format(data)) . DATA=4321.123456 . 중요 | . {0:&lt;10} =&gt; {0} 값을 &quot;:&lt;10&quot; 10자리로 표현할건데 왼쪽 정렬 | {1:&gt;5} =&gt; {1} 값을 &quot;:&gt;5&quot; 5자리로 표현할건데 오른쪽 정렬 | :^10 = 가운데 정렬 | . print(&#39;DATA= {:.2f}&#39;.format(data)) . DATA= 4321.12 . print(&#39;DATA= {:.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:4.0f}&#39;.format(data)) . DATA=4321 . print(&#39;DATA={:5.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:6.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:7.0f}&#39;.format(data)) . DATA= 4321 . print(&#39;DATA={:,}&#39;.format(data)) . DATA=4,321.123456 . data2=454654456.1213546 . print(&#39;DATA={:,}&#39;.format(data2)) . DATA=454,654,456.1213546 . . data자체가 float이라서 d입력하면 오류가 발생 | . int는 소수점 없으니까 .4d 이렇게 입력하면 오류 그냥 4d로 입력 | . print(&#39;DATA={:4d}&#39;.format(int(data))) . DATA=4321 . print(&#39;DATA={:5d}&#39;.format(int(data))) . DATA= 4321 . print(&#39;DATA={:8d}&#39;.format(int(data))) . DATA= 4321 . scientific notation : e라는 것을 사용하여 수를 표현해줌 | . print(&#39;data = {:e}&#39;.format(data)) . data = 4.321123e+03 . % 이용해보자 | . print(&#39;DATA=%(x)f&#39; % {&#39;x&#39; : data}) . DATA=4321.123456 . print(&#39;DATA=%(x).0f&#39; % {&#39;x&#39; : data}) . DATA=4321 . print(&#39;DATA=%(x).2f&#39; % {&#39;x&#39; : data}) . DATA=4321.12 . print(&#39;DATA=%(x)7.0f&#39; % {&#39;x&#39; : data}) . DATA= 4321 . print(&#39;DATA=%(x)8.3f&#39; % {&#39;x&#39; : data}) . DATA=4321.123 . print(&#39;DATA=%(x)8.0f&#39; % {&#39;x&#39; : data}) . DATA= 4321 . . import math math.pi . 3.141592653589793 . import numpy as np np.pi . 3.141592653589793 . math.inf . inf . np.inf . inf . math.nan #숫자가 아님을 표현할 때 . nan . np.nan . nan . math.e . 2.718281828459045 . math.floor(math.pi) . 3 . math.ceil(math.pi) . 4 . math.sqrt(math.pi) . 1.7724538509055159 . math.log(10) . 2.302585092994046 . math.log(math.e) . 1.0 . math.log10(10) . 1.0 . p=math.pi . math.sin(p/2) . 1.0 . math.sin(2*p) . -2.4492935982947064e-16 . x_degree=90 . x_radian=x_degree*(math.pi/180) . x_radian #pi/2랑 동일 . 1.5707963267948966 . math.radians(90) . 1.5707963267948966 . math.pow(2,3) . 8.0 . pow(2,3) . 8 . 2**3 . 8 . x=2 . math.isinf(x) . False . math.isnan(x) . False . math.fsum([1,2,3]) . 6.0 . # error 발생 # 원소가 int일때만 가능 . . file - input &amp; output . import os . os.chdir(&#39;c: test&#39;) . os.mkdir(&#39;temp4&#39;) . os.chdir(&#39;temp4&#39;) . os.getcwd() . &#39;c: test temp4&#39; . os.chdir(&#39;..&#39;) . os.getcwd() . &#39;c: test&#39; . os.chdir(&#39;temp&#39;) . os.getcwd() . &#39;c: test temp&#39; . os.chdir(&#39;.&#39;) . os.getcwd() . &#39;c: test temp&#39; . os.mkdir(&#39;dir0&#39;) . os.mkdir(&#39;dir3&#39;) . os.mkdir(&#39;dir4&#39;) . os.getcwd() . &#39;c: test temp&#39; . os.listdir() . [&#39;dir0&#39;, &#39;dir1&#39;, &#39;dir2&#39;, &#39;dir3&#39;, &#39;dir4&#39;, &#39;file1.txt&#39;, &#39;file2.txt&#39;, &#39;file3.txt&#39;, &#39;file4.txt&#39;] . os.rename(&#39;dir0&#39;,&#39;dir100&#39;) . os.listdir() . [&#39;dir1&#39;, &#39;dir100&#39;, &#39;dir2&#39;, &#39;dir3&#39;, &#39;dir4&#39;, &#39;file1.txt&#39;, &#39;file2.txt&#39;, &#39;file3.txt&#39;, &#39;file4.txt&#39;] . os.rmdir(&#39;dir100&#39;) . os.listdir() . [&#39;dir1&#39;, &#39;dir2&#39;, &#39;dir3&#39;, &#39;dir4&#39;, &#39;file1.txt&#39;, &#39;file2.txt&#39;, &#39;file3.txt&#39;, &#39;file4.txt&#39;] . import sys . # 파이썬에서 사용가능한 모듈들을 불러준 것 . # sys.path . os.chdir(&#39;C: Users ehfus Downloads python Introduction&#39;) . os.chdir(&#39;c: test temp&#39;) . os.getcwd() . &#39;c: test temp&#39; . . f=open(&#39;file1.txt&#39;,&#39;w&#39;)#파일 작성 . f.closed . False . f.write(&#39;fucking&#39;) . 7 . f.close() . f.closed . True . with open(&#39;file2.txt&#39;,&#39;w&#39;) as f: f.write(&#39;sibal n&#39;) f.write(&#39;jotgatne n&#39;) f.write(&#39;just joke n&#39;) . f.closed . True . fid=open(&#39;file2.txt&#39;,&#39;r&#39;) . fid.read() . &#39;sibal njotgatne njust joke n&#39; . fid.close() . fid.closed . True . fid=open(&#39;file2.txt&#39;,&#39;r&#39;) . fid.readline() . &#39;sibal n&#39; . fid.readline() . &#39;jotgatne n&#39; . fid.readline() . &#39;just joke n&#39; . fid.readline() . &#39;&#39; . 한 줄씩 불러옴 . fid.close() . fid=open(&#39;file2.txt&#39;,&#39;r&#39;) . data=[] . data.append(fid.readline()) . data.append(fid.readline()) . data.append(fid.readline()) . data . [&#39;sibal n&#39;, &#39;jotgatne n&#39;, &#39;just joke n&#39;] . 자동화 . data=[&#39;string1&#39;,&#39;string2&#39;,&#39;string3&#39;] . import json . f=open(&#39;file3.txt&#39;,&#39;w&#39;) . json.dump(data,f) . f.close() . f=open(&#39;file3.txt&#39;,&#39;r&#39;) . x=json.load(f) . x . [&#39;string1&#39;, &#39;string2&#39;, &#39;string3&#39;] . f.close() . import pickle . f=open(&#39;file4.txt&#39;,&#39;wb&#39;) # 바이너리로 쓰겠다 . 용량을 작게 할 수 있다는 장점이 있음 . pickle.dump(data,f) . f.close() . f=open(&#39;file4.txt&#39;,&#39;rb&#39;) # 바이너리 불러옴 . x= pickle.load(f) . x . [&#39;string1&#39;, &#39;string2&#39;, &#39;string3&#39;] . f.close() .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/23/intro.html",
            "relUrl": "/2021/12/23/intro.html",
            "date": " • Dec 23, 2021"
        }
        
    
  
    
        ,"post8": {
            "title": "2021/12/22/WED",
            "content": "&#51088;&#47308;&#54805; . 정수(int), 소수(float), 복소수(complex), 참거짓(bool,True,False), 문자(str) | . 문자형(str) &gt; 따옴표 하나 혹은 두개 | . &#39;a&#39;,&quot;hello&quot; # str이 tuple로 묶여있음 . (&#39;a&#39;, &#39;hello&#39;) . 자료의 형태를 알고 싶을 때 | . type(True) . bool . 자료형 변환 | . int() . 0 . str() . &#39;&#39; . bool() . False . int(1) . 1 . int(1.3) . 1 . str -&gt; int 또는 float으로 변경 가능 | . int(&#39;1&#39;) . 1 . float(&#39;3.14&#39;) . 3.14 . . float(&#39;-inf&#39;) . -inf . complex(1) . (1+0j) . complex(3+5j) . (3+5j) . complex(3,5.5) . (3+5.5j) . complex(&#39;1+3j&#39;) . (1+3j) . str(1) . &#39;1&#39; . str(2+5j) # 괄호랑 플러스,j모두 원소 하나하나로 들어감 . &#39;(2+5j)&#39; . bool(-0.8) . True . bool(&#39;&#39;) . False . bool(123) # 0이 아닌 다른 수는 모두 True . True . bool(&#39;aasdss&#39;) . True . bool(0) . False . bool(float(&#39;inf&#39;)) . True . float(&#39;inf&#39;),bool(&#39;-inf&#39;),complex(&#39;inf&#39;) . (inf, True, (inf+0j)) . &#50672;&#49328; . 1+1,3-2,5*2,5/2 . (2, 1, 10, 2.5) . 5//2 . 2 . 5%2 . 1 . divmod(5,3) # 원소 2개인 tuple로 들어감 . (1, 2) . abs(-232) . 232 . pow(5,4),5**4 . (625, 625) . &#39;asdasd&#39;+&#39;asdfeq&#39; . &#39;asdasdasdfeq&#39; . &#39;asdasd&#39;*2 . &#39;asdasdasdasd&#39; . 문자형이 다른 건 더할 수 없음 | . &#39;asdasd&#39;+str(235456) . &#39;asdasd235456&#39; . True+True . 2 . *** 비교 연산 =&gt; BOOL형태로 출력됨 | . 1&lt;0 . False . 2==3 . False . 1!=3 # 틀렸으니 맞다고 나올 것 . True . # False라고 나오긴 함 # 그런데 is나 is not은 원래 자료형이 같고 다른지를 물을 때 사용함 . type(&#39;123&#39;) is not type(True) . True . . True and False . False . True and False and True . False . 거짓이 하나라도 있으면 거짓 처리 | . True or False . True . True or False or False . True . 참이 하나라도 있으면 참 처리 | . not True . False . 참과 거짓을 반대로 바꿔주는 기능 | . 100 and 5 . 5 . True and 3 . 3 . 34 and True . True . 34 and 2 . 2 . 둘다 참일 경우(1이상인 수 혹은 True)일 땐 뒤에 걸 출력하는 것 같음 | . False and 3 . False . 0 and 100 # 하나 거짓 -&gt; 거짓 처리 . 0 . 이럴 땐 무조건 False출력 | . 1 or 100 . 1 . 100 or 1 . 100 . 100 or 1 or 300 . 100 . 3 or 1 or 45 or 0 . 3 . or 사용시엔 하나라도 참이 섞여있으면 그 중 가장 큰 참값을 출력함 | . 1 and 0 and 100 . 0 . 0(False)이 하나 있어서 0 출력 | . 1 and 5 or 100 . 5 . 1 and 5 or 100 and 1 or 3 and 100 . 5 . and 먼저 수행하는 것 같음 | . Bitwise :&#51060;&#51652;&#48277; . 2 #십진법 . 2 . bin(2) # 이진법 . &#39;0b10&#39; . bin(3) . &#39;0b11&#39; . bin(12) . &#39;0b1100&#39; . &amp; . 10&amp;6 . 2 . 10과 6을 2진법으로 처리한 후 겹치는 자리만 뽑아낸 것 | . bin(10) . &#39;0b1010&#39; . bin(6) . &#39;0b110&#39; . bin(10&amp;6) . &#39;0b10&#39; . 10|6 . 14 . bin(10|6) . &#39;0b1110&#39; . bin(10^6) . &#39;0b1100&#39; . bin(6&lt;&lt;2) . &#39;0b11000&#39; . bin(6&gt;&gt;2) . &#39;0b1&#39; . 6&gt;&gt;2 . 1 . &#48320;&#49688; . a=1 a . 1 . print(a) . 1 . b=3.225 . type(b) . float . b=546548 . b # b의 정의가 업데이트 . 546548 . d=True . print(d) . True . b=a . b # 다른 변수로 해당 변수를 업데이트 할 수 있음 . 1 . a=5 . a . 5 . b . 1 . a가 바뀌어도 a로 업데이트 된 b는 그 전 a의 자료인 1로 그대로 유지 중 . length=2 width=3 area=length*width . x=1 . y=2*x . y . 2 . a=3 . bin(a) . &#39;0b11&#39; . a.bit_length() . 2 . b=10 . bin(b) . &#39;0b1010&#39; . b.bit_length() . 4 . c=1+2j . d=c.conjugate() . d . (1-2j) . d.imag . -2.0 . c . (1+2j) . c.real # c 안의 실수 . 1.0 . c.imag # c 안의 허수 . 2.0 . a=1 . a+=1 # a에 있는 값을 1만큼 올려서 저장 . a . 2 . a-=10 . a . -8 . name=&#39;tom&#39; . name.capitalize() # 맨 앞을 대문자 처리 . &#39;Tom&#39; . name.count(&#39;2&#39;) #name이라는 변수에 2 몇개?, 대문자 소문자도 구별해서 카운트함 . 0 . name.count(&#39;o&#39;) . 1 . name.split(&#39;o&#39;) # o 없애고 나눠줌 # 리스트 형태로 저장됨 . [&#39;t&#39;, &#39;m&#39;] . a=name.split(&#39;o&#39;) . type(a[0]) . str . a[1]=&#39;o&#39; . a.append(&#39;m&#39;) # str, list에서 가능함 . a . [&#39;t&#39;, &#39;o&#39;, &#39;m&#39;] . # split은 str에서만 가능한가봄 . &#39;asdasd&#39;.capitalize() . &#39;Asdasd&#39; . a=&#39;i &#39;m student&#39; . a . &#34;i&#39;m student&#34; . 백 슬러시 다음에 심볼 적으면 심볼로 인식 | . input(&#39;enter: &#39;) . &#39;55&#39; . a=input(&#39;enter: &#39;) . a # str으로 저장됨 . &#39;55&#39; . age=int(input(&#39;enter your age: &#39;)) . age # int로 저장됨 . 565 . enter your age 이 부분은 그냥 user한테 input값 받아올 때 안내문 같은 거고 실제로 저장되는 건 입력값만 str으로 저장됨 | . del age . 변수 지우기 . a=1 b=3 a==b . False . a.__eq__(b) # a==b랑 동일 . False . a,b=10,134 # tuple을 의미하는 건 아님 . a,b=b,a . a와 b 교환 | . . str=1 . str . 1 . # error 발생 =&gt; 원래 내장 함수인 str이 위셀에서 변수명으로 저장됨으로써 함수기능을 상실함 . 즉 파이썬과 지원되는 함수와 동일한 변수명 사용하면 안 됨 . del str . Container . list. tuple. set. frozenset. dictionary. . list (수정 가능) | . asd=[10,25,&#39;123&#39;,True] # 자료형 혼합 가능 . asdasd=list([10,25,&#39;123&#39;,True]) # 이 방법으로 list만들 땐 꼭 대괄호로 묶어줘야 함 . tuple (수정 불가) | . qwe=(12,22.1,&#39;qwe&#39;) . qwe . (12, 22.1, &#39;qwe&#39;) . qweqwe=tuple([1,2,3,&#39;asdasd&#39;,True]) # 대괄호로 묶어줘야함 . qweqwe . (1, 2, 3, &#39;asdasd&#39;, True) . list와 tuple은 sequence자료형 | . vip_names = [&#39;c&#39;,&#39;d&#39;,&#39;a&#39;] . vip_names[0]=&#39;랴차&#39; . vip_names . [&#39;랴차&#39;, &#39;d&#39;, &#39;a&#39;] . 이렇게 list는 자료 수정 가능 | . slicing . my_list1=[12,123,123,123,42,14] . my_list1[0:2] #0,1번 원소 추출 . [12, 123] . my_list1[:] # 모든 자료 . [12, 123, 123, 123, 42, 14] . my_list1[::2] # 모든 자료형태에서 2단위로 추출 . [12, 123, 42] . my_list1[:3:2] # 0,1,2원소를 2단위로 추출 . [12, 123] . my_list1[::2] . [12, 123, 42] . my_list1[-1] . 14 . my_list1[-5:-1] # -1값은 해당 X . [123, 123, 123, 42] . my_list1[-5] . 123 . my_list1[-1::-1] # 뒤에서부터 가져올 땐 단위도 - 붙여줘야 함 . [14, 42, 123, 123, 123, 12] . my_list1[-1:2:-1] # 두번째 인덱스 전까지 뒤로 추출 # 시작을 -1로 해서 2로 끝났으니 마지막에 호출 단위를 -붙여서 꼭 해줘야함 # 호출단위를 안 쓰거나 플러스로 하면 아무것도 출력 안 됨 . [14, 42, 123] . my_list1[-1:1:-1] # 뒤에서부터 가져오기 뒤로 . [14, 42, 123, 123] . my_list1 . [12, 123, 123, 123, 42, 14] . my_list1[-4:5:1] . [123, 123, 42] . my_list2 = [[1,2,3,4,5],[1232]] . my_list4 = [[1,2,3,4,5], [1,2,3,4], &quot;ㅁㄴㅇㅁㄴㅇ&quot;] # 이렇게 복잡할 땐 한줄 내려서 입력해도 가능하다 . 리스트 중첩 가능 | . my_list4[0][3] . 4 . my_list4[1][::2] . [1, 3] . my_list5 = [ [10,20,[100,200,300]], [40,50,60] ] . my_list5[0][2][2] # 리스트 중첩 후 원소 불러오기 . 300 . a=[1,2] b=[123,2323] . a+b . [1, 2, 123, 2323] . a=[[1,2],[1,2,3]] . b=[[1,2,&#39;s&#39;],[1,2,3]] . a+b . [[1, 2], [1, 2, 3], [1, 2, &#39;s&#39;], [1, 2, 3]] . a*2 . [[1, 2], [1, 2, 3], [1, 2], [1, 2, 3]] . old_a=[1,2,3] . new_a=old_a . old_a[0]=2 . new_a[0] . 2 . new_a=old_a는 같은 메모리를 공유함으로써 new_a 와 old_a 모두 동시 수정됨 | . 대책은? | . new_a=old_a.copy() . new_a[0]=&#39;1&#39; . new_a . [&#39;1&#39;, 2, 3] . old_a . [2, 2, 3] . extend | . a=[1,2,3] b=[2,3,4] . a+b . [1, 2, 3, 2, 3, 4] . a.extend(b) . a . [1, 2, 3, 2, 3, 4] . a=[1,2,3] b=[2,3,4] . a+=b . a . [1, 2, 3, 2, 3, 4] . asd=[&#39;asds&#39;,&#39;sdasd&#39;,&#39;sd&#39;] . 이 자료에 원소 추가하기 | . asd.append(&#39;e&#39;) . asd . [&#39;asds&#39;, &#39;sdasd&#39;, &#39;sd&#39;, &#39;e&#39;] . asd.remove(&#39;e&#39;) . asd . [&#39;asds&#39;, &#39;sdasd&#39;, &#39;sd&#39;] . 인덱스로 원소 지우기 -&gt; pop사용 | . asd.pop(1) # &#39;sdasd&#39;가 삭제됨 . &#39;sdasd&#39; . asd . [&#39;asds&#39;, &#39;sd&#39;] . 초기화 | . asd.clear() . asd . [] . asd.insert(0,&#39;sds&#39;) . asd . [&#39;sds&#39;] . str에선 append였음 | list에선 insert , 사용할 때 5자리에 넣고 싶어도 마지막 자리에 순서대로 추가 됨 | . asd.index(&#39;sds&#39;) # 자리 번호 알기 . 0 . asd.count(&#39;sds&#39;) # 몇번 들어가 있는지 . 1 . a=[&#39;a&#39;,&#39;c&#39;,&#39;f&#39;,&#39;b&#39;] . a.sort() # 정렬중 . a # 숫자와, bool도 정렬가능 . [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;f&#39;] . a=[2,&#39;False&#39;] . # 이렇게 자료형이 섞여있으면 불가능 # 지금 False가 bool형태가 아니라 str형태로 들어가있음 . asf=[True,123333,0,134] . asf.sort() . asf # 자료형이 안 섞여있으면 가능 . [0, True, 134, 123333] . qwe=[1,2,3] . qwe.reverse() . qwe . [3, 2, 1] . qwe[-1::-1] # reverse와 동일 . [1, 2, 3] . . set | . my_set1={1,2,3} . my_set2={False,5,54} . my_set3={False,5,5} . my_set3 . {False, 5} . 집합처럼 중복 원소는 하나로 처리 . set은 인덱스를 지원하지 않음 . alist=[2,3,4,1324] . my_set32412=set(alist) . my_set32412 . {2, 3, 4, 1324} . my_set32412.add(2525) . my_set32412 . {2, 3, 4, 1324, 2525} . my_set32412.update([546]) . my_set32412 . {2, 3, 4, 546, 1324, 2525} . 이렇게 순서대로 들어가게 됨 | . my_set32412.discard(1324) . my_set32412 . {2, 3, 4, 546, 2525} . my_set32412.remove(2525) . my_set32412 . {2, 3, 4, 546} . 즉 discard와 remove는 동일하나 remove는 이미 없는 값을 또 삭제하려 할 때 error메세지를 보여줌 . a={1,2,3,5} b={6,5,55,4} . a or b . {1, 2, 3, 5} . b or a . {4, 5, 6, 55} . 앞에 있는 거 출력 | . 2|4 . 6 . 이거랑 다른 거 . a|b . {1, 2, 3, 4, 5, 6, 55} . a.union(b) . {1, 2, 3, 4, 5, 6, 55} . b.union(a) . {1, 2, 3, 4, 5, 6, 55} . a&amp;b # 교집합 . {5} . a.intersection(b) . {5} . b.intersection(a) . {5} . a-b . {1, 2, 3} . a.difference(b) . {1, 2, 3} . b.difference(a) . {4, 6, 55} . a^b # 겹치는 거 빼고 출력 . {1, 2, 3, 4, 6, 55} . a.symmetric_difference(b) ## 겹치는 거 빼고 출력 . {1, 2, 3, 4, 6, 55} . b.symmetric_difference(a) # 겹치는 거 빼고 출력 . {1, 2, 3, 4, 6, 55} . a={1,2,3,4,5} b={1} . b.issubset(a) #b가 a의 부분집합? . True . a.issubset(b) # a가 b의 부분집합? . False . a.issuperset(b) # a는 b를 포함? . True . b.issuperset(a)# b는 a를 포함? . False . . a=frozenset([1,2,3,4,5]) . b=frozenset([4,5,6,7,8]) . a|b . frozenset({1, 2, 3, 4, 5, 6, 7, 8}) . a&amp;b . frozenset({4, 5}) . # 추가 불가 # frozenset이기 때문에 . c=set([1,2,3,4]) . a&amp;c . frozenset({1, 2, 3, 4}) . asq=[&#39;qw&#39;,&#39;qwa&#39;,&#39;qwsd&#39;] . door1_list = [&#39;qw&#39;] . door2_list = [&#39;qwa&#39;] . door1_list in asq . False . door1_list . [&#39;qw&#39;] . 왜 false? | . door1_list[0] . &#39;qw&#39; . door1_list[0] in asq . True . all=set(asq) . all . {&#39;qw&#39;, &#39;qwa&#39;, &#39;qwsd&#39;} . d1=set(door1_list) . d2=set(door2_list) . d1.issubset(all) . True . d2.issubset(all) . True . d_combine=d1 |d2 . d_combine . {&#39;qw&#39;, &#39;qwa&#39;} . d_combine.issubset(all) # 부분집합? . True . all-d_combine . {&#39;qwsd&#39;} . dic =&gt; key,value로 이루어져있다 | . : 이 들어가면서 set이랑은 다름 | . type(my_dict) . dict . my_dict={&#39;a&#39;:&#39;qewqwe&#39;,&#39;b&#39;:&#39;qewe&#39;,&#39;c&#39;:&#39;qwqwe&#39;} . my_dict[&#39;c&#39;] . &#39;qwqwe&#39; . 즉 따라서 순서는 중요하지 않음 . number={&#39;1&#39;:&#39;12312123123&#39;,&#39;asas&#39;:&#39;12313&#39;,&#39;asdad&#39;:&#39;12323&#39;} . number[&#39;asas&#39;] . &#39;12313&#39; . number.get(&#39;asas&#39;) . &#39;12313&#39; . number[&#39;asas&#39;]=&#39;fucking&#39; # 자료 업데이트 . number.update({&#39;1&#39;:&#39;asdasdddd&#39;}) # 자료 업데이트 . number[&#39;1&#39;] . &#39;asdasdddd&#39; . &#39;1&#39; in number # key가 들어가있는지 안 들어가 있는지 . True . number.pop(&#39;1&#39;) # 삭제 . &#39;asdasdddd&#39; . number . {&#39;asas&#39;: &#39;fucking&#39;, &#39;asdad&#39;: &#39;12323&#39;} . number.clear() . number . {} . . alist=[1,2,3,4,5] atuple=(1,2,3,4,5) aset={1,2,3,4,5} . len(alist) # 컨테이너의 값 개수를 알 수 있음 . 5 . max(aset) . 5 . min(alist) . 1 . 6 in atuple # 값 들어가있는지 체크하기 . False . 555 not in atuple . True . . list unpacking . a=[&#39;a&#39;,23,&#39;asf&#39;] . name=a[0] . age=a[1] . lan=a[2] . 이걸 한 번에 = list unpacking | . name,age,lan=a . 리스트 a에서 처음 원소만 자료로 받고 나머지는 그에 헤당한 자료형으로 남겨놓고 싶을 때 | . name, *rest = a . 응용하면 . *rest,name=a . name . &#39;asf&#39; . first,second,*rest=a . first . &#39;a&#39; . second . 23 . . a=range(0,21,2) # 20까지임 . a . range(0, 21, 2) . type(a) . range . a[2] . 4 . a.index(20) . 10 . a[10] . 20 . a[:5] . range(0, 10, 2) . a[-1] . 20 . list(range(10,51,10)) . [10, 20, 30, 40, 50] . . for i in range(5) : print(i) . 0 1 2 3 4 . for i in range(2,11,2) : print(i) . 2 4 6 8 10 . for i in range(10,2,-2) : print(i) . 10 8 6 4 . for i in range(10,1,-2) : print(i) . 10 8 6 4 2 .",
            "url": "https://rhkrehtjd.github.io/INTROpython/2021/12/22/intro.html",
            "relUrl": "/2021/12/22/intro.html",
            "date": " • Dec 22, 2021"
        }
        
    
  

  
  

  
      ,"page1": {
          "title": "About Me",
          "content": "This website is powered by fastpages 1. . a blogging platform that natively supports Jupyter notebooks in addition to other formats. &#8617; . |",
          "url": "https://rhkrehtjd.github.io/INTROpython/about/",
          "relUrl": "/about/",
          "date": ""
      }
      
  

  

  
  

  

  
  

  

  
  

  
  

  
  

  
      ,"page10": {
          "title": "",
          "content": "Sitemap: {{ “sitemap.xml” | absolute_url }} | .",
          "url": "https://rhkrehtjd.github.io/INTROpython/robots.txt",
          "relUrl": "/robots.txt",
          "date": ""
      }
      
  

}